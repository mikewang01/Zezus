; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\stm32f0xx_tim.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f0xx_tim.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\stm32f0xx_tim.crf ..\arch\arm\stm32f05x\lib\src\stm32f0xx_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;190      */
;;;191    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  49f8              LDR      r1,|L1.996|
;;;192    {
000002  b510              PUSH     {r4,lr}
;;;193      /* Check the parameters */
;;;194      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;195    
;;;196      if (TIMx == TIM1)
000004  4288              CMP      r0,r1
000006  d102              BNE      |L1.14|
;;;197      {
;;;198        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  14c4              ASRS     r4,r0,#19
;;;199        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
00000c  e030              B        |L1.112|
                  |L1.14|
;;;200      }     
;;;201      else if (TIMx == TIM2)
00000e  2101              MOVS     r1,#1
000010  0789              LSLS     r1,r1,#30
000012  4288              CMP      r0,r1
000014  d106              BNE      |L1.36|
;;;202      {
;;;203        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000016  2101              MOVS     r1,#1
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;204        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
00001e  2100              MOVS     r1,#0
000020  2001              MOVS     r0,#1
000022  e008              B        |L1.54|
                  |L1.36|
;;;205      }
;;;206      else if (TIMx == TIM3)
000024  49f0              LDR      r1,|L1.1000|
000026  4288              CMP      r0,r1
000028  d108              BNE      |L1.60|
;;;207      {
;;;208        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00002a  2101              MOVS     r1,#1
00002c  2002              MOVS     r0,#2
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;209        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000032  2100              MOVS     r1,#0
000034  2002              MOVS     r0,#2
                  |L1.54|
000036  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;210      }
;;;211      else if (TIMx == TIM6)
;;;212      {
;;;213        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
;;;214        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
;;;215      } 
;;;216      else if (TIMx == TIM14) 
;;;217      {       
;;;218        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
;;;219        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
;;;220      }        
;;;221      else if (TIMx == TIM15)
;;;222      {
;;;223        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
;;;224        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
;;;225      } 
;;;226      else if (TIMx == TIM16)
;;;227      {
;;;228        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
;;;229        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
;;;230      } 
;;;231      else
;;;232      {
;;;233        if (TIMx == TIM17)
;;;234        {
;;;235          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
;;;236          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
;;;237        }  
;;;238      }
;;;239         
;;;240    }
00003a  bd10              POP      {r4,pc}
                  |L1.60|
00003c  49eb              LDR      r1,|L1.1004|
00003e  4288              CMP      r0,r1                 ;211
000040  d106              BNE      |L1.80|
000042  2101              MOVS     r1,#1                 ;213
000044  2010              MOVS     r0,#0x10              ;213
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004a  2100              MOVS     r1,#0                 ;214
00004c  2010              MOVS     r0,#0x10              ;214
00004e  e7f2              B        |L1.54|
                  |L1.80|
000050  49e7              LDR      r1,|L1.1008|
000052  4288              CMP      r0,r1                 ;216
000054  d107              BNE      |L1.102|
000056  1584              ASRS     r4,r0,#22             ;218
000058  2101              MOVS     r1,#1                 ;218
00005a  4620              MOV      r0,r4                 ;218
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000060  2100              MOVS     r1,#0                 ;219
000062  4620              MOV      r0,r4                 ;219
000064  e7e7              B        |L1.54|
                  |L1.102|
000066  49e3              LDR      r1,|L1.1012|
000068  4288              CMP      r0,r1                 ;221
00006a  d109              BNE      |L1.128|
00006c  2101              MOVS     r1,#1                 ;223
00006e  040c              LSLS     r4,r1,#16             ;223
                  |L1.112|
000070  4620              MOV      r0,r4                 ;198
000072  f7fffffe          BL       RCC_APB2PeriphResetCmd
000076  2100              MOVS     r1,#0                 ;199
000078  4620              MOV      r0,r4                 ;199
00007a  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L1.126|
00007e  bd10              POP      {r4,pc}
                  |L1.128|
000080  49dd              LDR      r1,|L1.1016|
000082  4288              CMP      r0,r1                 ;226
000084  d102              BNE      |L1.140|
000086  2101              MOVS     r1,#1                 ;228
000088  044c              LSLS     r4,r1,#17             ;228
00008a  e7f1              B        |L1.112|
                  |L1.140|
00008c  49db              LDR      r1,|L1.1020|
00008e  4288              CMP      r0,r1                 ;233
000090  d1f5              BNE      |L1.126|
000092  2101              MOVS     r1,#1                 ;235
000094  048c              LSLS     r4,r1,#18             ;235
000096  e7eb              B        |L1.112|
;;;241    
                          ENDP

                  TIM_TimeBaseInit PROC
;;;251      */
;;;252    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000098  b510              PUSH     {r4,lr}
;;;253    {
;;;254      uint16_t tmpcr1 = 0;
;;;255    
;;;256      /* Check the parameters */
;;;257      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;258      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;259      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;260    
;;;261      tmpcr1 = TIMx->CR1;  
00009a  8802              LDRH     r2,[r0,#0]
;;;262    
;;;263      if((TIMx == TIM1) || (TIMx == TIM2) || (TIMx == TIM3))
00009c  4bd1              LDR      r3,|L1.996|
00009e  4298              CMP      r0,r3
0000a0  d006              BEQ      |L1.176|
0000a2  2401              MOVS     r4,#1
0000a4  07a4              LSLS     r4,r4,#30
0000a6  42a0              CMP      r0,r4
0000a8  d002              BEQ      |L1.176|
0000aa  4ccf              LDR      r4,|L1.1000|
0000ac  42a0              CMP      r0,r4
0000ae  d103              BNE      |L1.184|
                  |L1.176|
;;;264      {
;;;265        /* Select the Counter Mode */
;;;266        tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
0000b0  2470              MOVS     r4,#0x70
0000b2  43a2              BICS     r2,r2,r4
;;;267        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
0000b4  884c              LDRH     r4,[r1,#2]
0000b6  4322              ORRS     r2,r2,r4
                  |L1.184|
;;;268      }
;;;269     
;;;270      if(TIMx != TIM6)
0000b8  4ccc              LDR      r4,|L1.1004|
0000ba  42a0              CMP      r0,r4
0000bc  d003              BEQ      |L1.198|
;;;271      {
;;;272        /* Set the clock division */
;;;273        tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
0000be  4cd0              LDR      r4,|L1.1024|
0000c0  4022              ANDS     r2,r2,r4
;;;274        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
0000c2  890c              LDRH     r4,[r1,#8]
0000c4  4322              ORRS     r2,r2,r4
                  |L1.198|
;;;275      }
;;;276    
;;;277      TIMx->CR1 = tmpcr1;
0000c6  8002              STRH     r2,[r0,#0]
;;;278    
;;;279      /* Set the Autoreload value */
;;;280      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
0000c8  684a              LDR      r2,[r1,#4]
0000ca  62c2              STR      r2,[r0,#0x2c]
;;;281     
;;;282      /* Set the Prescaler value */
;;;283      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
0000cc  880a              LDRH     r2,[r1,#0]
0000ce  8502              STRH     r2,[r0,#0x28]
;;;284        
;;;285      if ((TIMx == TIM1) || (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
0000d0  4298              CMP      r0,r3
0000d2  d008              BEQ      |L1.230|
0000d4  4ac7              LDR      r2,|L1.1012|
0000d6  4290              CMP      r0,r2
0000d8  d005              BEQ      |L1.230|
0000da  4ac7              LDR      r2,|L1.1016|
0000dc  4290              CMP      r0,r2
0000de  d002              BEQ      |L1.230|
0000e0  4ac6              LDR      r2,|L1.1020|
0000e2  4290              CMP      r0,r2
0000e4  d101              BNE      |L1.234|
                  |L1.230|
;;;286      {
;;;287        /* Set the Repetition Counter value */
;;;288        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
0000e6  7a89              LDRB     r1,[r1,#0xa]
0000e8  8601              STRH     r1,[r0,#0x30]
                  |L1.234|
;;;289      }
;;;290    
;;;291      /* Generate an update event to reload the Prescaler and the Repetition counter
;;;292         values immediately */
;;;293      TIMx->EGR = TIM_PSCReloadMode_Immediate;           
0000ea  2101              MOVS     r1,#1
0000ec  8281              STRH     r1,[r0,#0x14]
;;;294    }
0000ee  bd10              POP      {r4,pc}
;;;295    
                          ENDP

                  TIM_TimeBaseStructInit PROC
;;;301      */
;;;302    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
0000f0  2100              MOVS     r1,#0
;;;303    {
;;;304      /* Set the default configuration */
;;;305      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
0000f2  43c9              MVNS     r1,r1
;;;306      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
0000f4  6041              STR      r1,[r0,#4]
0000f6  2100              MOVS     r1,#0
0000f8  8001              STRH     r1,[r0,#0]
;;;307      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
0000fa  8101              STRH     r1,[r0,#8]
;;;308      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
0000fc  8041              STRH     r1,[r0,#2]
;;;309      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
0000fe  7281              STRB     r1,[r0,#0xa]
;;;310    }
000100  4770              BX       lr
;;;311    
                          ENDP

                  TIM_PrescalerConfig PROC
;;;321      */
;;;322    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000102  8501              STRH     r1,[r0,#0x28]
;;;323    {
;;;324      /* Check the parameters */
;;;325      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;326      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;327      
;;;328      /* Set the Prescaler value */
;;;329      TIMx->PSC = Prescaler;
;;;330      /* Set or reset the UG Bit */
;;;331      TIMx->EGR = TIM_PSCReloadMode;
000104  8282              STRH     r2,[r0,#0x14]
;;;332    }
000106  4770              BX       lr
;;;333    
                          ENDP

                  TIM_CounterModeConfig PROC
;;;345      */
;;;346    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000108  8802              LDRH     r2,[r0,#0]
;;;347    {
;;;348      uint16_t tmpcr1 = 0;
;;;349      
;;;350      /* Check the parameters */
;;;351      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;352      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;353      
;;;354      tmpcr1 = TIMx->CR1;
;;;355      /* Reset the CMS and DIR Bits */
;;;356      tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
00010a  2370              MOVS     r3,#0x70
00010c  439a              BICS     r2,r2,r3
;;;357      /* Set the Counter Mode */
;;;358      tmpcr1 |= TIM_CounterMode;
00010e  430a              ORRS     r2,r2,r1
;;;359      /* Write to TIMx CR1 register */
;;;360      TIMx->CR1 = tmpcr1;
000110  8002              STRH     r2,[r0,#0]
;;;361    }
000112  4770              BX       lr
;;;362    
                          ENDP

                  TIM_SetCounter PROC
;;;369      */
;;;370    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
000114  6241              STR      r1,[r0,#0x24]
;;;371    {
;;;372      /* Check the parameters */
;;;373       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;374       
;;;375      /* Set the Counter Register value */
;;;376      TIMx->CNT = Counter;
;;;377    }
000116  4770              BX       lr
;;;378    
                          ENDP

                  TIM_SetAutoreload PROC
;;;384      */
;;;385    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
000118  62c1              STR      r1,[r0,#0x2c]
;;;386    {
;;;387      /* Check the parameters */
;;;388      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;389      
;;;390      /* Set the Autoreload Register value */
;;;391      TIMx->ARR = Autoreload;
;;;392    }
00011a  4770              BX       lr
;;;393    
                          ENDP

                  TIM_GetCounter PROC
;;;399      */
;;;400    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
00011c  6a40              LDR      r0,[r0,#0x24]
;;;401    {
;;;402      /* Check the parameters */
;;;403      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;404      
;;;405      /* Get the Counter Register value */
;;;406      return TIMx->CNT;
;;;407    }
00011e  4770              BX       lr
;;;408    
                          ENDP

                  TIM_GetPrescaler PROC
;;;414      */
;;;415    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000120  8d00              LDRH     r0,[r0,#0x28]
;;;416    {
;;;417      /* Check the parameters */
;;;418      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;419      
;;;420      /* Get the Prescaler Register value */
;;;421      return TIMx->PSC;
;;;422    }
000122  4770              BX       lr
;;;423    
                          ENDP

                  TIM_UpdateDisableConfig PROC
;;;431      */
;;;432    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000124  2202              MOVS     r2,#2
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;436      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;437      
;;;438      if (NewState != DISABLE)
000126  2900              CMP      r1,#0
;;;439      {
;;;440        /* Set the Update Disable Bit */
;;;441        TIMx->CR1 |= TIM_CR1_UDIS;
;;;442      }
;;;443      else
;;;444      {
;;;445        /* Reset the Update Disable Bit */
;;;446        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
000128  8801              LDRH     r1,[r0,#0]
00012a  d001              BEQ      |L1.304|
00012c  4311              ORRS     r1,r1,r2              ;441
00012e  e000              B        |L1.306|
                  |L1.304|
000130  4391              BICS     r1,r1,r2
                  |L1.306|
000132  8001              STRH     r1,[r0,#0]            ;441
;;;447      }
;;;448    }
000134  4770              BX       lr
;;;449    
                          ENDP

                  TIM_UpdateRequestConfig PROC
;;;461      */
;;;462    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000136  2204              MOVS     r2,#4
;;;463    {
;;;464      /* Check the parameters */
;;;465      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;466      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;467      
;;;468      if (TIM_UpdateSource != TIM_UpdateSource_Global)
000138  2900              CMP      r1,#0
;;;469      {
;;;470        /* Set the URS Bit */
;;;471        TIMx->CR1 |= TIM_CR1_URS;
;;;472      }
;;;473      else
;;;474      {
;;;475        /* Reset the URS Bit */
;;;476        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
00013a  8801              LDRH     r1,[r0,#0]
00013c  d001              BEQ      |L1.322|
00013e  4311              ORRS     r1,r1,r2              ;471
000140  e000              B        |L1.324|
                  |L1.322|
000142  4391              BICS     r1,r1,r2
                  |L1.324|
000144  8001              STRH     r1,[r0,#0]            ;471
;;;477      }
;;;478    }
000146  4770              BX       lr
;;;479    
                          ENDP

                  TIM_ARRPreloadConfig PROC
;;;487      */
;;;488    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000148  2280              MOVS     r2,#0x80
;;;489    {
;;;490      /* Check the parameters */
;;;491      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;492      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;493      
;;;494      if (NewState != DISABLE)
00014a  2900              CMP      r1,#0
;;;495      {
;;;496        /* Set the ARR Preload Bit */
;;;497        TIMx->CR1 |= TIM_CR1_ARPE;
;;;498      }
;;;499      else
;;;500      {
;;;501        /* Reset the ARR Preload Bit */
;;;502        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
00014c  8801              LDRH     r1,[r0,#0]
00014e  d001              BEQ      |L1.340|
000150  4311              ORRS     r1,r1,r2              ;497
000152  e000              B        |L1.342|
                  |L1.340|
000154  4391              BICS     r1,r1,r2
                  |L1.342|
000156  8001              STRH     r1,[r0,#0]            ;497
;;;503      }
;;;504    }
000158  4770              BX       lr
;;;505    
                          ENDP

                  TIM_SelectOnePulseMode PROC
;;;515      */
;;;516    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
00015a  8802              LDRH     r2,[r0,#0]
;;;517    {
;;;518      /* Check the parameters */
;;;519      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;520      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;521      
;;;522      /* Reset the OPM Bit */
;;;523      TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
00015c  2308              MOVS     r3,#8
00015e  439a              BICS     r2,r2,r3
000160  8002              STRH     r2,[r0,#0]
;;;524      /* Configure the OPM Mode */
;;;525      TIMx->CR1 |= TIM_OPMode;
000162  8802              LDRH     r2,[r0,#0]
000164  430a              ORRS     r2,r2,r1
000166  8002              STRH     r2,[r0,#0]
;;;526    }
000168  4770              BX       lr
;;;527    
                          ENDP

                  TIM_SetClockDivision PROC
;;;537      */
;;;538    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
00016a  8802              LDRH     r2,[r0,#0]
;;;539    {
;;;540      /* Check the parameters */
;;;541      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;542      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;543      
;;;544      /* Reset the CKD Bits */
;;;545      TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
00016c  4ba4              LDR      r3,|L1.1024|
00016e  401a              ANDS     r2,r2,r3
000170  8002              STRH     r2,[r0,#0]
;;;546      /* Set the CKD value */
;;;547      TIMx->CR1 |= TIM_CKD;
000172  8802              LDRH     r2,[r0,#0]
000174  430a              ORRS     r2,r2,r1
000176  8002              STRH     r2,[r0,#0]
;;;548    }
000178  4770              BX       lr
;;;549    
                          ENDP

                  TIM_Cmd PROC
;;;557      */
;;;558    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
00017a  2900              CMP      r1,#0
;;;559    {
;;;560      /* Check the parameters */
;;;561      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;562      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;563      
;;;564      if (NewState != DISABLE)
;;;565      {
;;;566        /* Enable the TIM Counter */
;;;567        TIMx->CR1 |= TIM_CR1_CEN;
;;;568      }
;;;569      else
;;;570      {
;;;571        /* Disable the TIM Counter */
;;;572        TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
00017c  8801              LDRH     r1,[r0,#0]
00017e  d002              BEQ      |L1.390|
000180  2201              MOVS     r2,#1                 ;567
000182  4311              ORRS     r1,r1,r2              ;567
000184  e001              B        |L1.394|
                  |L1.390|
000186  0849              LSRS     r1,r1,#1
000188  0049              LSLS     r1,r1,#1
                  |L1.394|
00018a  8001              STRH     r1,[r0,#0]            ;567
;;;573      }
;;;574    }
00018c  4770              BX       lr
;;;575    
                          ENDP

                  TIM_BDTRConfig PROC
;;;615      */
;;;616    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
00018e  b510              PUSH     {r4,lr}
;;;617    {
;;;618      /* Check the parameters */
;;;619      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;620      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;621      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;622      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;623      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;624      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;625      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;626      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;627         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;628      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000190  880a              LDRH     r2,[r1,#0]
000192  884b              LDRH     r3,[r1,#2]
000194  88cc              LDRH     r4,[r1,#6]
000196  431a              ORRS     r2,r2,r3
000198  888b              LDRH     r3,[r1,#4]
00019a  4323              ORRS     r3,r3,r4
00019c  431a              ORRS     r2,r2,r3
00019e  890b              LDRH     r3,[r1,#8]
0001a0  431a              ORRS     r2,r2,r3
0001a2  894b              LDRH     r3,[r1,#0xa]
0001a4  8989              LDRH     r1,[r1,#0xc]
0001a6  431a              ORRS     r2,r2,r3
0001a8  430a              ORRS     r2,r2,r1
0001aa  3040              ADDS     r0,r0,#0x40
0001ac  8082              STRH     r2,[r0,#4]
;;;629                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;630                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;631                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;632    }
0001ae  bd10              POP      {r4,pc}
;;;633    
                          ENDP

                  TIM_BDTRStructInit PROC
;;;639      */
;;;640    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
0001b0  2100              MOVS     r1,#0
;;;641    {
;;;642      /* Set the default configuration */
;;;643      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
0001b2  8001              STRH     r1,[r0,#0]
;;;644      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
0001b4  8041              STRH     r1,[r0,#2]
;;;645      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
0001b6  8081              STRH     r1,[r0,#4]
;;;646      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
0001b8  80c1              STRH     r1,[r0,#6]
;;;647      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
0001ba  8101              STRH     r1,[r0,#8]
;;;648      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
0001bc  8141              STRH     r1,[r0,#0xa]
;;;649      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
0001be  8181              STRH     r1,[r0,#0xc]
;;;650    }
0001c0  4770              BX       lr
;;;651    
                          ENDP

                  TIM_CtrlPWMOutputs PROC
;;;658      */
;;;659    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
0001c2  3040              ADDS     r0,r0,#0x40
;;;660    {
;;;661      /* Check the parameters */
;;;662      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;663      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;664      if (NewState != DISABLE)
0001c4  2900              CMP      r1,#0
;;;665      {
;;;666        /* Enable the TIM Main Output */
;;;667        TIMx->BDTR |= TIM_BDTR_MOE;
;;;668      }
;;;669      else
;;;670      {
;;;671        /* Disable the TIM Main Output */
;;;672        TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
0001c6  8881              LDRH     r1,[r0,#4]
0001c8  d003              BEQ      |L1.466|
0001ca  2201              MOVS     r2,#1                 ;667
0001cc  03d2              LSLS     r2,r2,#15             ;667
0001ce  4311              ORRS     r1,r1,r2              ;667
0001d0  e001              B        |L1.470|
                  |L1.466|
0001d2  0449              LSLS     r1,r1,#17
0001d4  0c49              LSRS     r1,r1,#17
                  |L1.470|
0001d6  8081              STRH     r1,[r0,#4]            ;667
;;;673      }  
;;;674    }
0001d8  4770              BX       lr
;;;675    
                          ENDP

                  TIM_OC1Init PROC
;;;730      */
;;;731    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
0001da  b570              PUSH     {r4-r6,lr}
;;;732    {
;;;733      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;734       
;;;735      /* Check the parameters */
;;;736      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;737      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;738      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;739      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;740     /* Disable the Channel 1: Reset the CC1E Bit */
;;;741      TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
0001dc  8c02              LDRH     r2,[r0,#0x20]
0001de  0852              LSRS     r2,r2,#1
0001e0  0052              LSLS     r2,r2,#1
0001e2  8402              STRH     r2,[r0,#0x20]
;;;742      /* Get the TIMx CCER register value */
;;;743      tmpccer = TIMx->CCER;
0001e4  8c04              LDRH     r4,[r0,#0x20]
;;;744      /* Get the TIMx CR2 register value */
;;;745      tmpcr2 =  TIMx->CR2;
0001e6  8882              LDRH     r2,[r0,#4]
;;;746      
;;;747      /* Get the TIMx CCMR1 register value */
;;;748      tmpccmrx = TIMx->CCMR1;
0001e8  8b03              LDRH     r3,[r0,#0x18]
;;;749        
;;;750      /* Reset the Output Compare Mode Bits */
;;;751      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
0001ea  2570              MOVS     r5,#0x70
0001ec  43ab              BICS     r3,r3,r5
;;;752      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
0001ee  089b              LSRS     r3,r3,#2
;;;753    
;;;754      /* Select the Output Compare Mode */
;;;755      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
0001f0  880d              LDRH     r5,[r1,#0]
0001f2  009b              LSLS     r3,r3,#2              ;752
0001f4  431d              ORRS     r5,r5,r3
;;;756      
;;;757      /* Reset the Output Polarity level */
;;;758      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
0001f6  2302              MOVS     r3,#2
0001f8  439c              BICS     r4,r4,r3
;;;759      /* Set the Output Compare Polarity */
;;;760      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
0001fa  898e              LDRH     r6,[r1,#0xc]
;;;761      
;;;762      /* Set the Output State */
;;;763      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
0001fc  884b              LDRH     r3,[r1,#2]
0001fe  4326              ORRS     r6,r6,r4              ;760
;;;764        
;;;765      if((TIMx == TIM1) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17))
000200  4c78              LDR      r4,|L1.996|
000202  4333              ORRS     r3,r3,r6              ;763
000204  42a0              CMP      r0,r4
000206  d008              BEQ      |L1.538|
000208  4c7a              LDR      r4,|L1.1012|
00020a  42a0              CMP      r0,r4
00020c  d005              BEQ      |L1.538|
00020e  4c7a              LDR      r4,|L1.1016|
000210  42a0              CMP      r0,r4
000212  d002              BEQ      |L1.538|
000214  4c79              LDR      r4,|L1.1020|
000216  42a0              CMP      r0,r4
000218  d10d              BNE      |L1.566|
                  |L1.538|
;;;766      {
;;;767        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;768        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;769        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;770        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;771        
;;;772        /* Reset the Output N Polarity level */
;;;773        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
00021a  2408              MOVS     r4,#8
00021c  43a3              BICS     r3,r3,r4
;;;774        /* Set the Output N Polarity */
;;;775        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
00021e  89cc              LDRH     r4,[r1,#0xe]
000220  431c              ORRS     r4,r4,r3
;;;776        
;;;777        /* Reset the Output N State */
;;;778        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
000222  2304              MOVS     r3,#4
000224  439c              BICS     r4,r4,r3
;;;779        /* Set the Output N State */
;;;780        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000226  888b              LDRH     r3,[r1,#4]
000228  4323              ORRS     r3,r3,r4
;;;781        
;;;782        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;783        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
00022a  4c75              LDR      r4,|L1.1024|
00022c  4022              ANDS     r2,r2,r4
;;;784        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
;;;785        
;;;786        /* Set the Output Idle state */
;;;787        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00022e  8a0c              LDRH     r4,[r1,#0x10]
000230  4314              ORRS     r4,r4,r2
;;;788        /* Set the Output N Idle state */
;;;789        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000232  8a4a              LDRH     r2,[r1,#0x12]
000234  4322              ORRS     r2,r2,r4
                  |L1.566|
;;;790      }
;;;791      /* Write to TIMx CR2 */
;;;792      TIMx->CR2 = tmpcr2;
000236  8082              STRH     r2,[r0,#4]
;;;793      
;;;794      /* Write to TIMx CCMR1 */
;;;795      TIMx->CCMR1 = tmpccmrx;
000238  8305              STRH     r5,[r0,#0x18]
;;;796    
;;;797      /* Set the Capture Compare Register value */
;;;798      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
00023a  6889              LDR      r1,[r1,#8]
00023c  6341              STR      r1,[r0,#0x34]
;;;799     
;;;800      /* Write to TIMx CCER */
;;;801      TIMx->CCER = tmpccer;
00023e  8403              STRH     r3,[r0,#0x20]
;;;802    }
000240  bd70              POP      {r4-r6,pc}
;;;803    
                          ENDP

                  TIM_OC2Init PROC
;;;812      */
;;;813    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000242  b570              PUSH     {r4-r6,lr}
;;;814    {
;;;815      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;816       
;;;817      /* Check the parameters */
;;;818      assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;819      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;820      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;821      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;822       /* Disable the Channel 2: Reset the CC2E Bit */
;;;823      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
000244  8c02              LDRH     r2,[r0,#0x20]
000246  2310              MOVS     r3,#0x10
000248  439a              BICS     r2,r2,r3
00024a  8402              STRH     r2,[r0,#0x20]
;;;824      
;;;825      /* Get the TIMx CCER register value */  
;;;826      tmpccer = TIMx->CCER;
00024c  8c05              LDRH     r5,[r0,#0x20]
;;;827      /* Get the TIMx CR2 register value */
;;;828      tmpcr2 =  TIMx->CR2;
00024e  8882              LDRH     r2,[r0,#4]
;;;829      
;;;830      /* Get the TIMx CCMR1 register value */
;;;831      tmpccmrx = TIMx->CCMR1;
000250  8b03              LDRH     r3,[r0,#0x18]
;;;832        
;;;833      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;834      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
000252  4c6c              LDR      r4,|L1.1028|
000254  4023              ANDS     r3,r3,r4
;;;835      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
;;;836      
;;;837      /* Select the Output Compare Mode */
;;;838      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000256  780c              LDRB     r4,[r1,#0]
000258  0624              LSLS     r4,r4,#24
00025a  0c24              LSRS     r4,r4,#16
00025c  431c              ORRS     r4,r4,r3
;;;839      
;;;840      /* Reset the Output Polarity level */
;;;841      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
00025e  2320              MOVS     r3,#0x20
000260  439d              BICS     r5,r5,r3
;;;842      /* Set the Output Compare Polarity */
;;;843      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000262  898b              LDRH     r3,[r1,#0xc]
000264  051b              LSLS     r3,r3,#20
000266  0c1e              LSRS     r6,r3,#16
;;;844      
;;;845      /* Set the Output State */
;;;846      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000268  884b              LDRH     r3,[r1,#2]
00026a  432e              ORRS     r6,r6,r5              ;843
00026c  051b              LSLS     r3,r3,#20
00026e  0c1b              LSRS     r3,r3,#16
;;;847        
;;;848      if(TIMx == TIM1)
000270  4d5c              LDR      r5,|L1.996|
000272  4333              ORRS     r3,r3,r6              ;846
000274  42a8              CMP      r0,r5
000276  d115              BNE      |L1.676|
;;;849      {
;;;850        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;851        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;852        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;853        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;854        
;;;855        /* Reset the Output N Polarity level */
;;;856        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
000278  2580              MOVS     r5,#0x80
00027a  43ab              BICS     r3,r3,r5
;;;857        /* Set the Output N Polarity */
;;;858        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
00027c  89cd              LDRH     r5,[r1,#0xe]
00027e  052d              LSLS     r5,r5,#20
000280  0c2d              LSRS     r5,r5,#16
000282  431d              ORRS     r5,r5,r3
;;;859        
;;;860        /* Reset the Output N State */
;;;861        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
000284  2340              MOVS     r3,#0x40
000286  439d              BICS     r5,r5,r3
;;;862        /* Set the Output N State */
;;;863        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
000288  888b              LDRH     r3,[r1,#4]
00028a  051b              LSLS     r3,r3,#20
00028c  0c1b              LSRS     r3,r3,#16
00028e  432b              ORRS     r3,r3,r5
;;;864        
;;;865        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;866        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
000290  4d5d              LDR      r5,|L1.1032|
000292  402a              ANDS     r2,r2,r5
;;;867        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
;;;868        
;;;869        /* Set the Output Idle state */
;;;870        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
000294  8a0d              LDRH     r5,[r1,#0x10]
000296  04ad              LSLS     r5,r5,#18
000298  0c2d              LSRS     r5,r5,#16
00029a  4315              ORRS     r5,r5,r2
;;;871        /* Set the Output N Idle state */
;;;872        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
00029c  8a4a              LDRH     r2,[r1,#0x12]
00029e  0492              LSLS     r2,r2,#18
0002a0  0c12              LSRS     r2,r2,#16
0002a2  432a              ORRS     r2,r2,r5
                  |L1.676|
;;;873      }
;;;874      /* Write to TIMx CR2 */
;;;875      TIMx->CR2 = tmpcr2;
0002a4  8082              STRH     r2,[r0,#4]
;;;876      
;;;877      /* Write to TIMx CCMR1 */
;;;878      TIMx->CCMR1 = tmpccmrx;
0002a6  8304              STRH     r4,[r0,#0x18]
;;;879    
;;;880      /* Set the Capture Compare Register value */
;;;881      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
0002a8  6889              LDR      r1,[r1,#8]
0002aa  6381              STR      r1,[r0,#0x38]
;;;882      
;;;883      /* Write to TIMx CCER */
;;;884      TIMx->CCER = tmpccer;
0002ac  8403              STRH     r3,[r0,#0x20]
;;;885    }
0002ae  bd70              POP      {r4-r6,pc}
;;;886    
                          ENDP

                  TIM_OC3Init PROC
;;;895      */
;;;896    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
0002b0  b530              PUSH     {r4,r5,lr}
;;;897    {
;;;898      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;899       
;;;900      /* Check the parameters */
;;;901      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;902      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;903      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;904      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;905      /* Disable the Channel 2: Reset the CC2E Bit */
;;;906      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
0002b2  8c02              LDRH     r2,[r0,#0x20]
0002b4  4b55              LDR      r3,|L1.1036|
0002b6  401a              ANDS     r2,r2,r3
0002b8  8402              STRH     r2,[r0,#0x20]
;;;907      
;;;908      /* Get the TIMx CCER register value */
;;;909      tmpccer = TIMx->CCER;
0002ba  8c03              LDRH     r3,[r0,#0x20]
;;;910      /* Get the TIMx CR2 register value */
;;;911      tmpcr2 =  TIMx->CR2;
0002bc  8882              LDRH     r2,[r0,#4]
;;;912      
;;;913      /* Get the TIMx CCMR2 register value */
;;;914      tmpccmrx = TIMx->CCMR2;
0002be  8b84              LDRH     r4,[r0,#0x1c]
;;;915        
;;;916      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;917      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
0002c0  2570              MOVS     r5,#0x70
0002c2  43ac              BICS     r4,r4,r5
;;;918      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
0002c4  08a4              LSRS     r4,r4,#2
;;;919      /* Select the Output Compare Mode */
;;;920      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
0002c6  880d              LDRH     r5,[r1,#0]
0002c8  00a4              LSLS     r4,r4,#2              ;918
0002ca  4325              ORRS     r5,r5,r4
;;;921      
;;;922      /* Reset the Output Polarity level */
;;;923      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
0002cc  4c50              LDR      r4,|L1.1040|
0002ce  4023              ANDS     r3,r3,r4
;;;924      /* Set the Output Compare Polarity */
;;;925      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
0002d0  7b0c              LDRB     r4,[r1,#0xc]
0002d2  0624              LSLS     r4,r4,#24
0002d4  0c24              LSRS     r4,r4,#16
0002d6  431c              ORRS     r4,r4,r3
;;;926      
;;;927      /* Set the Output State */
;;;928      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
0002d8  788b              LDRB     r3,[r1,#2]
0002da  061b              LSLS     r3,r3,#24
0002dc  0c1b              LSRS     r3,r3,#16
0002de  4323              ORRS     r3,r3,r4
;;;929        
;;;930      if(TIMx == TIM1)
0002e0  4c40              LDR      r4,|L1.996|
0002e2  42a0              CMP      r0,r4
0002e4  d115              BNE      |L1.786|
;;;931      {
;;;932        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;933        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;934        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;935        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;936        
;;;937        /* Reset the Output N Polarity level */
;;;938        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
0002e6  4c4b              LDR      r4,|L1.1044|
0002e8  4023              ANDS     r3,r3,r4
;;;939        /* Set the Output N Polarity */
;;;940        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
0002ea  7b8c              LDRB     r4,[r1,#0xe]
0002ec  0624              LSLS     r4,r4,#24
0002ee  0c24              LSRS     r4,r4,#16
0002f0  431c              ORRS     r4,r4,r3
;;;941        /* Reset the Output N State */
;;;942        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
0002f2  4b49              LDR      r3,|L1.1048|
0002f4  401c              ANDS     r4,r4,r3
;;;943        
;;;944        /* Set the Output N State */
;;;945        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
0002f6  790b              LDRB     r3,[r1,#4]
0002f8  061b              LSLS     r3,r3,#24
0002fa  0c1b              LSRS     r3,r3,#16
0002fc  4323              ORRS     r3,r3,r4
;;;946        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;947        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
0002fe  4c47              LDR      r4,|L1.1052|
000300  4022              ANDS     r2,r2,r4
;;;948        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
;;;949        /* Set the Output Idle state */
;;;950        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000302  8a0c              LDRH     r4,[r1,#0x10]
000304  0524              LSLS     r4,r4,#20
000306  0c24              LSRS     r4,r4,#16
000308  4314              ORRS     r4,r4,r2
;;;951        /* Set the Output N Idle state */
;;;952        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
00030a  8a4a              LDRH     r2,[r1,#0x12]
00030c  0512              LSLS     r2,r2,#20
00030e  0c12              LSRS     r2,r2,#16
000310  4322              ORRS     r2,r2,r4
                  |L1.786|
;;;953      }
;;;954      /* Write to TIMx CR2 */
;;;955      TIMx->CR2 = tmpcr2;
000312  8082              STRH     r2,[r0,#4]
;;;956      
;;;957      /* Write to TIMx CCMR2 */
;;;958      TIMx->CCMR2 = tmpccmrx;
000314  8385              STRH     r5,[r0,#0x1c]
;;;959    
;;;960      /* Set the Capture Compare Register value */
;;;961      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000316  6889              LDR      r1,[r1,#8]
000318  63c1              STR      r1,[r0,#0x3c]
;;;962      
;;;963      /* Write to TIMx CCER */
;;;964      TIMx->CCER = tmpccer;
00031a  8403              STRH     r3,[r0,#0x20]
;;;965    }
00031c  bd30              POP      {r4,r5,pc}
;;;966    
                          ENDP

                  TIM_OC4Init PROC
;;;975      */
;;;976    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
00031e  b530              PUSH     {r4,r5,lr}
;;;977    {
;;;978      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;979       
;;;980      /* Check the parameters */
;;;981      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;982      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;983      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;984      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;985      /* Disable the Channel 2: Reset the CC4E Bit */
;;;986      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
000320  8c02              LDRH     r2,[r0,#0x20]
000322  4b3f              LDR      r3,|L1.1056|
000324  401a              ANDS     r2,r2,r3
000326  8402              STRH     r2,[r0,#0x20]
;;;987      
;;;988      /* Get the TIMx CCER register value */
;;;989      tmpccer = TIMx->CCER;
000328  8c05              LDRH     r5,[r0,#0x20]
;;;990      /* Get the TIMx CR2 register value */
;;;991      tmpcr2 =  TIMx->CR2;
00032a  8882              LDRH     r2,[r0,#4]
;;;992      
;;;993      /* Get the TIMx CCMR2 register value */
;;;994      tmpccmrx = TIMx->CCMR2;
00032c  8b83              LDRH     r3,[r0,#0x1c]
;;;995        
;;;996      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;997      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
00032e  4c35              LDR      r4,|L1.1028|
000330  4023              ANDS     r3,r3,r4
;;;998      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
;;;999      
;;;1000     /* Select the Output Compare Mode */
;;;1001     tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000332  780c              LDRB     r4,[r1,#0]
000334  0624              LSLS     r4,r4,#24
000336  0c24              LSRS     r4,r4,#16
000338  431c              ORRS     r4,r4,r3
;;;1002     
;;;1003     /* Reset the Output Polarity level */
;;;1004     tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
00033a  4b3a              LDR      r3,|L1.1060|
00033c  401d              ANDS     r5,r5,r3
;;;1005     /* Set the Output Compare Polarity */
;;;1006     tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
00033e  7b0b              LDRB     r3,[r1,#0xc]
000340  071b              LSLS     r3,r3,#28
000342  0c1b              LSRS     r3,r3,#16
000344  432b              ORRS     r3,r3,r5
;;;1007     
;;;1008     /* Set the Output State */
;;;1009     tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
000346  788d              LDRB     r5,[r1,#2]
000348  072d              LSLS     r5,r5,#28
00034a  0c2d              LSRS     r5,r5,#16
00034c  431d              ORRS     r5,r5,r3
;;;1010       
;;;1011     if(TIMx == TIM1)
00034e  4b25              LDR      r3,|L1.996|
000350  4298              CMP      r0,r3
000352  d105              BNE      |L1.864|
;;;1012     {
;;;1013       assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;1014       /* Reset the Ouput Compare IDLE State */
;;;1015       tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
000354  4b34              LDR      r3,|L1.1064|
000356  4013              ANDS     r3,r3,r2
;;;1016       /* Set the Output Idle state */
;;;1017       tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000358  8a0a              LDRH     r2,[r1,#0x10]
00035a  0592              LSLS     r2,r2,#22
00035c  0c12              LSRS     r2,r2,#16
00035e  431a              ORRS     r2,r2,r3
                  |L1.864|
;;;1018     }
;;;1019     /* Write to TIMx CR2 */
;;;1020     TIMx->CR2 = tmpcr2;
000360  8082              STRH     r2,[r0,#4]
;;;1021     
;;;1022     /* Write to TIMx CCMR2 */  
;;;1023     TIMx->CCMR2 = tmpccmrx;
000362  8384              STRH     r4,[r0,#0x1c]
;;;1024   
;;;1025     /* Set the Capture Compare Register value */
;;;1026     TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000364  6889              LDR      r1,[r1,#8]
000366  6401              STR      r1,[r0,#0x40]
;;;1027     
;;;1028     /* Write to TIMx CCER */
;;;1029     TIMx->CCER = tmpccer;
000368  8405              STRH     r5,[r0,#0x20]
;;;1030   }
00036a  bd30              POP      {r4,r5,pc}
;;;1031   
                          ENDP

                  TIM_OCStructInit PROC
;;;1037     */
;;;1038   void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
00036c  2100              MOVS     r1,#0
;;;1039   {
;;;1040     /* Set the default configuration */
;;;1041     TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
00036e  8001              STRH     r1,[r0,#0]
;;;1042     TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000370  8041              STRH     r1,[r0,#2]
;;;1043     TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000372  8081              STRH     r1,[r0,#4]
;;;1044     TIM_OCInitStruct->TIM_Pulse = 0x0000000;
;;;1045     TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
000374  6081              STR      r1,[r0,#8]
000376  8181              STRH     r1,[r0,#0xc]
;;;1046     TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
000378  81c1              STRH     r1,[r0,#0xe]
;;;1047     TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00037a  8201              STRH     r1,[r0,#0x10]
;;;1048     TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
00037c  8241              STRH     r1,[r0,#0x12]
;;;1049   }
00037e  4770              BX       lr
;;;1050   
                          ENDP

                  TIM_SelectOCxM PROC
;;;1073     */
;;;1074   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000380  b530              PUSH     {r4,r5,lr}
;;;1075   {
;;;1076     uint32_t tmp = 0;
;;;1077     uint16_t tmp1 = 0;
;;;1078   
;;;1079     /* Check the parameters */
;;;1080     assert_param(IS_TIM_LIST4_PERIPH(TIMx));  
;;;1081     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;1082     
;;;1083     tmp = (uint32_t) TIMx;
;;;1084     tmp += CCMR_OFFSET;
000382  4603              MOV      r3,r0
000384  3318              ADDS     r3,r3,#0x18
;;;1085   
;;;1086     tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
000386  2401              MOVS     r4,#1
;;;1087   
;;;1088     /* Disable the Channel: Reset the CCxE Bit */
;;;1089     TIMx->CCER &= (uint16_t) ~tmp1;
000388  8c05              LDRH     r5,[r0,#0x20]
00038a  408c              LSLS     r4,r4,r1              ;1086
00038c  43a5              BICS     r5,r5,r4
00038e  8405              STRH     r5,[r0,#0x20]
;;;1090   
;;;1091     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000390  2900              CMP      r1,#0
000392  d010              BEQ      |L1.950|
000394  2908              CMP      r1,#8
000396  d00e              BEQ      |L1.950|
;;;1092     {
;;;1093       tmp += (TIM_Channel>>1);
;;;1094   
;;;1095       /* Reset the OCxM bits in the CCMRx register */
;;;1096       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
;;;1097      
;;;1098       /* Configure the OCxM bits in the CCMRx register */
;;;1099       *(__IO uint32_t *) tmp |= TIM_OCMode;
;;;1100     }
;;;1101     else
;;;1102     {
;;;1103       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000398  1f09              SUBS     r1,r1,#4
00039a  0408              LSLS     r0,r1,#16
00039c  0c40              LSRS     r0,r0,#17
00039e  18c0              ADDS     r0,r0,r3
;;;1104   
;;;1105       /* Reset the OCxM bits in the CCMRx register */
;;;1106       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
0003a0  6801              LDR      r1,[r0,#0]
0003a2  2307              MOVS     r3,#7
0003a4  031b              LSLS     r3,r3,#12
0003a6  4399              BICS     r1,r1,r3
0003a8  6001              STR      r1,[r0,#0]
;;;1107       
;;;1108       /* Configure the OCxM bits in the CCMRx register */
;;;1109       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
0003aa  6801              LDR      r1,[r0,#0]
0003ac  0612              LSLS     r2,r2,#24
0003ae  0c12              LSRS     r2,r2,#16
                  |L1.944|
0003b0  4311              ORRS     r1,r1,r2              ;1099
0003b2  6001              STR      r1,[r0,#0]            ;1099
;;;1110     }
;;;1111   }
0003b4  bd30              POP      {r4,r5,pc}
                  |L1.950|
0003b6  0848              LSRS     r0,r1,#1              ;1093
0003b8  18c0              ADDS     r0,r0,r3              ;1093
0003ba  6801              LDR      r1,[r0,#0]            ;1096
0003bc  2370              MOVS     r3,#0x70              ;1096
0003be  4399              BICS     r1,r1,r3              ;1096
0003c0  6001              STR      r1,[r0,#0]            ;1096
0003c2  6801              LDR      r1,[r0,#0]            ;1099
0003c4  e7f4              B        |L1.944|
;;;1112   
                          ENDP

                  TIM_SetCompare1 PROC
;;;1118     */
;;;1119   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
0003c6  6341              STR      r1,[r0,#0x34]
;;;1120   {
;;;1121     /* Check the parameters */
;;;1122     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1123     
;;;1124     /* Set the Capture Compare1 Register value */
;;;1125     TIMx->CCR1 = Compare1;
;;;1126   }
0003c8  4770              BX       lr
;;;1127   
                          ENDP

                  TIM_SetCompare2 PROC
;;;1133     */
;;;1134   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
0003ca  6381              STR      r1,[r0,#0x38]
;;;1135   {
;;;1136     /* Check the parameters */
;;;1137     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1138     
;;;1139     /* Set the Capture Compare2 Register value */
;;;1140     TIMx->CCR2 = Compare2;
;;;1141   }
0003cc  4770              BX       lr
;;;1142   
                          ENDP

                  TIM_SetCompare3 PROC
;;;1148     */
;;;1149   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
0003ce  63c1              STR      r1,[r0,#0x3c]
;;;1150   {
;;;1151     /* Check the parameters */
;;;1152     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1153     
;;;1154     /* Set the Capture Compare3 Register value */
;;;1155     TIMx->CCR3 = Compare3;
;;;1156   }
0003d0  4770              BX       lr
;;;1157   
                          ENDP

                  TIM_SetCompare4 PROC
;;;1163     */
;;;1164   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
0003d2  6401              STR      r1,[r0,#0x40]
;;;1165   {
;;;1166     /* Check the parameters */
;;;1167     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1168     
;;;1169     /* Set the Capture Compare4 Register value */
;;;1170     TIMx->CCR4 = Compare4;
;;;1171   }
0003d4  4770              BX       lr
;;;1172   
                          ENDP

                  TIM_ForcedOC1Config PROC
;;;1181     */
;;;1182   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
0003d6  8b02              LDRH     r2,[r0,#0x18]
;;;1183   {
;;;1184     uint16_t tmpccmr1 = 0;
;;;1185     /* Check the parameters */
;;;1186     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1187     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1188     tmpccmr1 = TIMx->CCMR1;
;;;1189     /* Reset the OC1M Bits */
;;;1190     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
0003d8  2370              MOVS     r3,#0x70
0003da  439a              BICS     r2,r2,r3
;;;1191     /* Configure The Forced output Mode */
;;;1192     tmpccmr1 |= TIM_ForcedAction;
0003dc  430a              ORRS     r2,r2,r1
;;;1193     /* Write to TIMx CCMR1 register */
;;;1194     TIMx->CCMR1 = tmpccmr1;
0003de  8302              STRH     r2,[r0,#0x18]
                  |L1.992|
;;;1195   }
0003e0  4770              BX       lr
0003e2  0000              DCW      0x0000
                  |L1.996|
                          DCD      0x40012c00
                  |L1.1000|
                          DCD      0x40000400
                  |L1.1004|
                          DCD      0x40001000
                  |L1.1008|
                          DCD      0x40002000
                  |L1.1012|
                          DCD      0x40014000
                  |L1.1016|
                          DCD      0x40014400
                  |L1.1020|
                          DCD      0x40014800
                  |L1.1024|
                          DCD      0x0000fcff
                  |L1.1028|
                          DCD      0x00008cff
                  |L1.1032|
                          DCD      0x0000f3ff
                  |L1.1036|
                          DCD      0x0000feff
                  |L1.1040|
                          DCD      0x0000fdff
                  |L1.1044|
                          DCD      0x0000f7ff
                  |L1.1048|
                          DCD      0x0000fbff
                  |L1.1052|
                          DCD      0x0000cfff
                  |L1.1056|
                          DCD      0x0000efff
                  |L1.1060|
                          DCD      0x0000dfff
                  |L1.1064|
                          DCD      0x0000bfff
                          ENDP

                  TIM_ForcedOC2Config PROC
;;;1206     */
;;;1207   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
00042c  8b02              LDRH     r2,[r0,#0x18]
;;;1208   {
;;;1209     uint16_t tmpccmr1 = 0;
;;;1210     
;;;1211     /* Check the parameters */
;;;1212     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1213     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1214     
;;;1215     tmpccmr1 = TIMx->CCMR1;
;;;1216     /* Reset the OC2M Bits */
;;;1217     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
00042e  4bf6              LDR      r3,|L1.2056|
;;;1218     /* Configure The Forced output Mode */
;;;1219     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000430  0209              LSLS     r1,r1,#8
000432  401a              ANDS     r2,r2,r3              ;1217
000434  4311              ORRS     r1,r1,r2
;;;1220     /* Write to TIMx CCMR1 register */
;;;1221     TIMx->CCMR1 = tmpccmr1;
000436  8301              STRH     r1,[r0,#0x18]
;;;1222   }
000438  e7d2              B        |L1.992|
;;;1223   
                          ENDP

                  TIM_ForcedOC3Config PROC
;;;1232     */
;;;1233   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
00043a  8b82              LDRH     r2,[r0,#0x1c]
;;;1234   {
;;;1235     uint16_t tmpccmr2 = 0;
;;;1236     
;;;1237     /* Check the parameters */
;;;1238     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1239     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1240     
;;;1241     tmpccmr2 = TIMx->CCMR2;
;;;1242     /* Reset the OC1M Bits */
;;;1243     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
00043c  2370              MOVS     r3,#0x70
00043e  439a              BICS     r2,r2,r3
;;;1244     /* Configure The Forced output Mode */
;;;1245     tmpccmr2 |= TIM_ForcedAction;
000440  430a              ORRS     r2,r2,r1
;;;1246     /* Write to TIMx CCMR2 register */
;;;1247     TIMx->CCMR2 = tmpccmr2;
000442  8382              STRH     r2,[r0,#0x1c]
;;;1248   }
000444  e7cc              B        |L1.992|
;;;1249   
                          ENDP

                  TIM_ForcedOC4Config PROC
;;;1258     */
;;;1259   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000446  8b82              LDRH     r2,[r0,#0x1c]
;;;1260   {
;;;1261     uint16_t tmpccmr2 = 0;
;;;1262     /* Check the parameters */
;;;1263     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1264     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1265     
;;;1266     tmpccmr2 = TIMx->CCMR2;
;;;1267     /* Reset the OC2M Bits */
;;;1268     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
000448  4bef              LDR      r3,|L1.2056|
;;;1269     /* Configure The Forced output Mode */
;;;1270     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
00044a  0209              LSLS     r1,r1,#8
00044c  401a              ANDS     r2,r2,r3              ;1268
00044e  4311              ORRS     r1,r1,r2
;;;1271     /* Write to TIMx CCMR2 register */
;;;1272     TIMx->CCMR2 = tmpccmr2;
000450  8381              STRH     r1,[r0,#0x1c]
;;;1273   }
000452  e7c5              B        |L1.992|
;;;1274   
                          ENDP

                  TIM_CCPreloadControl PROC
;;;1282     */
;;;1283   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000454  2900              CMP      r1,#0
;;;1284   { 
;;;1285     /* Check the parameters */
;;;1286     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1287     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1288     if (NewState != DISABLE)
;;;1289     {
;;;1290       /* Set the CCPC Bit */
;;;1291       TIMx->CR2 |= TIM_CR2_CCPC;
;;;1292     }
;;;1293     else
;;;1294     {
;;;1295       /* Reset the CCPC Bit */
;;;1296       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
000456  8881              LDRH     r1,[r0,#4]
000458  d002              BEQ      |L1.1120|
00045a  2201              MOVS     r2,#1                 ;1291
00045c  4311              ORRS     r1,r1,r2              ;1291
00045e  e001              B        |L1.1124|
                  |L1.1120|
000460  0849              LSRS     r1,r1,#1
000462  0049              LSLS     r1,r1,#1
                  |L1.1124|
000464  8081              STRH     r1,[r0,#4]            ;1291
;;;1297     }
;;;1298   }
000466  e7bb              B        |L1.992|
;;;1299   
                          ENDP

                  TIM_OC1PreloadConfig PROC
;;;1309     */
;;;1310   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000468  8b02              LDRH     r2,[r0,#0x18]
;;;1311   {
;;;1312     uint16_t tmpccmr1 = 0;
;;;1313     /* Check the parameters */
;;;1314     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1315     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1316     
;;;1317     tmpccmr1 = TIMx->CCMR1;
;;;1318     /* Reset the OC1PE Bit */
;;;1319     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
00046a  2308              MOVS     r3,#8
00046c  439a              BICS     r2,r2,r3
;;;1320     /* Enable or Disable the Output Compare Preload feature */
;;;1321     tmpccmr1 |= TIM_OCPreload;
00046e  430a              ORRS     r2,r2,r1
;;;1322     /* Write to TIMx CCMR1 register */
;;;1323     TIMx->CCMR1 = tmpccmr1;
000470  8302              STRH     r2,[r0,#0x18]
;;;1324   }
000472  e7b5              B        |L1.992|
;;;1325   
                          ENDP

                  TIM_OC2PreloadConfig PROC
;;;1334     */
;;;1335   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000474  8b02              LDRH     r2,[r0,#0x18]
;;;1336   {
;;;1337     uint16_t tmpccmr1 = 0;
;;;1338     /* Check the parameters */
;;;1339     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1340     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1341     
;;;1342     tmpccmr1 = TIMx->CCMR1;
;;;1343     /* Reset the OC2PE Bit */
;;;1344     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
000476  4be5              LDR      r3,|L1.2060|
;;;1345     /* Enable or Disable the Output Compare Preload feature */
;;;1346     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000478  0209              LSLS     r1,r1,#8
00047a  401a              ANDS     r2,r2,r3              ;1344
00047c  4311              ORRS     r1,r1,r2
;;;1347     /* Write to TIMx CCMR1 register */
;;;1348     TIMx->CCMR1 = tmpccmr1;
00047e  8301              STRH     r1,[r0,#0x18]
;;;1349   }
000480  e7ae              B        |L1.992|
;;;1350   
                          ENDP

                  TIM_OC3PreloadConfig PROC
;;;1359     */
;;;1360   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000482  8b82              LDRH     r2,[r0,#0x1c]
;;;1361   {
;;;1362     uint16_t tmpccmr2 = 0;
;;;1363     
;;;1364     /* Check the parameters */
;;;1365     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1366     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1367     
;;;1368     tmpccmr2 = TIMx->CCMR2;
;;;1369     /* Reset the OC3PE Bit */
;;;1370     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
000484  2308              MOVS     r3,#8
000486  439a              BICS     r2,r2,r3
;;;1371     /* Enable or Disable the Output Compare Preload feature */
;;;1372     tmpccmr2 |= TIM_OCPreload;
000488  430a              ORRS     r2,r2,r1
;;;1373     /* Write to TIMx CCMR2 register */
;;;1374     TIMx->CCMR2 = tmpccmr2;
00048a  8382              STRH     r2,[r0,#0x1c]
;;;1375   }
00048c  e7a8              B        |L1.992|
;;;1376   
                          ENDP

                  TIM_OC4PreloadConfig PROC
;;;1385     */
;;;1386   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
00048e  8b82              LDRH     r2,[r0,#0x1c]
;;;1387   {
;;;1388     uint16_t tmpccmr2 = 0;
;;;1389     
;;;1390     /* Check the parameters */
;;;1391     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1392     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1393     
;;;1394     tmpccmr2 = TIMx->CCMR2;
;;;1395     /* Reset the OC4PE Bit */
;;;1396     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
000490  4bde              LDR      r3,|L1.2060|
;;;1397     /* Enable or Disable the Output Compare Preload feature */
;;;1398     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
000492  0209              LSLS     r1,r1,#8
000494  401a              ANDS     r2,r2,r3              ;1396
000496  4311              ORRS     r1,r1,r2
;;;1399     /* Write to TIMx CCMR2 register */
;;;1400     TIMx->CCMR2 = tmpccmr2;
000498  8381              STRH     r1,[r0,#0x1c]
;;;1401   }
00049a  e7a1              B        |L1.992|
;;;1402   
                          ENDP

                  TIM_OC1FastConfig PROC
;;;1411     */
;;;1412   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
00049c  8b02              LDRH     r2,[r0,#0x18]
;;;1413   {
;;;1414     uint16_t tmpccmr1 = 0;
;;;1415     
;;;1416     /* Check the parameters */
;;;1417     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1418     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1419     
;;;1420     /* Get the TIMx CCMR1 register value */
;;;1421     tmpccmr1 = TIMx->CCMR1;
;;;1422     /* Reset the OC1FE Bit */
;;;1423     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
00049e  2304              MOVS     r3,#4
0004a0  439a              BICS     r2,r2,r3
;;;1424     /* Enable or Disable the Output Compare Fast Bit */
;;;1425     tmpccmr1 |= TIM_OCFast;
0004a2  430a              ORRS     r2,r2,r1
;;;1426     /* Write to TIMx CCMR1 */
;;;1427     TIMx->CCMR1 = tmpccmr1;
0004a4  8302              STRH     r2,[r0,#0x18]
;;;1428   }
0004a6  e79b              B        |L1.992|
;;;1429   
                          ENDP

                  TIM_OC2FastConfig PROC
;;;1438     */
;;;1439   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0004a8  8b02              LDRH     r2,[r0,#0x18]
;;;1440   {
;;;1441     uint16_t tmpccmr1 = 0;
;;;1442     
;;;1443     /* Check the parameters */
;;;1444     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1445     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1446     
;;;1447     /* Get the TIMx CCMR1 register value */
;;;1448     tmpccmr1 = TIMx->CCMR1;
;;;1449     /* Reset the OC2FE Bit */
;;;1450     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
0004aa  4bd9              LDR      r3,|L1.2064|
;;;1451     /* Enable or Disable the Output Compare Fast Bit */
;;;1452     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
0004ac  0209              LSLS     r1,r1,#8
0004ae  401a              ANDS     r2,r2,r3              ;1450
0004b0  4311              ORRS     r1,r1,r2
;;;1453     /* Write to TIMx CCMR1 */
;;;1454     TIMx->CCMR1 = tmpccmr1;
0004b2  8301              STRH     r1,[r0,#0x18]
;;;1455   }
0004b4  e794              B        |L1.992|
;;;1456   
                          ENDP

                  TIM_OC3FastConfig PROC
;;;1465     */
;;;1466   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0004b6  8b82              LDRH     r2,[r0,#0x1c]
;;;1467   {
;;;1468     uint16_t tmpccmr2 = 0;
;;;1469     
;;;1470     /* Check the parameters */
;;;1471     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1472     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1473     
;;;1474     /* Get the TIMx CCMR2 register value */
;;;1475     tmpccmr2 = TIMx->CCMR2;
;;;1476     /* Reset the OC3FE Bit */
;;;1477     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
0004b8  2304              MOVS     r3,#4
0004ba  439a              BICS     r2,r2,r3
;;;1478     /* Enable or Disable the Output Compare Fast Bit */
;;;1479     tmpccmr2 |= TIM_OCFast;
0004bc  430a              ORRS     r2,r2,r1
;;;1480     /* Write to TIMx CCMR2 */
;;;1481     TIMx->CCMR2 = tmpccmr2;
0004be  8382              STRH     r2,[r0,#0x1c]
;;;1482   }
0004c0  e78e              B        |L1.992|
;;;1483   
                          ENDP

                  TIM_OC4FastConfig PROC
;;;1492     */
;;;1493   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0004c2  8b82              LDRH     r2,[r0,#0x1c]
;;;1494   {
;;;1495     uint16_t tmpccmr2 = 0;
;;;1496     
;;;1497     /* Check the parameters */
;;;1498     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1499     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1500     
;;;1501     /* Get the TIMx CCMR2 register value */
;;;1502     tmpccmr2 = TIMx->CCMR2;
;;;1503     /* Reset the OC4FE Bit */
;;;1504     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
0004c4  4bd2              LDR      r3,|L1.2064|
;;;1505     /* Enable or Disable the Output Compare Fast Bit */
;;;1506     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
0004c6  0209              LSLS     r1,r1,#8
0004c8  401a              ANDS     r2,r2,r3              ;1504
0004ca  4311              ORRS     r1,r1,r2
;;;1507     /* Write to TIMx CCMR2 */
;;;1508     TIMx->CCMR2 = tmpccmr2;
0004cc  8381              STRH     r1,[r0,#0x1c]
;;;1509   }
0004ce  e787              B        |L1.992|
;;;1510   
                          ENDP

                  TIM_ClearOC1Ref PROC
;;;1519     */
;;;1520   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
0004d0  8b02              LDRH     r2,[r0,#0x18]
;;;1521   {
;;;1522     uint16_t tmpccmr1 = 0;
;;;1523     
;;;1524     /* Check the parameters */
;;;1525     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1526     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1527     
;;;1528     tmpccmr1 = TIMx->CCMR1;
;;;1529     /* Reset the OC1CE Bit */
;;;1530     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
0004d2  2380              MOVS     r3,#0x80
0004d4  439a              BICS     r2,r2,r3
;;;1531     /* Enable or Disable the Output Compare Clear Bit */
;;;1532     tmpccmr1 |= TIM_OCClear;
0004d6  430a              ORRS     r2,r2,r1
;;;1533     /* Write to TIMx CCMR1 register */
;;;1534     TIMx->CCMR1 = tmpccmr1;
0004d8  8302              STRH     r2,[r0,#0x18]
;;;1535   }
0004da  e781              B        |L1.992|
;;;1536   
                          ENDP

                  TIM_ClearOC2Ref PROC
;;;1546     */
;;;1547   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
0004dc  8b02              LDRH     r2,[r0,#0x18]
;;;1548   {
;;;1549     uint16_t tmpccmr1 = 0;
;;;1550     
;;;1551     /* Check the parameters */
;;;1552     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1553     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1554     
;;;1555     tmpccmr1 = TIMx->CCMR1;
;;;1556     /* Reset the OC2CE Bit */
;;;1557     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
0004de  0452              LSLS     r2,r2,#17
0004e0  0c52              LSRS     r2,r2,#17
;;;1558     /* Enable or Disable the Output Compare Clear Bit */
;;;1559     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
0004e2  0209              LSLS     r1,r1,#8
0004e4  4311              ORRS     r1,r1,r2
;;;1560     /* Write to TIMx CCMR1 register */
;;;1561     TIMx->CCMR1 = tmpccmr1;
0004e6  8301              STRH     r1,[r0,#0x18]
;;;1562   }
0004e8  e77a              B        |L1.992|
;;;1563   
                          ENDP

                  TIM_ClearOC3Ref PROC
;;;1572     */
;;;1573   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
0004ea  8b82              LDRH     r2,[r0,#0x1c]
;;;1574   {
;;;1575     uint16_t tmpccmr2 = 0;
;;;1576     
;;;1577     /* Check the parameters */
;;;1578     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1579     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1580     
;;;1581     tmpccmr2 = TIMx->CCMR2;
;;;1582     /* Reset the OC3CE Bit */
;;;1583     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
0004ec  2380              MOVS     r3,#0x80
0004ee  439a              BICS     r2,r2,r3
;;;1584     /* Enable or Disable the Output Compare Clear Bit */
;;;1585     tmpccmr2 |= TIM_OCClear;
0004f0  430a              ORRS     r2,r2,r1
;;;1586     /* Write to TIMx CCMR2 register */
;;;1587     TIMx->CCMR2 = tmpccmr2;
0004f2  8382              STRH     r2,[r0,#0x1c]
;;;1588   }
0004f4  e774              B        |L1.992|
;;;1589   
                          ENDP

                  TIM_ClearOC4Ref PROC
;;;1598     */
;;;1599   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
0004f6  8b82              LDRH     r2,[r0,#0x1c]
;;;1600   {
;;;1601     uint16_t tmpccmr2 = 0;
;;;1602     
;;;1603     /* Check the parameters */
;;;1604     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1605     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1606     
;;;1607     tmpccmr2 = TIMx->CCMR2;
;;;1608     /* Reset the OC4CE Bit */
;;;1609     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
0004f8  0452              LSLS     r2,r2,#17
0004fa  0c52              LSRS     r2,r2,#17
;;;1610     /* Enable or Disable the Output Compare Clear Bit */
;;;1611     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
0004fc  0209              LSLS     r1,r1,#8
0004fe  4311              ORRS     r1,r1,r2
;;;1612     /* Write to TIMx CCMR2 register */
;;;1613     TIMx->CCMR2 = tmpccmr2;
000500  8381              STRH     r1,[r0,#0x1c]
;;;1614   }
000502  e76d              B        |L1.992|
;;;1615   
                          ENDP

                  TIM_OC1PolarityConfig PROC
;;;1624     */
;;;1625   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000504  8c02              LDRH     r2,[r0,#0x20]
;;;1626   {
;;;1627     uint16_t tmpccer = 0;
;;;1628     
;;;1629     /* Check the parameters */
;;;1630     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1631     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1632     
;;;1633     tmpccer = TIMx->CCER;
;;;1634     /* Set or Reset the CC1P Bit */
;;;1635     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
000506  2302              MOVS     r3,#2
000508  439a              BICS     r2,r2,r3
;;;1636     tmpccer |= TIM_OCPolarity;
00050a  430a              ORRS     r2,r2,r1
;;;1637     /* Write to TIMx CCER register */
;;;1638     TIMx->CCER = tmpccer;
00050c  8402              STRH     r2,[r0,#0x20]
;;;1639   }
00050e  e767              B        |L1.992|
;;;1640   
                          ENDP

                  TIM_OC1NPolarityConfig PROC
;;;1649     */
;;;1650   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000510  8c02              LDRH     r2,[r0,#0x20]
;;;1651   {
;;;1652     uint16_t tmpccer = 0;
;;;1653     /* Check the parameters */
;;;1654     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1655     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1656      
;;;1657     tmpccer = TIMx->CCER;
;;;1658     /* Set or Reset the CC1NP Bit */
;;;1659     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
000512  2308              MOVS     r3,#8
000514  439a              BICS     r2,r2,r3
;;;1660     tmpccer |= TIM_OCNPolarity;
000516  430a              ORRS     r2,r2,r1
;;;1661     /* Write to TIMx CCER register */
;;;1662     TIMx->CCER = tmpccer;
000518  8402              STRH     r2,[r0,#0x20]
;;;1663   }
00051a  e761              B        |L1.992|
;;;1664   
                          ENDP

                  TIM_OC2PolarityConfig PROC
;;;1673     */
;;;1674   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
00051c  8c02              LDRH     r2,[r0,#0x20]
;;;1675   {
;;;1676     uint16_t tmpccer = 0;
;;;1677     
;;;1678     /* Check the parameters */
;;;1679     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1680     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1681     
;;;1682     tmpccer = TIMx->CCER;
;;;1683     /* Set or Reset the CC2P Bit */
;;;1684     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
00051e  2320              MOVS     r3,#0x20
000520  439a              BICS     r2,r2,r3
;;;1685     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
000522  0109              LSLS     r1,r1,#4
000524  4311              ORRS     r1,r1,r2
;;;1686     /* Write to TIMx CCER register */
;;;1687     TIMx->CCER = tmpccer;
000526  8401              STRH     r1,[r0,#0x20]
;;;1688   }
000528  e75a              B        |L1.992|
;;;1689   
                          ENDP

                  TIM_OC2NPolarityConfig PROC
;;;1698     */
;;;1699   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
00052a  8c02              LDRH     r2,[r0,#0x20]
;;;1700   {
;;;1701     uint16_t tmpccer = 0;
;;;1702     /* Check the parameters */
;;;1703     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1704     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1705     
;;;1706     tmpccer = TIMx->CCER;
;;;1707     /* Set or Reset the CC2NP Bit */
;;;1708     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
00052c  2380              MOVS     r3,#0x80
00052e  439a              BICS     r2,r2,r3
;;;1709     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000530  0109              LSLS     r1,r1,#4
000532  4311              ORRS     r1,r1,r2
;;;1710     /* Write to TIMx CCER register */
;;;1711     TIMx->CCER = tmpccer;
000534  8401              STRH     r1,[r0,#0x20]
;;;1712   }
000536  e753              B        |L1.992|
;;;1713   
                          ENDP

                  TIM_OC3PolarityConfig PROC
;;;1722     */
;;;1723   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000538  8c02              LDRH     r2,[r0,#0x20]
;;;1724   {
;;;1725     uint16_t tmpccer = 0;
;;;1726     
;;;1727     /* Check the parameters */
;;;1728     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1729     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1730     
;;;1731     tmpccer = TIMx->CCER;
;;;1732     /* Set or Reset the CC3P Bit */
;;;1733     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
00053a  4bb6              LDR      r3,|L1.2068|
;;;1734     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
00053c  0209              LSLS     r1,r1,#8
00053e  401a              ANDS     r2,r2,r3              ;1733
000540  4311              ORRS     r1,r1,r2
;;;1735     /* Write to TIMx CCER register */
;;;1736     TIMx->CCER = tmpccer;
000542  8401              STRH     r1,[r0,#0x20]
;;;1737   }
000544  e74c              B        |L1.992|
;;;1738   
                          ENDP

                  TIM_OC3NPolarityConfig PROC
;;;1747     */
;;;1748   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000546  8c02              LDRH     r2,[r0,#0x20]
;;;1749   {
;;;1750     uint16_t tmpccer = 0;
;;;1751    
;;;1752     /* Check the parameters */
;;;1753     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1754     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1755       
;;;1756     tmpccer = TIMx->CCER;
;;;1757     /* Set or Reset the CC3NP Bit */
;;;1758     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
000548  4bb0              LDR      r3,|L1.2060|
;;;1759     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
00054a  0209              LSLS     r1,r1,#8
00054c  401a              ANDS     r2,r2,r3              ;1758
00054e  4311              ORRS     r1,r1,r2
;;;1760     /* Write to TIMx CCER register */
;;;1761     TIMx->CCER = tmpccer;
000550  8401              STRH     r1,[r0,#0x20]
;;;1762   }
000552  e745              B        |L1.992|
;;;1763   
                          ENDP

                  TIM_OC4PolarityConfig PROC
;;;1773     */
;;;1774   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000554  8c02              LDRH     r2,[r0,#0x20]
;;;1775   {
;;;1776     uint16_t tmpccer = 0;
;;;1777     
;;;1778     /* Check the parameters */
;;;1779     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1780     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1781     
;;;1782     tmpccer = TIMx->CCER;
;;;1783     /* Set or Reset the CC4P Bit */
;;;1784     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
000556  4bb0              LDR      r3,|L1.2072|
;;;1785     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
000558  0309              LSLS     r1,r1,#12
00055a  401a              ANDS     r2,r2,r3              ;1784
00055c  4311              ORRS     r1,r1,r2
;;;1786     /* Write to TIMx CCER register */
;;;1787     TIMx->CCER = tmpccer;
00055e  8401              STRH     r1,[r0,#0x20]
;;;1788   }
000560  e73e              B        |L1.992|
;;;1789   
                          ENDP

                  TIM_SelectOCREFClear PROC
;;;1798     */
;;;1799   void TIM_SelectOCREFClear(TIM_TypeDef* TIMx, uint16_t TIM_OCReferenceClear)
000562  8902              LDRH     r2,[r0,#8]
;;;1800   {
;;;1801     /* Check the parameters */
;;;1802     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1803     assert_param(TIM_OCREFERENCECECLEAR_SOURCE(TIM_OCReferenceClear));
;;;1804   
;;;1805     /* Set the TIM_OCReferenceClear source */
;;;1806     TIMx->SMCR &=  (uint16_t)~((uint16_t)TIM_SMCR_OCCS);
000564  2308              MOVS     r3,#8
000566  439a              BICS     r2,r2,r3
000568  8102              STRH     r2,[r0,#8]
;;;1807     TIMx->SMCR |=  TIM_OCReferenceClear;
00056a  8902              LDRH     r2,[r0,#8]
00056c  430a              ORRS     r2,r2,r1
00056e  8102              STRH     r2,[r0,#8]
;;;1808   }
000570  e736              B        |L1.992|
;;;1809   
                          ENDP

                  TIM_CCxCmd PROC
;;;1822     */
;;;1823   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000572  b510              PUSH     {r4,lr}
;;;1824   {
;;;1825     uint16_t tmp = 0;
;;;1826   
;;;1827     /* Check the parameters */
;;;1828     assert_param(IS_TIM_LIST4_PERIPH(TIMx)); 
;;;1829     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1830   
;;;1831     tmp = CCER_CCE_SET << TIM_Channel;
000574  2301              MOVS     r3,#1
;;;1832   
;;;1833     /* Reset the CCxE Bit */
;;;1834     TIMx->CCER &= (uint16_t)~ tmp;
000576  8c04              LDRH     r4,[r0,#0x20]
000578  408b              LSLS     r3,r3,r1              ;1831
00057a  439c              BICS     r4,r4,r3
00057c  8404              STRH     r4,[r0,#0x20]
;;;1835   
;;;1836     /* Set or reset the CCxE Bit */ 
;;;1837     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
00057e  8c03              LDRH     r3,[r0,#0x20]
000580  408a              LSLS     r2,r2,r1
000582  4313              ORRS     r3,r3,r2
000584  8403              STRH     r3,[r0,#0x20]
;;;1838   }
000586  bd10              POP      {r4,pc}
;;;1839   
                          ENDP

                  TIM_CCxNCmd PROC
;;;1851     */
;;;1852   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000588  b510              PUSH     {r4,lr}
;;;1853   {
;;;1854     uint16_t tmp = 0;
;;;1855   
;;;1856     /* Check the parameters */
;;;1857     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1858     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1859     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1860   
;;;1861     tmp = CCER_CCNE_SET << TIM_Channel;
00058a  2304              MOVS     r3,#4
;;;1862   
;;;1863     /* Reset the CCxNE Bit */
;;;1864     TIMx->CCER &= (uint16_t) ~tmp;
00058c  8c04              LDRH     r4,[r0,#0x20]
00058e  408b              LSLS     r3,r3,r1              ;1861
000590  439c              BICS     r4,r4,r3
000592  8404              STRH     r4,[r0,#0x20]
;;;1865   
;;;1866     /* Set or reset the CCxNE Bit */ 
;;;1867     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000594  8c03              LDRH     r3,[r0,#0x20]
000596  408a              LSLS     r2,r2,r1
000598  4313              ORRS     r3,r3,r2
00059a  8403              STRH     r3,[r0,#0x20]
;;;1868   }
00059c  bd10              POP      {r4,pc}
;;;1869   
                          ENDP

                  TIM_SelectCOM PROC
;;;1876     */
;;;1877   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
00059e  2204              MOVS     r2,#4
;;;1878   {
;;;1879     /* Check the parameters */
;;;1880     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1881     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1882     if (NewState != DISABLE)
0005a0  2900              CMP      r1,#0
;;;1883     {
;;;1884       /* Set the COM Bit */
;;;1885       TIMx->CR2 |= TIM_CR2_CCUS;
;;;1886     }
;;;1887     else
;;;1888     {
;;;1889       /* Reset the COM Bit */
;;;1890       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
0005a2  8881              LDRH     r1,[r0,#4]
0005a4  d001              BEQ      |L1.1450|
0005a6  4311              ORRS     r1,r1,r2              ;1885
0005a8  e000              B        |L1.1452|
                  |L1.1450|
0005aa  4391              BICS     r1,r1,r2
                  |L1.1452|
0005ac  8081              STRH     r1,[r0,#4]            ;1885
;;;1891     }
;;;1892   }
0005ae  e717              B        |L1.992|
;;;1893   
                          ENDP

                  TIM_SetIC4Prescaler PROC
;;;2215     */
;;;2216   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
0005b0  8b82              LDRH     r2,[r0,#0x1c]
;;;2217   {  
;;;2218     /* Check the parameters */
;;;2219     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2220     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2221     
;;;2222     /* Reset the IC4PSC Bits */
;;;2223     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
0005b2  4b9a              LDR      r3,|L1.2076|
0005b4  401a              ANDS     r2,r2,r3
0005b6  8382              STRH     r2,[r0,#0x1c]
;;;2224     /* Set the IC4PSC value */
;;;2225     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
0005b8  8b82              LDRH     r2,[r0,#0x1c]
0005ba  0209              LSLS     r1,r1,#8
0005bc  430a              ORRS     r2,r2,r1
0005be  8382              STRH     r2,[r0,#0x1c]
;;;2226   }
0005c0  e70e              B        |L1.992|
;;;2227   
                          ENDP

                  TIM_SetIC3Prescaler PROC
;;;2192     */
;;;2193   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
0005c2  8b82              LDRH     r2,[r0,#0x1c]
;;;2194   {
;;;2195     /* Check the parameters */
;;;2196     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2197     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2198     
;;;2199     /* Reset the IC3PSC Bits */
;;;2200     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
0005c4  230c              MOVS     r3,#0xc
0005c6  439a              BICS     r2,r2,r3
0005c8  8382              STRH     r2,[r0,#0x1c]
;;;2201     /* Set the IC3PSC value */
;;;2202     TIMx->CCMR2 |= TIM_ICPSC;
0005ca  8b82              LDRH     r2,[r0,#0x1c]
0005cc  430a              ORRS     r2,r2,r1
0005ce  8382              STRH     r2,[r0,#0x1c]
;;;2203   }
0005d0  e706              B        |L1.992|
;;;2204   
                          ENDP

                  TIM_SetIC2Prescaler PROC
;;;2169     */
;;;2170   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
0005d2  8b02              LDRH     r2,[r0,#0x18]
;;;2171   {
;;;2172     /* Check the parameters */
;;;2173     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2174     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2175     
;;;2176     /* Reset the IC2PSC Bits */
;;;2177     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
0005d4  4b91              LDR      r3,|L1.2076|
0005d6  401a              ANDS     r2,r2,r3
0005d8  8302              STRH     r2,[r0,#0x18]
;;;2178     /* Set the IC2PSC value */
;;;2179     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
0005da  8b02              LDRH     r2,[r0,#0x18]
0005dc  0209              LSLS     r1,r1,#8
0005de  430a              ORRS     r2,r2,r1
0005e0  8302              STRH     r2,[r0,#0x18]
;;;2180   }
0005e2  e6fd              B        |L1.992|
;;;2181   
                          ENDP

                  TI2_Config PROC
;;;3100     */
;;;3101   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
0005e4  b5f0              PUSH     {r4-r7,lr}
;;;3102                          uint16_t TIM_ICFilter)
;;;3103   {
;;;3104     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
;;;3105     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3106     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
0005e6  8c04              LDRH     r4,[r0,#0x20]
0005e8  2610              MOVS     r6,#0x10
0005ea  43b4              BICS     r4,r4,r6
0005ec  8404              STRH     r4,[r0,#0x20]
;;;3107     tmpccmr1 = TIMx->CCMR1;
0005ee  8b05              LDRH     r5,[r0,#0x18]
;;;3108     tmpccer = TIMx->CCER;
0005f0  8c04              LDRH     r4,[r0,#0x20]
;;;3109     tmp = (uint16_t)(TIM_ICPolarity << 4);
;;;3110     /* Select the Input and set the filter */
;;;3111     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
0005f2  4f8b              LDR      r7,|L1.2080|
;;;3112     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
0005f4  031b              LSLS     r3,r3,#12
0005f6  0109              LSLS     r1,r1,#4              ;3109
0005f8  403d              ANDS     r5,r5,r7              ;3111
0005fa  432b              ORRS     r3,r3,r5
;;;3113     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
0005fc  0212              LSLS     r2,r2,#8
0005fe  431a              ORRS     r2,r2,r3
;;;3114     /* Select the Polarity and set the CC2E Bit */
;;;3115     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
000600  23a0              MOVS     r3,#0xa0
000602  439c              BICS     r4,r4,r3
;;;3116     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
000604  430c              ORRS     r4,r4,r1
000606  4334              ORRS     r4,r4,r6
;;;3117     /* Write to TIMx CCMR1 and CCER registers */
;;;3118     TIMx->CCMR1 = tmpccmr1 ;
000608  8302              STRH     r2,[r0,#0x18]
;;;3119     TIMx->CCER = tmpccer;
00060a  8404              STRH     r4,[r0,#0x20]
;;;3120   }
00060c  bdf0              POP      {r4-r7,pc}
;;;3121   
                          ENDP

                  TIM_SetIC1Prescaler PROC
;;;2146     */
;;;2147   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
00060e  8b02              LDRH     r2,[r0,#0x18]
;;;2148   {
;;;2149     /* Check the parameters */
;;;2150     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2151     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2152     
;;;2153     /* Reset the IC1PSC Bits */
;;;2154     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
000610  230c              MOVS     r3,#0xc
000612  439a              BICS     r2,r2,r3
000614  8302              STRH     r2,[r0,#0x18]
;;;2155     /* Set the IC1PSC value */
;;;2156     TIMx->CCMR1 |= TIM_ICPSC;
000616  8b02              LDRH     r2,[r0,#0x18]
000618  430a              ORRS     r2,r2,r1
00061a  8302              STRH     r2,[r0,#0x18]
;;;2157   }
00061c  e6e0              B        |L1.992|
;;;2158   
                          ENDP

                  TI1_Config PROC
;;;3064     */
;;;3065   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
00061e  b570              PUSH     {r4-r6,lr}
;;;3066                          uint16_t TIM_ICFilter)
;;;3067   {
;;;3068     uint16_t tmpccmr1 = 0, tmpccer = 0;
;;;3069     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3070     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
000620  8c04              LDRH     r4,[r0,#0x20]
000622  0864              LSRS     r4,r4,#1
000624  0064              LSLS     r4,r4,#1
000626  8404              STRH     r4,[r0,#0x20]
;;;3071     tmpccmr1 = TIMx->CCMR1;
000628  8b05              LDRH     r5,[r0,#0x18]
;;;3072     tmpccer = TIMx->CCER;
00062a  8c04              LDRH     r4,[r0,#0x20]
;;;3073     /* Select the Input and set the filter */
;;;3074     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
;;;3075     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00062c  011b              LSLS     r3,r3,#4
00062e  4313              ORRS     r3,r3,r2
000630  26f3              MOVS     r6,#0xf3              ;3074
;;;3076    
;;;3077     /* Select the Polarity and set the CC1E Bit */
;;;3078     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
000632  220a              MOVS     r2,#0xa
000634  43b5              BICS     r5,r5,r6              ;3074
000636  4394              BICS     r4,r4,r2
000638  432b              ORRS     r3,r3,r5              ;3075
;;;3079     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
00063a  430c              ORRS     r4,r4,r1
00063c  2101              MOVS     r1,#1
00063e  430c              ORRS     r4,r4,r1
;;;3080     /* Write to TIMx CCMR1 and CCER registers */
;;;3081     TIMx->CCMR1 = tmpccmr1;
000640  8303              STRH     r3,[r0,#0x18]
;;;3082     TIMx->CCER = tmpccer;
000642  8404              STRH     r4,[r0,#0x20]
;;;3083   }
000644  bd70              POP      {r4-r6,pc}
;;;3084   
                          ENDP

                  TIM_ICInit PROC
;;;1952     */
;;;1953   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000646  b5f8              PUSH     {r3-r7,lr}
;;;1954   {
000648  4605              MOV      r5,r0
;;;1955     /* Check the parameters */
;;;1956     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1957     assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));  
;;;1958     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1959     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1960     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1961     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1962   
;;;1963     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00064a  8808              LDRH     r0,[r1,#0]
;;;1964     {
;;;1965       assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1966       /* TI1 Configuration */
;;;1967       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00064c  884e              LDRH     r6,[r1,#2]
00064e  888a              LDRH     r2,[r1,#4]
000650  890b              LDRH     r3,[r1,#8]
000652  460c              MOV      r4,r1                 ;1954
000654  2800              CMP      r0,#0                 ;1963
000656  d01d              BEQ      |L1.1684|
;;;1968                  TIM_ICInitStruct->TIM_ICSelection,
;;;1969                  TIM_ICInitStruct->TIM_ICFilter);
;;;1970       /* Set the Input Capture Prescaler value */
;;;1971       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1972     }
;;;1973     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000658  2804              CMP      r0,#4
00065a  d024              BEQ      |L1.1702|
;;;1974     {
;;;1975       assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1976       /* TI2 Configuration */
;;;1977       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1978                  TIM_ICInitStruct->TIM_ICSelection,
;;;1979                  TIM_ICInitStruct->TIM_ICFilter);
;;;1980       /* Set the Input Capture Prescaler value */
;;;1981       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1982     }
;;;1983     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
00065c  2808              CMP      r0,#8
00065e  8c28              LDRH     r0,[r5,#0x20]
000660  d02a              BEQ      |L1.1720|
000662  4970              LDR      r1,|L1.2084|
000664  4008              ANDS     r0,r0,r1
000666  8428              STRH     r0,[r5,#0x20]
000668  8ba8              LDRH     r0,[r5,#0x1c]
00066a  8c2f              LDRH     r7,[r5,#0x20]
00066c  0331              LSLS     r1,r6,#12
00066e  4e6c              LDR      r6,|L1.2080|
000670  0212              LSLS     r2,r2,#8
000672  4030              ANDS     r0,r0,r6
000674  4302              ORRS     r2,r2,r0
000676  0318              LSLS     r0,r3,#12
000678  4310              ORRS     r0,r0,r2
00067a  4a6b              LDR      r2,|L1.2088|
00067c  83a8              STRH     r0,[r5,#0x1c]
00067e  4017              ANDS     r7,r7,r2
000680  430f              ORRS     r7,r7,r1
000682  2101              MOVS     r1,#1
000684  0309              LSLS     r1,r1,#12
000686  430f              ORRS     r7,r7,r1
000688  842f              STRH     r7,[r5,#0x20]
;;;1984     {
;;;1985       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1986       /* TI3 Configuration */
;;;1987       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;1988                  TIM_ICInitStruct->TIM_ICSelection,
;;;1989                  TIM_ICInitStruct->TIM_ICFilter);
;;;1990       /* Set the Input Capture Prescaler value */
;;;1991       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1992     }
;;;1993     else
;;;1994     {
;;;1995       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1996       /* TI4 Configuration */
;;;1997       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1998                  TIM_ICInitStruct->TIM_ICSelection,
;;;1999                  TIM_ICInitStruct->TIM_ICFilter);
;;;2000       /* Set the Input Capture Prescaler value */
;;;2001       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00068a  88e1              LDRH     r1,[r4,#6]
00068c  4628              MOV      r0,r5
00068e  f7fffffe          BL       TIM_SetIC4Prescaler
;;;2002     }
;;;2003   }
000692  bdf8              POP      {r3-r7,pc}
                  |L1.1684|
000694  4631              MOV      r1,r6
000696  4628              MOV      r0,r5                 ;1967
000698  f7fffffe          BL       TI1_Config
00069c  88e1              LDRH     r1,[r4,#6]            ;1971
00069e  4628              MOV      r0,r5                 ;1971
0006a0  f7fffffe          BL       TIM_SetIC1Prescaler
0006a4  bdf8              POP      {r3-r7,pc}
                  |L1.1702|
0006a6  4631              MOV      r1,r6
0006a8  4628              MOV      r0,r5                 ;1977
0006aa  f7fffffe          BL       TI2_Config
0006ae  88e1              LDRH     r1,[r4,#6]            ;1981
0006b0  4628              MOV      r0,r5                 ;1981
0006b2  f7fffffe          BL       TIM_SetIC2Prescaler
0006b6  bdf8              POP      {r3-r7,pc}
                  |L1.1720|
0006b8  495c              LDR      r1,|L1.2092|
0006ba  4008              ANDS     r0,r0,r1
0006bc  8428              STRH     r0,[r5,#0x20]
0006be  8ba9              LDRH     r1,[r5,#0x1c]
0006c0  8c28              LDRH     r0,[r5,#0x20]
0006c2  0237              LSLS     r7,r6,#8
0006c4  26f3              MOVS     r6,#0xf3
0006c6  011b              LSLS     r3,r3,#4
0006c8  43b1              BICS     r1,r1,r6
0006ca  4313              ORRS     r3,r3,r2
0006cc  430b              ORRS     r3,r3,r1
0006ce  4958              LDR      r1,|L1.2096|
0006d0  83ab              STRH     r3,[r5,#0x1c]
0006d2  4008              ANDS     r0,r0,r1
0006d4  21ff              MOVS     r1,#0xff
0006d6  4338              ORRS     r0,r0,r7
0006d8  3101              ADDS     r1,#1
0006da  4308              ORRS     r0,r0,r1
0006dc  8428              STRH     r0,[r5,#0x20]
0006de  88e1              LDRH     r1,[r4,#6]            ;1991
0006e0  4628              MOV      r0,r5                 ;1991
0006e2  f7fffffe          BL       TIM_SetIC3Prescaler
0006e6  bdf8              POP      {r3-r7,pc}
;;;2004   
                          ENDP

                  TIM_ICStructInit PROC
;;;2010     */
;;;2011   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
0006e8  2100              MOVS     r1,#0
;;;2012   {
;;;2013     /* Set the default configuration */
;;;2014     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
0006ea  8001              STRH     r1,[r0,#0]
;;;2015     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
0006ec  8041              STRH     r1,[r0,#2]
;;;2016     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
0006ee  2201              MOVS     r2,#1
0006f0  8082              STRH     r2,[r0,#4]
;;;2017     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
0006f2  80c1              STRH     r1,[r0,#6]
;;;2018     TIM_ICInitStruct->TIM_ICFilter = 0x00;
0006f4  8101              STRH     r1,[r0,#8]
;;;2019   }
0006f6  e673              B        |L1.992|
;;;2020   
                          ENDP

                  TIM_PWMIConfig PROC
;;;2029     */
;;;2030   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
0006f8  b5f8              PUSH     {r3-r7,lr}
;;;2031   {
0006fa  460c              MOV      r4,r1
;;;2032     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
;;;2033     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
;;;2034     /* Check the parameters */
;;;2035     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2036     /* Select the Opposite Input Polarity */
;;;2037     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
0006fc  8849              LDRH     r1,[r1,#2]
0006fe  2600              MOVS     r6,#0                 ;2032
000700  2501              MOVS     r5,#1                 ;2033
000702  4607              MOV      r7,r0                 ;2031
000704  2900              CMP      r1,#0
000706  d100              BNE      |L1.1802|
;;;2038     {
;;;2039       icoppositepolarity = TIM_ICPolarity_Falling;
000708  2602              MOVS     r6,#2
                  |L1.1802|
;;;2040     }
;;;2041     else
;;;2042     {
;;;2043       icoppositepolarity = TIM_ICPolarity_Rising;
;;;2044     }
;;;2045     /* Select the Opposite Input */
;;;2046     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
00070a  88a2              LDRH     r2,[r4,#4]
00070c  2a01              CMP      r2,#1
00070e  d100              BNE      |L1.1810|
;;;2047     {
;;;2048       icoppositeselection = TIM_ICSelection_IndirectTI;
000710  2502              MOVS     r5,#2
                  |L1.1810|
;;;2049     }
;;;2050     else
;;;2051     {
;;;2052       icoppositeselection = TIM_ICSelection_DirectTI;
;;;2053     }
;;;2054     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000712  8820              LDRH     r0,[r4,#0]
;;;2055     {
;;;2056       /* TI1 Configuration */
;;;2057       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000714  8923              LDRH     r3,[r4,#8]
000716  2800              CMP      r0,#0                 ;2054
;;;2058                  TIM_ICInitStruct->TIM_ICFilter);
;;;2059       /* Set the Input Capture Prescaler value */
;;;2060       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2061       /* TI2 Configuration */
;;;2062       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;2063       /* Set the Input Capture Prescaler value */
;;;2064       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2065     }
;;;2066     else
;;;2067     { 
;;;2068       /* TI2 Configuration */
;;;2069       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000718  4638              MOV      r0,r7
00071a  d010              BEQ      |L1.1854|
00071c  f7fffffe          BL       TI2_Config
;;;2070                  TIM_ICInitStruct->TIM_ICFilter);
;;;2071       /* Set the Input Capture Prescaler value */
;;;2072       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000720  88e1              LDRH     r1,[r4,#6]
000722  4638              MOV      r0,r7
000724  f7fffffe          BL       TIM_SetIC2Prescaler
;;;2073       /* TI1 Configuration */
;;;2074       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000728  8923              LDRH     r3,[r4,#8]
00072a  462a              MOV      r2,r5
00072c  4631              MOV      r1,r6
00072e  4638              MOV      r0,r7
000730  f7fffffe          BL       TI1_Config
;;;2075       /* Set the Input Capture Prescaler value */
;;;2076       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000734  88e1              LDRH     r1,[r4,#6]
000736  4638              MOV      r0,r7
000738  f7fffffe          BL       TIM_SetIC1Prescaler
;;;2077     }
;;;2078   }
00073c  bdf8              POP      {r3-r7,pc}
                  |L1.1854|
00073e  f7fffffe          BL       TI1_Config
000742  88e1              LDRH     r1,[r4,#6]            ;2060
000744  4638              MOV      r0,r7                 ;2060
000746  f7fffffe          BL       TIM_SetIC1Prescaler
00074a  8923              LDRH     r3,[r4,#8]            ;2062
00074c  462a              MOV      r2,r5                 ;2062
00074e  4631              MOV      r1,r6                 ;2062
000750  4638              MOV      r0,r7                 ;2062
000752  f7fffffe          BL       TI2_Config
000756  88e1              LDRH     r1,[r4,#6]            ;2064
000758  4638              MOV      r0,r7                 ;2064
00075a  f7fffffe          BL       TIM_SetIC2Prescaler
00075e  bdf8              POP      {r3-r7,pc}
;;;2079   
                          ENDP

                  TIM_GetCapture1 PROC
;;;2084     */
;;;2085   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000760  6b40              LDR      r0,[r0,#0x34]
;;;2086   {
;;;2087     /* Check the parameters */
;;;2088     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2089     
;;;2090     /* Get the Capture 1 Register value */
;;;2091     return TIMx->CCR1;
;;;2092   }
000762  e63d              B        |L1.992|
;;;2093   
                          ENDP

                  TIM_GetCapture2 PROC
;;;2098     */
;;;2099   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000764  6b80              LDR      r0,[r0,#0x38]
;;;2100   {
;;;2101     /* Check the parameters */
;;;2102     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2103     
;;;2104     /* Get the Capture 2 Register value */
;;;2105     return TIMx->CCR2;
;;;2106   }
000766  e63b              B        |L1.992|
;;;2107   
                          ENDP

                  TIM_GetCapture3 PROC
;;;2112     */
;;;2113   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000768  6bc0              LDR      r0,[r0,#0x3c]
;;;2114   {
;;;2115     /* Check the parameters */
;;;2116     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2117     
;;;2118     /* Get the Capture 3 Register value */
;;;2119     return TIMx->CCR3;
;;;2120   }
00076a  e639              B        |L1.992|
;;;2121   
                          ENDP

                  TIM_GetCapture4 PROC
;;;2126     */
;;;2127   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
00076c  6c00              LDR      r0,[r0,#0x40]
;;;2128   {
;;;2129     /* Check the parameters */
;;;2130     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2131     
;;;2132     /* Get the Capture 4 Register value */
;;;2133     return TIMx->CCR4;
;;;2134   }
00076e  e637              B        |L1.992|
;;;2135   
                          ENDP

                  TIM_ITConfig PROC
;;;2267     */
;;;2268   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000770  2a00              CMP      r2,#0
;;;2269   {  
;;;2270     /* Check the parameters */
;;;2271     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2272     assert_param(IS_TIM_IT(TIM_IT));
;;;2273     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2274     
;;;2275     if (NewState != DISABLE)
;;;2276     {
;;;2277       /* Enable the Interrupt sources */
;;;2278       TIMx->DIER |= TIM_IT;
;;;2279     }
;;;2280     else
;;;2281     {
;;;2282       /* Disable the Interrupt sources */
;;;2283       TIMx->DIER &= (uint16_t)~TIM_IT;
000772  8982              LDRH     r2,[r0,#0xc]
000774  d001              BEQ      |L1.1914|
000776  430a              ORRS     r2,r2,r1              ;2278
000778  e000              B        |L1.1916|
                  |L1.1914|
00077a  438a              BICS     r2,r2,r1
                  |L1.1916|
00077c  8182              STRH     r2,[r0,#0xc]          ;2278
;;;2284     }
;;;2285   }
00077e  e62f              B        |L1.992|
;;;2286   
                          ENDP

                  TIM_GenerateEvent PROC
;;;2307     */
;;;2308   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000780  8281              STRH     r1,[r0,#0x14]
;;;2309   { 
;;;2310     /* Check the parameters */
;;;2311     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2312     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource)); 
;;;2313     /* Set the event sources */
;;;2314     TIMx->EGR = TIM_EventSource;
;;;2315   }
000782  e62d              B        |L1.992|
;;;2316   
                          ENDP

                  TIM_GetFlagStatus PROC
;;;2342     */
;;;2343   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000784  4602              MOV      r2,r0
;;;2344   { 
;;;2345     ITStatus bitstatus = RESET; 
;;;2346      
;;;2347     /* Check the parameters */
;;;2348     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2349     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2350     
;;;2351     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000786  8a12              LDRH     r2,[r2,#0x10]
000788  2000              MOVS     r0,#0                 ;2345
00078a  420a              TST      r2,r1
00078c  d000              BEQ      |L1.1936|
;;;2352     {
;;;2353       bitstatus = SET;
00078e  2001              MOVS     r0,#1
                  |L1.1936|
;;;2354     }
;;;2355     else
;;;2356     {
;;;2357       bitstatus = RESET;
;;;2358     }
;;;2359     return bitstatus;
;;;2360   }
000790  e626              B        |L1.992|
;;;2361   
                          ENDP

                  TIM_ClearFlag PROC
;;;2387     */
;;;2388   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000792  43c9              MVNS     r1,r1
;;;2389   {  
;;;2390     /* Check the parameters */
;;;2391     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2392     assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
;;;2393      
;;;2394     /* Clear the flags */
;;;2395     TIMx->SR = (uint16_t)~TIM_FLAG;
000794  8201              STRH     r1,[r0,#0x10]
;;;2396   }
000796  e623              B        |L1.992|
;;;2397   
                          ENDP

                  TIM_GetITStatus PROC
;;;2418     */
;;;2419   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000798  4602              MOV      r2,r0
;;;2420   {
;;;2421     ITStatus bitstatus = RESET;  
;;;2422     uint16_t itstatus = 0x0, itenable = 0x0;
;;;2423     
;;;2424     /* Check the parameters */
;;;2425     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2426     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2427      
;;;2428     itstatus = TIMx->SR & TIM_IT;
00079a  8a13              LDRH     r3,[r2,#0x10]
00079c  2000              MOVS     r0,#0                 ;2421
;;;2429     
;;;2430     itenable = TIMx->DIER & TIM_IT;
00079e  8992              LDRH     r2,[r2,#0xc]
0007a0  400b              ANDS     r3,r3,r1              ;2428
0007a2  400a              ANDS     r2,r2,r1
;;;2431     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
0007a4  2b00              CMP      r3,#0
0007a6  d002              BEQ      |L1.1966|
0007a8  2a00              CMP      r2,#0
0007aa  d000              BEQ      |L1.1966|
;;;2432     {
;;;2433       bitstatus = SET;
0007ac  2001              MOVS     r0,#1
                  |L1.1966|
;;;2434     }
;;;2435     else
;;;2436     {
;;;2437       bitstatus = RESET;
;;;2438     }
;;;2439     return bitstatus;
;;;2440   }
0007ae  e617              B        |L1.992|
;;;2441   
                          ENDP

                  TIM_ClearITPendingBit PROC
;;;2462     */
;;;2463   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
0007b0  43c9              MVNS     r1,r1
;;;2464   {
;;;2465     /* Check the parameters */
;;;2466     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2467     assert_param(IS_TIM_IT(TIM_IT));
;;;2468      
;;;2469     /* Clear the IT pending Bit */
;;;2470     TIMx->SR = (uint16_t)~TIM_IT;
0007b2  8201              STRH     r1,[r0,#0x10]
;;;2471   }
0007b4  e614              B        |L1.992|
;;;2472   
                          ENDP

                  TIM_DMAConfig PROC
;;;2488     */
;;;2489   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
0007b6  4311              ORRS     r1,r1,r2
;;;2490   {
;;;2491     /* Check the parameters */
;;;2492     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2493     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2494     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2495     /* Set the DMA Base and the DMA Burst Length */
;;;2496     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
0007b8  3040              ADDS     r0,r0,#0x40
0007ba  8101              STRH     r1,[r0,#8]
;;;2497   }
0007bc  e610              B        |L1.992|
;;;2498   
                          ENDP

                  TIM_DMACmd PROC
;;;2514     */
;;;2515   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
0007be  2a00              CMP      r2,#0
;;;2516   { 
;;;2517     /* Check the parameters */
;;;2518     assert_param(IS_TIM_LIST10_PERIPH(TIMx));
;;;2519     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2520     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2521     
;;;2522     if (NewState != DISABLE)
;;;2523     {
;;;2524       /* Enable the DMA sources */
;;;2525       TIMx->DIER |= TIM_DMASource; 
;;;2526     }
;;;2527     else
;;;2528     {
;;;2529       /* Disable the DMA sources */
;;;2530       TIMx->DIER &= (uint16_t)~TIM_DMASource;
0007c0  8982              LDRH     r2,[r0,#0xc]
0007c2  d001              BEQ      |L1.1992|
0007c4  430a              ORRS     r2,r2,r1              ;2525
0007c6  e000              B        |L1.1994|
                  |L1.1992|
0007c8  438a              BICS     r2,r2,r1
                  |L1.1994|
0007ca  8182              STRH     r2,[r0,#0xc]          ;2525
;;;2531     }
;;;2532   }
0007cc  e608              B        |L1.992|
;;;2533   
                          ENDP

                  TIM_SelectCCDMA PROC
;;;2540     */
;;;2541   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
0007ce  2208              MOVS     r2,#8
;;;2542   {
;;;2543     /* Check the parameters */
;;;2544     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2545     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2546     
;;;2547     if (NewState != DISABLE)
0007d0  2900              CMP      r1,#0
;;;2548     {
;;;2549       /* Set the CCDS Bit */
;;;2550       TIMx->CR2 |= TIM_CR2_CCDS;
;;;2551     }
;;;2552     else
;;;2553     {
;;;2554       /* Reset the CCDS Bit */
;;;2555       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
0007d2  8881              LDRH     r1,[r0,#4]
0007d4  d001              BEQ      |L1.2010|
0007d6  4311              ORRS     r1,r1,r2              ;2550
0007d8  e000              B        |L1.2012|
                  |L1.2010|
0007da  4391              BICS     r1,r1,r2
                  |L1.2012|
0007dc  8081              STRH     r1,[r0,#4]            ;2550
;;;2556     }
;;;2557   }
0007de  e5ff              B        |L1.992|
;;;2558   
                          ENDP

                  TIM_InternalClockConfig PROC
;;;2579     */
;;;2580   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
0007e0  8901              LDRH     r1,[r0,#8]
;;;2581   {
;;;2582     /* Check the parameters */
;;;2583     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2584     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2585     TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
0007e2  08c9              LSRS     r1,r1,#3
0007e4  00c9              LSLS     r1,r1,#3
0007e6  8101              STRH     r1,[r0,#8]
;;;2586   }
0007e8  e5fa              B        |L1.992|
;;;2587   
                          ENDP

                  TIM_SelectInputTrigger PROC
;;;2774     */
;;;2775   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
0007ea  8902              LDRH     r2,[r0,#8]
;;;2776   {
;;;2777     uint16_t tmpsmcr = 0;
;;;2778   
;;;2779     /* Check the parameters */
;;;2780     assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;2781     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2782   
;;;2783     /* Get the TIMx SMCR register value */
;;;2784     tmpsmcr = TIMx->SMCR;
;;;2785     /* Reset the TS Bits */
;;;2786     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
0007ec  2370              MOVS     r3,#0x70
0007ee  439a              BICS     r2,r2,r3
;;;2787     /* Set the Input Trigger source */
;;;2788     tmpsmcr |= TIM_InputTriggerSource;
0007f0  430a              ORRS     r2,r2,r1
;;;2789     /* Write to TIMx SMCR */
;;;2790     TIMx->SMCR = tmpsmcr;
0007f2  8102              STRH     r2,[r0,#8]
;;;2791   }
0007f4  e5f4              B        |L1.992|
;;;2792   
                          ENDP

                  TIM_ITRxExternalClockConfig PROC
;;;2598     */
;;;2599   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
0007f6  b510              PUSH     {r4,lr}
;;;2600   {
0007f8  4604              MOV      r4,r0
;;;2601     /* Check the parameters */
;;;2602     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2603     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2604     /* Select the Internal Trigger */
;;;2605     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
0007fa  f7fffffe          BL       TIM_SelectInputTrigger
;;;2606     /* Select the External clock mode1 */
;;;2607     TIMx->SMCR |= TIM_SlaveMode_External1;
0007fe  8920              LDRH     r0,[r4,#8]
000800  2107              MOVS     r1,#7
000802  4308              ORRS     r0,r0,r1
000804  8120              STRH     r0,[r4,#8]
;;;2608   }
000806  bd10              POP      {r4,pc}
                  |L1.2056|
                          DCD      0x00008fff
                  |L1.2060|
                          DCD      0x0000f7ff
                  |L1.2064|
                          DCD      0x0000fbff
                  |L1.2068|
                          DCD      0x0000fdff
                  |L1.2072|
                          DCD      0x0000dfff
                  |L1.2076|
                          DCD      0x0000f3ff
                  |L1.2080|
                          DCD      0x00000cff
                  |L1.2084|
                          DCD      0x0000efff
                  |L1.2088|
                          DCD      0x00005fff
                  |L1.2092|
                          DCD      0x0000feff
                  |L1.2096|
                          DCD      0x0000f5ff
                          ENDP

                  TIM_TIxExternalClockConfig PROC
;;;2625     */
;;;2626   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000834  b570              PUSH     {r4-r6,lr}
;;;2627                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2628   {
000836  4616              MOV      r6,r2
000838  460d              MOV      r5,r1
00083a  4604              MOV      r4,r0
;;;2629     /* Check the parameters */
;;;2630     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2631     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2632     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2633     
;;;2634     /* Configure the Timer Input Clock Source */
;;;2635     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00083c  2960              CMP      r1,#0x60
00083e  d00c              BEQ      |L1.2138|
;;;2636     {
;;;2637       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;2638     }
;;;2639     else
;;;2640     {
;;;2641       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000840  2201              MOVS     r2,#1
000842  4631              MOV      r1,r6
000844  f7fffffe          BL       TI1_Config
                  |L1.2120|
;;;2642     }
;;;2643     /* Select the Trigger source */
;;;2644     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
000848  4629              MOV      r1,r5
00084a  4620              MOV      r0,r4
00084c  f7fffffe          BL       TIM_SelectInputTrigger
;;;2645     /* Select the External clock mode1 */
;;;2646     TIMx->SMCR |= TIM_SlaveMode_External1;
000850  8920              LDRH     r0,[r4,#8]
000852  2107              MOVS     r1,#7
000854  4308              ORRS     r0,r0,r1
000856  8120              STRH     r0,[r4,#8]
;;;2647   }
000858  bd70              POP      {r4-r6,pc}
                  |L1.2138|
00085a  2201              MOVS     r2,#1                 ;2637
00085c  4631              MOV      r1,r6                 ;2637
00085e  f7fffffe          BL       TI2_Config
000862  e7f1              B        |L1.2120|
;;;2648   
                          ENDP

                  TIM_ETRConfig PROC
;;;2889     */
;;;2890   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000864  b510              PUSH     {r4,lr}
;;;2891                      uint16_t ExtTRGFilter)
;;;2892   {
;;;2893     uint16_t tmpsmcr = 0;
;;;2894     
;;;2895     /* Check the parameters */
;;;2896     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2897     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2898     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2899     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2900     
;;;2901     tmpsmcr = TIMx->SMCR;
000866  8904              LDRH     r4,[r0,#8]
;;;2902     /* Reset the ETR Bits */
;;;2903     tmpsmcr &= SMCR_ETR_MASK;
;;;2904     /* Set the Prescaler, the Filter value and the Polarity */
;;;2905     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000868  021b              LSLS     r3,r3,#8
00086a  4313              ORRS     r3,r3,r2
00086c  b2e4              UXTB     r4,r4                 ;2903
00086e  430b              ORRS     r3,r3,r1
000870  4323              ORRS     r3,r3,r4
;;;2906     /* Write to TIMx SMCR */
;;;2907     TIMx->SMCR = tmpsmcr;
000872  8103              STRH     r3,[r0,#8]
;;;2908   }
000874  bd10              POP      {r4,pc}
;;;2909   
                          ENDP

                  TIM_ETRClockMode1Config PROC
;;;2665     */
;;;2666   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000876  b510              PUSH     {r4,lr}
;;;2667                                uint16_t ExtTRGFilter)
;;;2668   {
000878  4604              MOV      r4,r0
;;;2669     uint16_t tmpsmcr = 0;
;;;2670     
;;;2671     /* Check the parameters */
;;;2672     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2673     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2674     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2675     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2676     
;;;2677     /* Configure the ETR Clock source */
;;;2678     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00087a  f7fffffe          BL       TIM_ETRConfig
;;;2679     
;;;2680     /* Get the TIMx SMCR register value */
;;;2681     tmpsmcr = TIMx->SMCR;
00087e  8920              LDRH     r0,[r4,#8]
;;;2682     /* Reset the SMS Bits */
;;;2683     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000880  08c1              LSRS     r1,r0,#3
000882  00c9              LSLS     r1,r1,#3
;;;2684     /* Select the External clock mode1 */
;;;2685     tmpsmcr |= TIM_SlaveMode_External1;
000884  2007              MOVS     r0,#7
000886  4301              ORRS     r1,r1,r0
;;;2686     /* Select the Trigger selection : ETRF */
;;;2687     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000888  2070              MOVS     r0,#0x70
00088a  4381              BICS     r1,r1,r0
;;;2688     tmpsmcr |= TIM_TS_ETRF;
00088c  4301              ORRS     r1,r1,r0
;;;2689     /* Write to TIMx SMCR */
;;;2690     TIMx->SMCR = tmpsmcr;
00088e  8121              STRH     r1,[r4,#8]
;;;2691   }
000890  bd10              POP      {r4,pc}
;;;2692   
                          ENDP

                  TIM_ETRClockMode2Config PROC
;;;2709     */
;;;2710   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000892  b510              PUSH     {r4,lr}
;;;2711                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2712   {
000894  4604              MOV      r4,r0
;;;2713     /* Check the parameters */
;;;2714     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2715     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2716     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2717     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2718     
;;;2719     /* Configure the ETR Clock source */
;;;2720     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000896  f7fffffe          BL       TIM_ETRConfig
;;;2721     /* Enable the External clock mode2 */
;;;2722     TIMx->SMCR |= TIM_SMCR_ECE;
00089a  8920              LDRH     r0,[r4,#8]
00089c  2101              MOVS     r1,#1
00089e  0389              LSLS     r1,r1,#14
0008a0  4308              ORRS     r0,r0,r1
0008a2  8120              STRH     r0,[r4,#8]
;;;2723   }
0008a4  bd10              POP      {r4,pc}
;;;2724   
                          ENDP

                  TIM_SelectOutputTrigger PROC
;;;2813     */
;;;2814   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
0008a6  8882              LDRH     r2,[r0,#4]
;;;2815   {
;;;2816     /* Check the parameters */
;;;2817     assert_param(IS_TIM_LIST9_PERIPH(TIMx));
;;;2818     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2819   
;;;2820     /* Reset the MMS Bits */
;;;2821     TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
0008a8  2370              MOVS     r3,#0x70
0008aa  439a              BICS     r2,r2,r3
0008ac  8082              STRH     r2,[r0,#4]
;;;2822     /* Select the TRGO source */
;;;2823     TIMx->CR2 |=  TIM_TRGOSource;
0008ae  8882              LDRH     r2,[r0,#4]
0008b0  430a              ORRS     r2,r2,r1
0008b2  8082              STRH     r2,[r0,#4]
;;;2824   }
0008b4  e594              B        |L1.992|
;;;2825   
                          ENDP

                  TIM_SelectSlaveMode PROC
;;;2837     */
;;;2838   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
0008b6  8902              LDRH     r2,[r0,#8]
;;;2839   {
;;;2840     /* Check the parameters */
;;;2841     assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;2842     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2843     
;;;2844     /* Reset the SMS Bits */
;;;2845     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
0008b8  08d2              LSRS     r2,r2,#3
0008ba  00d2              LSLS     r2,r2,#3
0008bc  8102              STRH     r2,[r0,#8]
;;;2846     /* Select the Slave Mode */
;;;2847     TIMx->SMCR |= TIM_SlaveMode;
0008be  8902              LDRH     r2,[r0,#8]
0008c0  430a              ORRS     r2,r2,r1
0008c2  8102              STRH     r2,[r0,#8]
;;;2848   }
0008c4  e58c              B        |L1.992|
;;;2849   
                          ENDP

                  TIM_SelectMasterSlaveMode PROC
;;;2859     */
;;;2860   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
0008c6  8902              LDRH     r2,[r0,#8]
;;;2861   {
;;;2862     /* Check the parameters */
;;;2863     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2864     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2865     
;;;2866     /* Reset the MSM Bit */
;;;2867     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
0008c8  2380              MOVS     r3,#0x80
0008ca  439a              BICS     r2,r2,r3
0008cc  8102              STRH     r2,[r0,#8]
;;;2868     
;;;2869     /* Set or Reset the MSM Bit */
;;;2870     TIMx->SMCR |= TIM_MasterSlaveMode;
0008ce  8902              LDRH     r2,[r0,#8]
0008d0  430a              ORRS     r2,r2,r1
0008d2  8102              STRH     r2,[r0,#8]
;;;2871   }
0008d4  e584              B        |L1.992|
;;;2872   
                          ENDP

                  TIM_EncoderInterfaceConfig PROC
;;;2944     */
;;;2945   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
0008d6  b570              PUSH     {r4-r6,lr}
;;;2946                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;2947   {
;;;2948     uint16_t tmpsmcr = 0;
;;;2949     uint16_t tmpccmr1 = 0;
;;;2950     uint16_t tmpccer = 0;
;;;2951       
;;;2952     /* Check the parameters */
;;;2953     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2954     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;2955     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;2956     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;2957     
;;;2958     /* Get the TIMx SMCR register value */
;;;2959     tmpsmcr = TIMx->SMCR;
0008d8  8905              LDRH     r5,[r0,#8]
;;;2960     /* Get the TIMx CCMR1 register value */
;;;2961     tmpccmr1 = TIMx->CCMR1;
0008da  8b04              LDRH     r4,[r0,#0x18]
;;;2962     /* Get the TIMx CCER register value */
;;;2963     tmpccer = TIMx->CCER;
0008dc  8c06              LDRH     r6,[r0,#0x20]
;;;2964     /* Set the encoder Mode */
;;;2965     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
0008de  08ed              LSRS     r5,r5,#3
0008e0  00ed              LSLS     r5,r5,#3
;;;2966     tmpsmcr |= TIM_EncoderMode;
0008e2  430d              ORRS     r5,r5,r1
;;;2967     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2968     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
0008e4  490c              LDR      r1,|L1.2328|
;;;2969     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
;;;2970     /* Set the TI1 and the TI2 Polarities */
;;;2971     //tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
;;;2972     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP)) & (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
;;;2973     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
;;;2974     /* Write to TIMx SMCR */
;;;2975     TIMx->SMCR = tmpsmcr;
0008e6  8105              STRH     r5,[r0,#8]
0008e8  400c              ANDS     r4,r4,r1              ;2968
0008ea  21ff              MOVS     r1,#0xff              ;2969
0008ec  3102              ADDS     r1,#2                 ;2969
0008ee  430c              ORRS     r4,r4,r1              ;2969
0008f0  21aa              MOVS     r1,#0xaa              ;2972
0008f2  438e              BICS     r6,r6,r1              ;2972
0008f4  0119              LSLS     r1,r3,#4              ;2973
0008f6  4311              ORRS     r1,r1,r2              ;2973
0008f8  4331              ORRS     r1,r1,r6              ;2973
;;;2976     /* Write to TIMx CCMR1 */
;;;2977     TIMx->CCMR1 = tmpccmr1;
0008fa  8304              STRH     r4,[r0,#0x18]
;;;2978     /* Write to TIMx CCER */
;;;2979     TIMx->CCER = tmpccer;
0008fc  8401              STRH     r1,[r0,#0x20]
;;;2980   }
0008fe  bd70              POP      {r4-r6,pc}
;;;2981   
                          ENDP

                  TIM_SelectHallSensor PROC
;;;2988     */
;;;2989   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000900  2280              MOVS     r2,#0x80
;;;2990   {
;;;2991     /* Check the parameters */
;;;2992     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2993     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2994     
;;;2995     if (NewState != DISABLE)
000902  2900              CMP      r1,#0
;;;2996     {
;;;2997       /* Set the TI1S Bit */
;;;2998       TIMx->CR2 |= TIM_CR2_TI1S;
;;;2999     }
;;;3000     else
;;;3001     {
;;;3002       /* Reset the TI1S Bit */
;;;3003       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
000904  8881              LDRH     r1,[r0,#4]
000906  d001              BEQ      |L1.2316|
000908  4311              ORRS     r1,r1,r2              ;2998
00090a  e000              B        |L1.2318|
                  |L1.2316|
00090c  4391              BICS     r1,r1,r2
                  |L1.2318|
00090e  8081              STRH     r1,[r0,#4]            ;2998
;;;3004     }
;;;3005   }
000910  e566              B        |L1.992|
;;;3006   
                          ENDP

                  TIM_RemapConfig PROC
;;;3034     */
;;;3035   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
000912  3040              ADDS     r0,r0,#0x40
;;;3036   {
;;;3037    /* Check the parameters */
;;;3038     assert_param(IS_TIM_LIST11_PERIPH(TIMx));
;;;3039     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;3040   
;;;3041     /* Set the Timer remapping configuration */
;;;3042     TIMx->OR =  TIM_Remap;
000914  8201              STRH     r1,[r0,#0x10]
;;;3043   }
000916  e563              B        |L1.992|
;;;3044   
                          ENDP

                  |L1.2328|
                          DCD      0x0000fcfc

;*** Start embedded assembler ***

#line 1 "..\\arch\\arm\\stm32f05x\\lib\\src\\stm32f0xx_tim.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_tim_c_c458916b____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f0xx_tim_c_c458916b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_tim_c_c458916b____REVSH|
#line 144
|__asm___15_stm32f0xx_tim_c_c458916b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
