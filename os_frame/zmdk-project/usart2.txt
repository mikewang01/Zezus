; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\usart2.o --asm_dir=.\ --list_dir=.\ --depend=.\usart2.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\usart2.crf ..\drivers\stm32f051x\char\usart\usart2.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart2_write PROC
;;;207    
;;;208    static os_size_t  uart2_write(os_device_t* dev, os_off_t pos, const void *buffer, os_size_t size)
000000  b510              PUSH     {r4,lr}
;;;209    {
000002  461c              MOV      r4,r3
000004  4610              MOV      r0,r2
;;;210        
;;;211        if(pos>=size||buffer==NULL||size>USART_TX_BUFFER_SIZE)
000006  42a1              CMP      r1,r4
000008  d203              BCS      |L1.18|
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L1.18|
00000e  2c40              CMP      r4,#0x40
000010  d901              BLS      |L1.22|
                  |L1.18|
;;;212        {
;;;213            return  NULL;
000012  2000              MOVS     r0,#0
;;;214        }else
;;;215        {
;;;216            
;;;217            osmemcpy(USART2_TX_BUF,(char *)buffer, size);
;;;218            USART2TX_DMA1_Channelx->CNDTR=size;//DMA channel x number of data register
;;;219            USART2TX_DMA1_Channelx->CMAR=(unsigned long)(USART2_TX_BUF);
;;;220            USART2TX_DMA1_Channelx->CCR|=1<<0;          //开启DMA传输
;;;221        }
;;;222        
;;;223        return SUCCESS;
;;;224    }	
000014  bd10              POP      {r4,pc}
                  |L1.22|
000016  4601              MOV      r1,r0                 ;217
000018  461a              MOV      r2,r3                 ;217
00001a  487d              LDR      r0,|L1.528|
00001c  f7fffffe          BL       osmemcpy
000020  487c              LDR      r0,|L1.532|
000022  6084              STR      r4,[r0,#8]            ;218
000024  497a              LDR      r1,|L1.528|
000026  6101              STR      r1,[r0,#0x10]         ;219
000028  6841              LDR      r1,[r0,#4]            ;220
00002a  2201              MOVS     r2,#1                 ;220
00002c  4311              ORRS     r1,r1,r2              ;220
00002e  6041              STR      r1,[r0,#4]            ;220
000030  4610              MOV      r0,r2                 ;223
000032  bd10              POP      {r4,pc}
;;;225    /*********************************************************************
                          ENDP

                  uart2_open PROC
;;;165     */
;;;166    static os_err_t  uart2_open(os_device_t* dev, u16 oflag)
000034  b510              PUSH     {r4,lr}
;;;167    {
;;;168        os_clock_open("AFIO");	
000036  a078              ADR      r0,|L1.536|
000038  f7fffffe          BL       os_clock_open
;;;169        os_clock_open("DMA1");	
00003c  a078              ADR      r0,|L1.544|
00003e  f7fffffe          BL       os_clock_open
;;;170        os_clock_open("USART1");
000042  a079              ADR      r0,|L1.552|
000044  f7fffffe          BL       os_clock_open
;;;171        os_clock_open("GPIOA");
000048  a079              ADR      r0,|L1.560|
00004a  f7fffffe          BL       os_clock_open
;;;172        os_clock_open("GPIOB");
00004e  a07a              ADR      r0,|L1.568|
000050  f7fffffe          BL       os_clock_open
;;;173        return SUCCESS;	
000054  2001              MOVS     r0,#1
;;;174    }
000056  bd10              POP      {r4,pc}
;;;175    
                          ENDP

                  uart2_init PROC
;;;100    #define USART2_REMAP
;;;101    os_err_t  uart2_init   (os_device_t* dev)
000058  b570              PUSH     {r4-r6,lr}
;;;102    {  	 
;;;103        float temp;
;;;104        u16 mantissa;
;;;105        u16 fraction;	
;;;106        os_device_t *__mptr = (dev);
;;;107        usart_device * usart_dev=(usart_device *)( (char *)__mptr - offsetof(usart_device,os_device));	
00005a  4604              MOV      r4,r0
;;;108        
;;;109        temp=(float)(usart_dev->pclk2*1000000)/(usart_dev->bound*16);//得到USARTDIV
00005c  6c40              LDR      r0,[r0,#0x44]
00005e  0100              LSLS     r0,r0,#4
000060  f7fffffe          BL       __aeabi_ui2f
000064  4605              MOV      r5,r0
000066  4976              LDR      r1,|L1.576|
000068  6c20              LDR      r0,[r4,#0x40]
00006a  4348              MULS     r0,r1,r0
00006c  f7fffffe          BL       __aeabi_ui2f
000070  4629              MOV      r1,r5
000072  f7fffffe          BL       __aeabi_fdiv
000076  4605              MOV      r5,r0
;;;110        mantissa=temp;				 //得到整数部分
000078  f7fffffe          BL       __aeabi_f2uiz
00007c  b284              UXTH     r4,r0
;;;111        fraction=(temp-mantissa)*16; //得到小数部分	 
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       __aeabi_ui2f
000084  4629              MOV      r1,r5
000086  f7fffffe          BL       __aeabi_frsub
00008a  2104              MOVS     r1,#4
00008c  f7fffffe          BL       __ARM_scalbnf
000090  f7fffffe          BL       __aeabi_f2uiz
;;;112        mantissa<<=4;
000094  0121              LSLS     r1,r4,#4
;;;113        mantissa+=fraction;
000096  180d              ADDS     r5,r1,r0
;;;114        
;;;115        os_clock_open("USART1");
000098  a063              ADR      r0,|L1.552|
00009a  f7fffffe          BL       os_clock_open
;;;116        
;;;117    #ifdef USART2_REMAP
;;;118        //	os_clock_open("GPIOB");
;;;119        //	GPIOB->CRL&=0X00FFFffF; 
;;;120        //	GPIOB->CRL|=0X8b000000;//IO状态设置
;;;121        //	RCC->APB2RSTR|=1<<14;   //复位串口1
;;;122        //  AFIO->MAPR|=1<<2;
;;;123        //	os_clock_close("GPIOB");
;;;124    #else
;;;125        os_clock_open("GPIOA");
;;;126        GPIOA->CRH&=0XFFFFF00F; 
;;;127        GPIOA->CRH|=0X000008B0;//IO状态设置
;;;128        RCC->APB2RSTR|=1<<14;   //复位串口1
;;;129        // os_clock_close("GPIOA");
;;;130    #endif	
;;;131        RCC->APB2RSTR&=~(1<<14);//停止复位	   	   
00009e  4869              LDR      r0,|L1.580|
0000a0  68c1              LDR      r1,[r0,#0xc]
0000a2  2201              MOVS     r2,#1
0000a4  0392              LSLS     r2,r2,#14
0000a6  4391              BICS     r1,r1,r2
0000a8  60c1              STR      r1,[r0,#0xc]
;;;132        
;;;133        
;;;134        USART1->CR3|=1<<7;//DMA enable transmitter
0000aa  4c67              LDR      r4,|L1.584|
0000ac  68a0              LDR      r0,[r4,#8]
0000ae  2180              MOVS     r1,#0x80
0000b0  4308              ORRS     r0,r0,r1
0000b2  60a0              STR      r0,[r4,#8]
;;;135        USART1->CR3|=1<<6;//DMA enable receiver
0000b4  68a0              LDR      r0,[r4,#8]
0000b6  2140              MOVS     r1,#0x40
0000b8  4308              ORRS     r0,r0,r1
0000ba  60a0              STR      r0,[r4,#8]
;;;136        
;;;137        //波特率设置
;;;138        USART1->BRR=mantissa; // 波特率设置	 
0000bc  81a5              STRH     r5,[r4,#0xc]
;;;139        USART1->CR1|=0X200C;  //1位停止,无校验位.
0000be  6820              LDR      r0,[r4,#0]
0000c0  4962              LDR      r1,|L1.588|
0000c2  4308              ORRS     r0,r0,r1
0000c4  6020              STR      r0,[r4,#0]
;;;140        
;;;141        os_clock_open("DMA1");		
0000c6  a056              ADR      r0,|L1.544|
0000c8  f7fffffe          BL       os_clock_open
;;;142        usart2_dma1_channel4_init();
;;;143        usart2_dma1_channel5_init();
0000cc  f7fffffe          BL       usart2_dma1_channel5_init
;;;144        os_clock_close("DMA1");	
0000d0  a053              ADR      r0,|L1.544|
0000d2  f7fffffe          BL       os_clock_close
;;;145        
;;;146        USART1->CR1|=1<<4;// IDLE interrupt enable
0000d6  6820              LDR      r0,[r4,#0]
0000d8  2110              MOVS     r1,#0x10
0000da  4308              ORRS     r0,r0,r1
0000dc  6020              STR      r0,[r4,#0]
;;;147        MY_NVIC_Init(0,1,USART1_IRQn,2);//组2，最低优先级
0000de  2302              MOVS     r3,#2
0000e0  221b              MOVS     r2,#0x1b
0000e2  2101              MOVS     r1,#1
0000e4  2000              MOVS     r0,#0
0000e6  f7fffffe          BL       MY_NVIC_Init
;;;148        
;;;149        os_clock_close("USART1");
0000ea  a04f              ADR      r0,|L1.552|
0000ec  f7fffffe          BL       os_clock_close
;;;150        
;;;151        return SUCCESS;
0000f0  2001              MOVS     r0,#1
;;;152        
;;;153        
;;;154    }
0000f2  bd70              POP      {r4-r6,pc}
;;;155    
                          ENDP

                  usart_register PROC
;;;63     #define USART2_NAME "USART2"
;;;64     os_err_t usart_register(u16 task_id)
0000f4  b510              PUSH     {r4,lr}
;;;65     {
0000f6  4604              MOV      r4,r0
;;;66         
;;;67         usart_dev=osmalloc(sizeof(usart_device));
0000f8  204c              MOVS     r0,#0x4c
0000fa  f7fffffe          BL       osmalloc
0000fe  4954              LDR      r1,|L1.592|
;;;68         
;;;69         
;;;70         usart_dev->pclk2=SYSCLK;
;;;71         usart_dev->bound=BOUND;
;;;72         
;;;73         usart_dev->os_device.type = OS_Device_Class_Char;
;;;74         
;;;75         usart_dev->os_device.device_id = OS_DEVICE_USART_ID;
;;;76         
;;;77         usart_dev->register_taskid = task_id;
;;;78         
;;;79         usart_dev->os_device.init  = uart2_init;
;;;80         
;;;81         usart_dev->os_device.open  = uart2_open;
;;;82         usart_dev->os_device.write = uart2_write;
;;;83         
;;;84         
;;;85         return os_device_register(&(usart_dev->os_device), USART2_NAME, OS_DEVICE_FLAG_INACTIVATED);
000100  2202              MOVS     r2,#2
000102  6008              STR      r0,[r1,#0]            ;70  ; usart_dev
000104  2130              MOVS     r1,#0x30              ;70
000106  6401              STR      r1,[r0,#0x40]         ;71
000108  21e1              MOVS     r1,#0xe1              ;71
00010a  0249              LSLS     r1,r1,#9              ;71
00010c  6441              STR      r1,[r0,#0x44]         ;73
00010e  2100              MOVS     r1,#0                 ;73
000110  7401              STRB     r1,[r0,#0x10]         ;73
000112  2101              MOVS     r1,#1                 ;75
000114  7581              STRB     r1,[r0,#0x16]         ;75
000116  8784              STRH     r4,[r0,#0x3c]         ;77
000118  494e              LDR      r1,|L1.596|
00011a  6201              STR      r1,[r0,#0x20]         ;81
00011c  494e              LDR      r1,|L1.600|
00011e  6241              STR      r1,[r0,#0x24]         ;82
000120  494e              LDR      r1,|L1.604|
000122  6301              STR      r1,[r0,#0x30]
000124  a14e              ADR      r1,|L1.608|
000126  f7fffffe          BL       os_device_register
;;;86     }
00012a  bd10              POP      {r4,pc}
;;;87     
                          ENDP

                  uart2_close PROC
;;;185     */
;;;186    os_err_t  uart2_close(os_device_t* dev, u16 oflag)
00012c  b510              PUSH     {r4,lr}
;;;187    {
;;;188        os_clock_close("AFIO");	
00012e  a03a              ADR      r0,|L1.536|
000130  f7fffffe          BL       os_clock_close
;;;189        os_clock_close("DMA1");	
000134  a03a              ADR      r0,|L1.544|
000136  f7fffffe          BL       os_clock_close
;;;190        os_clock_close("USART1");
00013a  a03b              ADR      r0,|L1.552|
00013c  f7fffffe          BL       os_clock_close
;;;191        os_clock_close("GPIOA");
000140  a03b              ADR      r0,|L1.560|
000142  f7fffffe          BL       os_clock_close
;;;192        os_clock_close("GPIOB");
000146  a03c              ADR      r0,|L1.568|
000148  f7fffffe          BL       os_clock_close
;;;193        return SUCCESS;		
00014c  2001              MOVS     r0,#1
;;;194        
;;;195    }
00014e  bd10              POP      {r4,pc}
;;;196    /*********************************************************************
                          ENDP

                  DMA1_Channel4_IRQHandler PROC
;;;296     */
;;;297    void DMA1_Channel4_IRQHandler()
000150  4830              LDR      r0,|L1.532|
;;;298    {
;;;299        
;;;300        USART2TX_DMA1_Channelx->CCR&=~(1<<0);         
000152  6841              LDR      r1,[r0,#4]
000154  0849              LSRS     r1,r1,#1
000156  0049              LSLS     r1,r1,#1
000158  6041              STR      r1,[r0,#4]
;;;301        if(DMA1->ISR&(1<<13))
00015a  482e              LDR      r0,|L1.532|
00015c  3840              SUBS     r0,r0,#0x40
00015e  6801              LDR      r1,[r0,#0]
;;;302        {
;;;303            
;;;304            
;;;305        }
;;;306        DMA1->IFCR|=3<<12;
000160  6841              LDR      r1,[r0,#4]
000162  2203              MOVS     r2,#3
000164  0312              LSLS     r2,r2,#12
000166  4311              ORRS     r1,r1,r2
000168  6041              STR      r1,[r0,#4]
;;;307    }
00016a  4770              BX       lr
;;;308    
                          ENDP

                  USART2_IRQHandler PROC
;;;319     */    
;;;320    void USART2_IRQHandler(void)
00016c  b570              PUSH     {r4-r6,lr}
;;;321    {
;;;322        
;;;323        volatile  u32 uart1_status;
;;;324        u16 data_length;
;;;325        usart_data usart_message_data;
;;;326        
;;;327        //if(USART1->SR&(1<<4))//idle interrupt
;;;328        {	 
;;;329            
;;;330            
;;;331            USART2RX_DMA1_Channelx->CCR&=(~0x01); //disable dma templaroly
00016e  4c29              LDR      r4,|L1.532|
000170  b094              SUB      sp,sp,#0x50           ;321
000172  69a0              LDR      r0,[r4,#0x18]
000174  0840              LSRS     r0,r0,#1
000176  0040              LSLS     r0,r0,#1
000178  61a0              STR      r0,[r4,#0x18]
;;;332            
;;;333            data_length=USART_TX_BUFFER_SIZE-USART2RX_DMA1_Channelx->CNDTR; //get the length of data
00017a  69e0              LDR      r0,[r4,#0x1c]
00017c  2540              MOVS     r5,#0x40
00017e  1a28              SUBS     r0,r5,r0
000180  b282              UXTH     r2,r0
;;;334            
;;;335            
;;;336            
;;;337            usart_message_data.length=data_length;
000182  4668              MOV      r0,sp
;;;338            osmemcpy(usart_message_data.data, USART2_RX_BUF , data_length);
000184  4922              LDR      r1,|L1.528|
000186  8102              STRH     r2,[r0,#8]            ;337
000188  3940              SUBS     r1,r1,#0x40
00018a  ae02              ADD      r6,sp,#8
00018c  300a              ADDS     r0,r0,#0xa
00018e  f7fffffe          BL       osmemcpy
;;;339            
;;;340            if(usart_dev==NULL)
000192  482f              LDR      r0,|L1.592|
000194  6801              LDR      r1,[r0,#0]  ; usart_dev
000196  2900              CMP      r1,#0
000198  d00c              BEQ      |L1.436|
;;;341            {
;;;342                goto end;  
;;;343            }
;;;344            
;;;345            usart_send_message(usart_dev->register_taskid , &usart_message_data ,usart_message_data.length+sizeof(usart_message_data.length));
00019a  4668              MOV      r0,sp
00019c  8900              LDRH     r0,[r0,#8]
00019e  9600              STR      r6,[sp,#0]
0001a0  1c80              ADDS     r0,r0,#2
0001a2  b280              UXTH     r0,r0
0001a4  9001              STR      r0,[sp,#4]
0001a6  8f88              LDRH     r0,[r1,#0x3c]
0001a8  2301              MOVS     r3,#1
0001aa  b2c0              UXTB     r0,r0
0001ac  2203              MOVS     r2,#3
0001ae  2104              MOVS     r1,#4
0001b0  f7fffffe          BL       send_message
                  |L1.436|
;;;346            
;;;347            
;;;348            
;;;349            // uart1_status=USART1->SR;  
;;;350            // uart1_status=USART1->DR;
;;;351            // uart1_status=USART1->SR;
;;;352            
;;;353            //	send_message(usart_dev->register_taskid,DEVICE_EVENT,USART_MSG , NULL,(void*)(usart_message_data), sizeof(usart_message_data));
;;;354    end:
;;;355            USART2RX_DMA1_Channelx->CNDTR=USART_RX_BUFFER_SIZE;
0001b4  61e5              STR      r5,[r4,#0x1c]
;;;356            //	  USART1RX_DMA1_Channelx->CPAR=(unsigned long)(&USART1->DR);
;;;357            USART2RX_DMA1_Channelx->CMAR=(unsigned long)(USART2_RX_BUF);	
0001b6  4816              LDR      r0,|L1.528|
0001b8  3840              SUBS     r0,r0,#0x40
0001ba  6260              STR      r0,[r4,#0x24]
;;;358            USART2RX_DMA1_Channelx->CCR|=1<<0; 	
0001bc  69a0              LDR      r0,[r4,#0x18]
0001be  2101              MOVS     r1,#1
0001c0  4308              ORRS     r0,r0,r1
0001c2  61a0              STR      r0,[r4,#0x18]
;;;359        }  	
;;;360        
;;;361        
;;;362        //	USART1->SR^=uart1_status;								 
;;;363    } 
0001c4  b014              ADD      sp,sp,#0x50
0001c6  bd70              POP      {r4-r6,pc}
;;;364    
                          ENDP

                  usart2_dma1_channel5_init PROC
;;;264     */
;;;265    static void usart2_dma1_channel5_init()
0001c8  4812              LDR      r0,|L1.532|
;;;266    {
;;;267        
;;;268        
;;;269        USART2RX_DMA1_Channelx->CCR=0;//reset
0001ca  2100              MOVS     r1,#0
0001cc  6181              STR      r1,[r0,#0x18]
;;;270        USART2RX_DMA1_Channelx->CCR|=0<<10;//Memory size 0:8bits,16-bits	 2 32bits
0001ce  6981              LDR      r1,[r0,#0x18]
0001d0  6181              STR      r1,[r0,#0x18]
;;;271        USART2RX_DMA1_Channelx->CCR|=0<<8;//Peripheral size 0:8bits,1:16-bits	 2 32bits
0001d2  6981              LDR      r1,[r0,#0x18]
0001d4  6181              STR      r1,[r0,#0x18]
;;;272        USART2RX_DMA1_Channelx->CCR|=1<<7;//Memory increment mode enabled
0001d6  6981              LDR      r1,[r0,#0x18]
0001d8  2280              MOVS     r2,#0x80
0001da  4311              ORRS     r1,r1,r2
0001dc  6181              STR      r1,[r0,#0x18]
;;;273        USART2RX_DMA1_Channelx->CCR|=2<<12;//
0001de  6981              LDR      r1,[r0,#0x18]
0001e0  0192              LSLS     r2,r2,#6
0001e2  4311              ORRS     r1,r1,r2
0001e4  6181              STR      r1,[r0,#0x18]
;;;274        USART2RX_DMA1_Channelx->CCR|=1<<5;//Memory Circular  mode enabled
0001e6  6981              LDR      r1,[r0,#0x18]
0001e8  2220              MOVS     r2,#0x20
0001ea  4311              ORRS     r1,r1,r2
0001ec  6181              STR      r1,[r0,#0x18]
;;;275        
;;;276        USART2RX_DMA1_Channelx->CCR&=~(1<<6);	//Peripheral increment mode disabled
0001ee  6982              LDR      r2,[r0,#0x18]
0001f0  2140              MOVS     r1,#0x40
0001f2  438a              BICS     r2,r2,r1
0001f4  6182              STR      r2,[r0,#0x18]
;;;277        USART2RX_DMA1_Channelx->CCR&=~(1<<4);//Read from peripheral
0001f6  6982              LDR      r2,[r0,#0x18]
0001f8  2310              MOVS     r3,#0x10
0001fa  439a              BICS     r2,r2,r3
0001fc  6182              STR      r2,[r0,#0x18]
;;;278        //USART1RX_DMA1_Channelx->CCR|=1<<1;//Transfer complete interrupt enable
;;;279        USART2RX_DMA1_Channelx->CNDTR=USART_TX_BUFFER_SIZE;//DMA channel x number of data register
0001fe  61c1              STR      r1,[r0,#0x1c]
;;;280        USART2RX_DMA1_Channelx->CMAR=(unsigned long)(USART2_RX_BUF);
000200  4903              LDR      r1,|L1.528|
000202  3940              SUBS     r1,r1,#0x40
000204  6241              STR      r1,[r0,#0x24]
;;;281        //	USART1RX_DMA1_Channelx->CPAR=(unsigned long)(&(USART1->DR));
;;;282        
;;;283        USART2RX_DMA1_Channelx->CCR|=1<<0;          //开启DMA传输
000206  6981              LDR      r1,[r0,#0x18]
000208  2201              MOVS     r2,#1
00020a  4311              ORRS     r1,r1,r2
00020c  6181              STR      r1,[r0,#0x18]
;;;284        
;;;285    }
00020e  4770              BX       lr
;;;286    
                          ENDP

                  |L1.528|
                          DCD      ||.bss||+0x40
                  |L1.532|
                          DCD      0x40020040
                  |L1.536|
000218  4146494f          DCB      "AFIO",0
00021c  00      
00021d  00                DCB      0
00021e  00                DCB      0
00021f  00                DCB      0
                  |L1.544|
000220  444d4131          DCB      "DMA1",0
000224  00      
000225  00                DCB      0
000226  00                DCB      0
000227  00                DCB      0
                  |L1.552|
000228  55534152          DCB      "USART1",0
00022c  543100  
00022f  00                DCB      0
                  |L1.560|
000230  4750494f          DCB      "GPIOA",0
000234  4100    
000236  00                DCB      0
000237  00                DCB      0
                  |L1.568|
000238  4750494f          DCB      "GPIOB",0
00023c  4200    
00023e  00                DCB      0
00023f  00                DCB      0
                  |L1.576|
                          DCD      0x000f4240
                  |L1.580|
                          DCD      0x40021000
                  |L1.584|
                          DCD      0x40013800
                  |L1.588|
                          DCD      0x0000200c
                  |L1.592|
                          DCD      ||.data||
                  |L1.596|
                          DCD      uart2_init
                  |L1.600|
                          DCD      uart2_open
                  |L1.604|
                          DCD      uart2_write
                  |L1.608|
000260  55534152          DCB      "USART2",0
000264  543200  
000267  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART2_RX_BUF
                          %        64
                  USART2_TX_BUF
                          %        64

                          AREA ||.data||, DATA, ALIGN=2

                  usart_dev
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\drivers\\stm32f051x\\char\\usart\\usart2.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_usart2_c_c5624bc8____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_usart2_c_c5624bc8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_usart2_c_c5624bc8____REVSH|
#line 144
|__asm___8_usart2_c_c5624bc8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
