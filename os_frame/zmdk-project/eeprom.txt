; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\eeprom.o --asm_dir=.\ --list_dir=.\ --depend=.\eeprom.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\eeprom.crf ..\drivers\stm32f051x\char\eeprom\eeprom.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  EE_FindValidPage PROC
;;;640      */
;;;641    static u16 EE_FindValidPage(u8 Operation)
000000  49ea              LDR      r1,|L1.940|
;;;642    {
;;;643        u16 PageStatus0 = 6, PageStatus1 = 6;
;;;644        
;;;645        /* Get Page0 actual status */
;;;646        PageStatus0 = (*(__IO u16*)PAGE0_BASE_ADDRESS);
000002  880a              LDRH     r2,[r1,#0]
;;;647        
;;;648        /* Get Page1 actual status */
;;;649        PageStatus1 = (*(__IO u16*)PAGE1_BASE_ADDRESS);
000004  49ea              LDR      r1,|L1.944|
000006  8809              LDRH     r1,[r1,#0]
;;;650        
;;;651        /* Write or read operation */
;;;652        switch (Operation)
000008  2800              CMP      r0,#0
00000a  d00d              BEQ      |L1.40|
00000c  2801              CMP      r0,#1
00000e  d113              BNE      |L1.56|
;;;653        {
;;;654        case WRITE_IN_VALID_PAGE:   /* ---- Write operation ---- */
;;;655            if (PageStatus1 == VALID_PAGE)
;;;656            {
;;;657                /* Page0 receiving data */
;;;658                if (PageStatus0 == RECEIVE_DATA)
000010  48e8              LDR      r0,|L1.948|
000012  2900              CMP      r1,#0                 ;655
000014  d002              BEQ      |L1.28|
;;;659                {
;;;660                    return PAGE0;         /* Page0 valid */
;;;661                }
;;;662                else
;;;663                {
;;;664                    return PAGE1;         /* Page1 valid */
;;;665                }
;;;666            }
;;;667            else if (PageStatus0 == VALID_PAGE)
000016  2a00              CMP      r2,#0
000018  d003              BEQ      |L1.34|
00001a  e009              B        |L1.48|
                  |L1.28|
00001c  4282              CMP      r2,r0                 ;658
00001e  d00b              BEQ      |L1.56|
000020  e008              B        |L1.52|
                  |L1.34|
;;;668            {
;;;669                /* Page1 receiving data */
;;;670                if (PageStatus1 == RECEIVE_DATA)
000022  4281              CMP      r1,r0
000024  d006              BEQ      |L1.52|
000026  e007              B        |L1.56|
                  |L1.40|
;;;671                {
;;;672                    return PAGE1;         /* Page1 valid */
;;;673                }
;;;674                else
;;;675                {
;;;676                    return PAGE0;         /* Page0 valid */
;;;677                }
;;;678            }
;;;679            else
;;;680            {
;;;681                return NO_VALID_PAGE;   /* No valid Page */
;;;682            }
;;;683            
;;;684        case READ_FROM_VALID_PAGE:  /* ---- Read operation ---- */
;;;685            if (PageStatus0 == VALID_PAGE)
000028  2a00              CMP      r2,#0
00002a  d005              BEQ      |L1.56|
;;;686            {
;;;687                return PAGE0;           /* Page0 valid */
;;;688            }
;;;689            else if (PageStatus1 == VALID_PAGE)
00002c  2900              CMP      r1,#0
00002e  d001              BEQ      |L1.52|
                  |L1.48|
;;;690            {
;;;691                return PAGE1;           /* Page1 valid */
;;;692            }
;;;693            else
;;;694            {
;;;695                return NO_VALID_PAGE ;  /* No valid Page */
000030  20ab              MOVS     r0,#0xab
;;;696            }
;;;697            
;;;698        default:
;;;699            return PAGE0;             /* Page0 valid */
;;;700        }
;;;701    }
000032  4770              BX       lr
                  |L1.52|
000034  2001              MOVS     r0,#1                 ;691
000036  4770              BX       lr
                  |L1.56|
000038  2000              MOVS     r0,#0                 ;699
00003a  4770              BX       lr
;;;702    
                          ENDP

                  EE_ReadVariable PROC
;;;519      */
;;;520    static u16 EE_ReadVariable(u16 VirtAddress, u16* Data)
00003c  b570              PUSH     {r4-r6,lr}
;;;521    {
00003e  4605              MOV      r5,r0
;;;522        u16 ValidPage = PAGE0;
;;;523        u16 AddressValue = 0x5555, ReadStatus = ERROR;
000040  2400              MOVS     r4,#0
000042  460e              MOV      r6,r1                 ;521
;;;524        u32 Address = 0x08010000, PageStartAddress = 0x08010000;
;;;525        
;;;526        /* Get active Page for read operation */
;;;527        ValidPage = EE_FindValidPage(READ_FROM_VALID_PAGE);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       EE_FindValidPage
;;;528        
;;;529        /* Check if there is no valid page */
;;;530        if (ValidPage == NO_VALID_PAGE)
00004a  28ab              CMP      r0,#0xab
00004c  d013              BEQ      |L1.118|
;;;531        {
;;;532            return  NO_VALID_PAGE;
;;;533        }
;;;534        
;;;535        /* Get the valid Page start Address */
;;;536        PageStartAddress = (u32)(EEPROM_START_ADDRESS + (u32)(ValidPage * PAGE_SIZE));
;;;537        
;;;538        /* Get the valid Page end Address */
;;;539        Address = (u32)((EEPROM_START_ADDRESS - 2) + (u32)((1 + ValidPage) * PAGE_SIZE));
00004e  4ad8              LDR      r2,|L1.944|
000050  0280              LSLS     r0,r0,#10             ;536
000052  49d6              LDR      r1,|L1.940|
000054  1e92              SUBS     r2,r2,#2
000056  1841              ADDS     r1,r0,r1              ;536
000058  1882              ADDS     r2,r0,r2
;;;540        
;;;541        /* Check each active page address starting from end */
;;;542        while (Address > (PageStartAddress + 2))
00005a  1c89              ADDS     r1,r1,#2
00005c  e008              B        |L1.112|
                  |L1.94|
;;;543        {
;;;544            /* Get the current location content to be compared with virtual address */
;;;545            AddressValue = (*(__IO u16*)Address);
00005e  8810              LDRH     r0,[r2,#0]
;;;546            
;;;547            /* Compare the read address with the virtual address */
;;;548            if (AddressValue == VirtAddress)
000060  42a8              CMP      r0,r5
000062  d104              BNE      |L1.110|
;;;549            {
;;;550                /* Get content of Address-2 which is variable value */
;;;551                *Data = (*(__IO u16*)(Address - 2));
000064  3a20              SUBS     r2,r2,#0x20
000066  8bd0              LDRH     r0,[r2,#0x1e]
000068  8030              STRH     r0,[r6,#0]
;;;552                
;;;553                /* In case variable value is read, reset ReadStatus flag */
;;;554                ReadStatus = SUCCESS;
00006a  2401              MOVS     r4,#1
;;;555                
;;;556                break;
00006c  e002              B        |L1.116|
                  |L1.110|
;;;557            }
;;;558            else
;;;559            {
;;;560                /* Next address location */
;;;561                Address = Address - 4;
00006e  1f12              SUBS     r2,r2,#4
                  |L1.112|
000070  428a              CMP      r2,r1                 ;542
000072  d8f4              BHI      |L1.94|
                  |L1.116|
;;;562            }
;;;563        }
;;;564        
;;;565        /* Return ReadStatus value: (0: variable exist, 1: variable doesn't exist) */
;;;566        return ReadStatus;
000074  4620              MOV      r0,r4
                  |L1.118|
;;;567    }
000076  bd70              POP      {r4-r6,pc}
;;;568    
                          ENDP

                  eeprom_read PROC
;;;253    
;;;254    os_size_t eeprom_read   (os_device_t* dev, os_off_t pos, void *buffer, os_size_t size)
000078  b5ff              PUSH     {r0-r7,lr}
;;;255    {
;;;256        
;;;257        u16 data_num = 0;
;;;258        u16 read_status = SUCCESS;
;;;259        u16 size_16bit   = size/sizeof(u16);
00007a  03d8              LSLS     r0,r3,#15
00007c  b099              SUB      sp,sp,#0x64           ;255
00007e  460f              MOV      r7,r1                 ;255
000080  0c05              LSRS     r5,r0,#16
000082  461e              MOV      r6,r3                 ;255
000084  2400              MOVS     r4,#0                 ;257
;;;260        u16 buffer_temp[50]={0};
000086  2164              MOVS     r1,#0x64
000088  4668              MOV      r0,sp
00008a  f7fffffe          BL       __aeabi_memclr4
;;;261        
;;;262        /*if size is a odd number then icn size_16bit*/
;;;263        if(size_16bit*sizeof(u16) < size)
00008e  0068              LSLS     r0,r5,#1
000090  42b0              CMP      r0,r6
000092  d201              BCS      |L1.152|
;;;264        {
;;;265            size_16bit++;
000094  1c6d              ADDS     r5,r5,#1
000096  b2ad              UXTH     r5,r5
                  |L1.152|
;;;266        }
;;;267        
;;;268        if(dev==NULL)
000098  9819              LDR      r0,[sp,#0x64]
00009a  2800              CMP      r0,#0
00009c  d015              BEQ      |L1.202|
00009e  e00c              B        |L1.186|
                  |L1.160|
;;;269        {
;;;270            return ERROR;
;;;271        }
;;;272        
;;;273        for(data_num =0 ; data_num < size_16bit ; data_num++)
;;;274        {
;;;275            /*read data form specific position*/
;;;276            read_status = EE_ReadVariable(pos + data_num , buffer_temp + data_num);
0000a0  0061              LSLS     r1,r4,#1
0000a2  4668              MOV      r0,sp
0000a4  1809              ADDS     r1,r1,r0
0000a6  1938              ADDS     r0,r7,r4
0000a8  b280              UXTH     r0,r0
0000aa  f7fffffe          BL       EE_ReadVariable
;;;277            
;;;278            /*if read error occurs return 0*/
;;;279            if(read_status == ERROR || read_status == NO_VALID_PAGE )
0000ae  2800              CMP      r0,#0
0000b0  d00d              BEQ      |L1.206|
0000b2  28ab              CMP      r0,#0xab
0000b4  d00b              BEQ      |L1.206|
0000b6  1c64              ADDS     r4,r4,#1              ;273
0000b8  b2a4              UXTH     r4,r4                 ;273
                  |L1.186|
0000ba  42ac              CMP      r4,r5                 ;273
0000bc  d3f0              BCC      |L1.160|
;;;280            {
;;;281    					
;;;282    #ifdef DEVICE_DEBUG
;;;283    					
;;;284    					  printf("EEPROM Read failed[%s]:%d",__FILE__, __LINE__ );
;;;285    #endif 
;;;286                return 0;
;;;287            }
;;;288        }	  
;;;289        
;;;290        /*copy data from kernel eara to user erea */
;;;291        osmemcpy((u8*)buffer , (u8*)buffer_temp ,size);
0000be  4632              MOV      r2,r6
0000c0  4669              MOV      r1,sp
0000c2  981b              LDR      r0,[sp,#0x6c]
0000c4  f7fffffe          BL       osmemcpy
;;;292        
;;;293    		/*greater or equal than size*/
;;;294        return data_num*sizeof(u16) ;	
0000c8  0060              LSLS     r0,r4,#1
                  |L1.202|
;;;295        
;;;296    }
0000ca  b01d              ADD      sp,sp,#0x74
0000cc  bdf0              POP      {r4-r7,pc}
                  |L1.206|
0000ce  22ff              MOVS     r2,#0xff              ;284
0000d0  321d              ADDS     r2,r2,#0x1d           ;284
0000d2  a1b9              ADR      r1,|L1.952|
0000d4  a0c3              ADR      r0,|L1.996|
0000d6  f7fffffe          BL       __2printf
0000da  2000              MOVS     r0,#0                 ;286
0000dc  e7f5              B        |L1.202|
;;;297    
                          ENDP

                  EE_VerifyPageFullWriteVariable PROC
;;;712      */
;;;713    static u16 EE_VerifyPageFullWriteVariable(u16 VirtAddress, u16 Data)
0000de  b570              PUSH     {r4-r6,lr}
;;;714    {
0000e0  4605              MOV      r5,r0
0000e2  460e              MOV      r6,r1
;;;715        FLASH_Status FlashStatus = FLASH_COMPLETE;
;;;716        u16 ValidPage = PAGE0;
;;;717        u32 Address = 0x08010000, PageEndAddress = 0x080107FF;
;;;718        
;;;719        /* Get valid Page for write operation */
;;;720        ValidPage = EE_FindValidPage(WRITE_IN_VALID_PAGE);
0000e4  2001              MOVS     r0,#1
0000e6  f7fffffe          BL       EE_FindValidPage
;;;721        
;;;722        /* Check if there is no valid page */
;;;723        if (ValidPage == NO_VALID_PAGE)
0000ea  28ab              CMP      r0,#0xab
0000ec  d00d              BEQ      |L1.266|
;;;724        {
;;;725            return  NO_VALID_PAGE;
;;;726        }
;;;727        
;;;728        /* Get the valid Page start Address */
;;;729        Address = (u32)(EEPROM_START_ADDRESS + (u32)(ValidPage * PAGE_SIZE));
0000ee  49af              LDR      r1,|L1.940|
0000f0  0280              LSLS     r0,r0,#10
0000f2  1844              ADDS     r4,r0,r1
;;;730        
;;;731        /* Get the valid Page end Address */
;;;732        PageEndAddress = (u32)((EEPROM_START_ADDRESS - 2) + (u32)((1 + ValidPage) * PAGE_SIZE));
0000f4  49ae              LDR      r1,|L1.944|
0000f6  1e89              SUBS     r1,r1,#2
0000f8  1841              ADDS     r1,r0,r1
;;;733        
;;;734        /* Check each active page address starting from begining */
;;;735        while (Address < PageEndAddress)
0000fa  e003              B        |L1.260|
                  |L1.252|
;;;736        {
;;;737            /* Verify if Address and Address+2 contents are 0xFFFFFFFF */
;;;738            if ((*(__IO u32*)Address) == 0xFFFFFFFF)
0000fc  6820              LDR      r0,[r4,#0]
0000fe  1c40              ADDS     r0,r0,#1
000100  d004              BEQ      |L1.268|
;;;739            {
;;;740                /* Set variable data */
;;;741                FlashStatus = FLASH_ProgramHalfWord(Address, Data);
;;;742                /* If program operation was failed, a Flash error code is returned */
;;;743                if (FlashStatus != FLASH_COMPLETE)
;;;744                {
;;;745                    return FlashStatus;
;;;746                }
;;;747                /* Set variable virtual address */
;;;748                FlashStatus = FLASH_ProgramHalfWord(Address + 2, VirtAddress);
;;;749                /* Return program operation status */
;;;750                return FlashStatus;
;;;751            }
;;;752            else
;;;753            {
;;;754                /* Next address location */
;;;755                Address = Address + 4;
000102  1d24              ADDS     r4,r4,#4
                  |L1.260|
000104  428c              CMP      r4,r1                 ;735
000106  d3f9              BCC      |L1.252|
;;;756            }
;;;757        }
;;;758        
;;;759        /* Return PAGE_FULL in case the valid page is full */
;;;760        return PAGE_FULL;
000108  2080              MOVS     r0,#0x80
                  |L1.266|
;;;761    }
00010a  bd70              POP      {r4-r6,pc}
                  |L1.268|
00010c  4631              MOV      r1,r6                 ;741
00010e  4620              MOV      r0,r4                 ;741
000110  f7fffffe          BL       FLASH_ProgramHalfWord
000114  2804              CMP      r0,#4                 ;743
000116  d1f8              BNE      |L1.266|
000118  4629              MOV      r1,r5                 ;748
00011a  1ca0              ADDS     r0,r4,#2              ;748
00011c  f7fffffe          BL       FLASH_ProgramHalfWord
000120  bd70              POP      {r4-r6,pc}
;;;762    
                          ENDP

                  eeprom_write PROC
;;;195     */
;;;196    static  os_size_t  eeprom_write(os_device_t* dev, os_off_t pos, const void *buffer, os_size_t size)
000122  b5ff              PUSH     {r0-r7,lr}
;;;197    {
;;;198        
;;;199        u16 data_num     = 0;
;;;200        u16 write_status = 0;
;;;201        u16 size_16bit   = size/sizeof(u16);
000124  03d8              LSLS     r0,r3,#15
000126  b09b              SUB      sp,sp,#0x6c           ;197
000128  460e              MOV      r6,r1                 ;197
00012a  0c05              LSRS     r5,r0,#16
00012c  461f              MOV      r7,r3                 ;197
00012e  2400              MOVS     r4,#0                 ;199
;;;202        u16 buffer_temp[50]={0};
000130  2164              MOVS     r1,#0x64
000132  4668              MOV      r0,sp
000134  f7fffffe          BL       __aeabi_memclr4
;;;203        
;;;204        /*copy data from user erea to kernel eara*/
;;;205        osmemcpy((u8*)buffer_temp , (u8*)buffer ,size);
000138  463a              MOV      r2,r7
00013a  4668              MOV      r0,sp
00013c  991d              LDR      r1,[sp,#0x74]
00013e  f7fffffe          BL       osmemcpy
;;;206        
;;;207        /*if size is a odd number then icn size_16bit*/
;;;208        if(size_16bit*sizeof(u16) < size)
000142  0068              LSLS     r0,r5,#1
000144  42b8              CMP      r0,r7
000146  d201              BCS      |L1.332|
;;;209        {
;;;210            size_16bit++;
000148  1c6d              ADDS     r5,r5,#1
00014a  b2ad              UXTH     r5,r5
                  |L1.332|
;;;211        }
;;;212        
;;;213        if(pos>=size || buffer==NULL)
00014c  42be              CMP      r6,r7
00014e  d202              BCS      |L1.342|
000150  981d              LDR      r0,[sp,#0x74]
000152  2800              CMP      r0,#0
000154  d11a              BNE      |L1.396|
                  |L1.342|
;;;214        {
;;;215            return  NULL;
000156  2000              MOVS     r0,#0
                  |L1.344|
;;;216        }else
;;;217        {
;;;218            for ( ; data_num < size_16bit ; data_num++ )
;;;219            {
;;;220                /*flush buffer in to eeprom in position in accodance with pos*/
;;;221                write_status = EE_WriteVariable( pos + data_num , ((buffer_temp)[data_num]));
;;;222                
;;;223                /*write error happens return 0*/
;;;224                if(write_status != FLASH_COMPLETE)
;;;225                {
;;;226    #ifdef DEVICE_DEBUG
;;;227                    printf("EEPROM write failed");  
;;;228    #endif
;;;229                    return 0;
;;;230                }
;;;231                
;;;232                
;;;233            }
;;;234            
;;;235            
;;;236        }
;;;237        
;;;238        /*read successfully*/	
;;;239        return (data_num+1)*sizeof(u16);
;;;240    }
000158  b01f              ADD      sp,sp,#0x7c
00015a  bdf0              POP      {r4-r7,pc}
                  |L1.348|
00015c  1930              ADDS     r0,r6,r4              ;221
00015e  b280              UXTH     r0,r0                 ;221
000160  9019              STR      r0,[sp,#0x64]         ;221
000162  0061              LSLS     r1,r4,#1              ;221
000164  4668              MOV      r0,sp                 ;221
000166  5a47              LDRH     r7,[r0,r1]            ;221
000168  9819              LDR      r0,[sp,#0x64]         ;221
00016a  4639              MOV      r1,r7                 ;221
00016c  f7fffffe          BL       EE_VerifyPageFullWriteVariable
000170  2880              CMP      r0,#0x80              ;221
000172  d103              BNE      |L1.380|
000174  4639              MOV      r1,r7                 ;221
000176  9819              LDR      r0,[sp,#0x64]         ;221
000178  f7fffffe          BL       EE_PageTransfer
                  |L1.380|
00017c  2804              CMP      r0,#4                 ;224
00017e  d003              BEQ      |L1.392|
000180  a09f              ADR      r0,|L1.1024|
000182  f7fffffe          BL       __2printf
000186  e7e6              B        |L1.342|
                  |L1.392|
000188  1c64              ADDS     r4,r4,#1              ;218
00018a  b2a4              UXTH     r4,r4                 ;218
                  |L1.396|
00018c  42ac              CMP      r4,r5                 ;218
00018e  d3e5              BCC      |L1.348|
000190  0060              LSLS     r0,r4,#1              ;239
000192  1c80              ADDS     r0,r0,#2              ;239
000194  e7e0              B        |L1.344|
;;;241    
                          ENDP

                  eeprom_close PROC
;;;171     */
;;;172    static os_err_t  eeprom_close(os_device_t* dev)
000196  b510              PUSH     {r4,lr}
;;;173    {
;;;174        
;;;175        /* Unlock the Flash Program Erase controller */
;;;176        FLASH_Lock();
000198  f7fffffe          BL       FLASH_Lock
;;;177        
;;;178        return SUCCESS;		
00019c  2001              MOVS     r0,#1
;;;179        
;;;180    }
00019e  bd10              POP      {r4,pc}
;;;181    
                          ENDP

                  eeprom_open PROC
;;;152     */
;;;153    static os_err_t  eeprom_open(os_device_t* dev, u16 oflag)
0001a0  b510              PUSH     {r4,lr}
;;;154    {
;;;155        
;;;156        /* Unlock the Flash Program Erase controller */
;;;157        FLASH_Unlock();
0001a2  f7fffffe          BL       FLASH_Unlock
;;;158        
;;;159        return SUCCESS;	
0001a6  2001              MOVS     r0,#1
;;;160    }
0001a8  bd10              POP      {r4,pc}
;;;161    
                          ENDP

                  EE_Init PROC
;;;304      */
;;;305    static u16 EE_Init(void)
0001aa  b5f8              PUSH     {r3-r7,lr}
;;;306    {
;;;307        u16 PageStatus0 = 6, PageStatus1 = 6;
;;;308        u16 VarIdx = 0;
;;;309        u16 EepromStatus = 0, ReadStatus = 0;
;;;310        int16_t x = -1;
;;;311        u16  FlashStatus;
;;;312        
;;;313        /* Get Page0 status */
;;;314        PageStatus0 = (*(__IO u16*)PAGE0_BASE_ADDRESS);
0001ac  487f              LDR      r0,|L1.940|
0001ae  2400              MOVS     r4,#0                 ;308
0001b0  8801              LDRH     r1,[r0,#0]
0001b2  1e65              SUBS     r5,r4,#1              ;310
;;;315        /* Get Page1 status */
;;;316        PageStatus1 = (*(__IO u16*)PAGE1_BASE_ADDRESS);
0001b4  487e              LDR      r0,|L1.944|
0001b6  8800              LDRH     r0,[r0,#0]
;;;317        
;;;318        /* Check for invalid header states and repair if necessary */
;;;319        switch (PageStatus0)
;;;320        {
;;;321        case ERASED:
;;;322            if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
;;;323            {
;;;324                /* Erase Page0 */
;;;325                FlashStatus = FLASH_ErasePage(PAGE0_BASE_ADDRESS);
;;;326                /* If erase operation was failed, a Flash error code is returned */
;;;327                if (FlashStatus != FLASH_COMPLETE)
;;;328                {
;;;329                    return FlashStatus;
;;;330                }
;;;331            }
;;;332            else if (PageStatus1 == RECEIVE_DATA) /* Page0 erased, Page1 receive */
;;;333            {
;;;334                /* Erase Page0 */
;;;335                FlashStatus = FLASH_ErasePage(PAGE0_BASE_ADDRESS);
;;;336                /* If erase operation was failed, a Flash error code is returned */
;;;337                if (FlashStatus != FLASH_COMPLETE)
;;;338                {
;;;339                    return FlashStatus;
;;;340                }
;;;341                /* Mark Page1 as valid */
;;;342                FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
;;;343                /* If program operation was failed, a Flash error code is returned */
;;;344                if (FlashStatus != FLASH_COMPLETE)
;;;345                {
;;;346                    return FlashStatus;
;;;347                }
;;;348            }
;;;349            else /* First EEPROM access (Page0&1 are erased) or invalid state -> format EEPROM */
;;;350            {
;;;351                /* Erase both Page0 and Page1 and set Page0 as valid page */
;;;352                FlashStatus = EE_Format();
;;;353                /* If erase/program operation was failed, a Flash error code is returned */
;;;354                if (FlashStatus != FLASH_COMPLETE)
;;;355                {
;;;356                    return FlashStatus;
;;;357                }
;;;358            }
;;;359            break;
;;;360            
;;;361        case RECEIVE_DATA:
;;;362            if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
;;;363            {
;;;364                /* Transfer data from Page1 to Page0 */
;;;365                for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
;;;366                {
;;;367                    if (( *(__IO u16*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
;;;368                    {
;;;369                        x = VarIdx;
;;;370                    }
;;;371                    if (VarIdx != x)
;;;372                    {
;;;373                        /* Read the last variables' updates */
;;;374                        ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
;;;375                        /* In case variable corresponding to the virtual address was found */
;;;376                        if (ReadStatus != 0x1)
;;;377                        {
;;;378                            /* Transfer the variable to the Page0 */
;;;379                            EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
;;;380                            /* If program operation was failed, a Flash error code is returned */
;;;381                            if (EepromStatus != FLASH_COMPLETE)
;;;382                            {
;;;383                                return EepromStatus;
;;;384                            }
;;;385                        }
;;;386                    }
;;;387                }
;;;388                /* Mark Page0 as valid */
;;;389                FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
;;;390                /* If program operation was failed, a Flash error code is returned */
;;;391                if (FlashStatus != FLASH_COMPLETE)
;;;392                {
;;;393                    return FlashStatus;
;;;394                }
;;;395                /* Erase Page1 */
;;;396                FlashStatus = FLASH_ErasePage(PAGE1_BASE_ADDRESS);
;;;397                /* If erase operation was failed, a Flash error code is returned */
;;;398                if (FlashStatus != FLASH_COMPLETE)
;;;399                {
;;;400                    return FlashStatus;
;;;401                }
;;;402            }
;;;403            else if (PageStatus1 == ERASED) /* Page0 receive, Page1 erased */
0001b8  0c2b              LSRS     r3,r5,#16
0001ba  4e96              LDR      r6,|L1.1044|
0001bc  2900              CMP      r1,#0                 ;319
0001be  d04a              BEQ      |L1.598|
0001c0  4f7c              LDR      r7,|L1.948|
0001c2  427f              RSBS     r7,r7,#0              ;319
0001c4  19c9              ADDS     r1,r1,r7              ;319
0001c6  d012              BEQ      |L1.494|
0001c8  4a93              LDR      r2,|L1.1048|
0001ca  1889              ADDS     r1,r1,r2              ;319
0001cc  d10c              BNE      |L1.488|
0001ce  2800              CMP      r0,#0                 ;322
0001d0  d068              BEQ      |L1.676|
0001d2  4279              RSBS     r1,r7,#0              ;332
0001d4  4288              CMP      r0,r1                 ;332
0001d6  d107              BNE      |L1.488|
0001d8  4874              LDR      r0,|L1.940|
0001da  f7fffffe          BL       FLASH_ErasePage
0001de  2804              CMP      r0,#4                 ;337
0001e0  d138              BNE      |L1.596|
0001e2  2100              MOVS     r1,#0                 ;342
0001e4  4872              LDR      r0,|L1.944|
0001e6  e00d              B        |L1.516|
                  |L1.488|
0001e8  f7fffffe          BL       EE_Format
0001ec  e031              B        |L1.594|
                  |L1.494|
0001ee  2800              CMP      r0,#0                 ;362
0001f0  d00b              BEQ      |L1.522|
0001f2  4298              CMP      r0,r3
0001f4  d1f8              BNE      |L1.488|
;;;404            {
;;;405                /* Erase Page1 */
;;;406                FlashStatus = FLASH_ErasePage(PAGE1_BASE_ADDRESS);
0001f6  486e              LDR      r0,|L1.944|
0001f8  f7fffffe          BL       FLASH_ErasePage
;;;407                /* If erase operation was failed, a Flash error code is returned */
;;;408                if (FlashStatus != FLASH_COMPLETE)
0001fc  2804              CMP      r0,#4
0001fe  d129              BNE      |L1.596|
;;;409                {
;;;410                    return FlashStatus;
;;;411                }
;;;412                /* Mark Page0 as valid */
;;;413                FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
000200  2100              MOVS     r1,#0
000202  486a              LDR      r0,|L1.940|
                  |L1.516|
000204  f7fffffe          BL       FLASH_ProgramHalfWord
000208  e023              B        |L1.594|
                  |L1.522|
00020a  4868              LDR      r0,|L1.940|
00020c  88c1              LDRH     r1,[r0,#6]            ;367
00020e  0067              LSLS     r7,r4,#1              ;367
000210  5bf0              LDRH     r0,[r6,r7]            ;367
000212  4281              CMP      r1,r0                 ;367
000214  d100              BNE      |L1.536|
000216  b225              SXTH     r5,r4                 ;369
                  |L1.536|
000218  42ac              CMP      r4,r5                 ;371
00021a  d00d              BEQ      |L1.568|
00021c  497d              LDR      r1,|L1.1044|
00021e  3908              SUBS     r1,r1,#8              ;374
000220  f7fffffe          BL       EE_ReadVariable
000224  2801              CMP      r0,#1                 ;376
000226  d007              BEQ      |L1.568|
000228  497a              LDR      r1,|L1.1044|
00022a  5bf0              LDRH     r0,[r6,r7]            ;379
00022c  3908              SUBS     r1,r1,#8              ;379
00022e  8809              LDRH     r1,[r1,#0]            ;379  ; DataVar
000230  f7fffffe          BL       EE_VerifyPageFullWriteVariable
000234  2804              CMP      r0,#4                 ;381
000236  d10d              BNE      |L1.596|
                  |L1.568|
000238  1c64              ADDS     r4,r4,#1              ;365
00023a  b2a4              UXTH     r4,r4                 ;365
00023c  2c03              CMP      r4,#3                 ;365
00023e  d3e4              BCC      |L1.522|
000240  2100              MOVS     r1,#0                 ;389
000242  485a              LDR      r0,|L1.940|
000244  f7fffffe          BL       FLASH_ProgramHalfWord
000248  2804              CMP      r0,#4                 ;391
00024a  d103              BNE      |L1.596|
00024c  e007              B        |L1.606|
                  |L1.590|
00024e  f7fffffe          BL       FLASH_ErasePage
                  |L1.594|
;;;414                /* If program operation was failed, a Flash error code is returned */
;;;415                if (FlashStatus != FLASH_COMPLETE)
;;;416                {
;;;417                    return FlashStatus;
;;;418                }
;;;419            }
;;;420            else /* Invalid state -> format eeprom */
;;;421            {
;;;422                /* Erase both Page0 and Page1 and set Page0 as valid page */
;;;423                FlashStatus = EE_Format();
;;;424                /* If erase/program operation was failed, a Flash error code is returned */
;;;425                if (FlashStatus != FLASH_COMPLETE)
;;;426                {
;;;427                    return FlashStatus;
;;;428                }
;;;429            }
;;;430            break;
;;;431            
;;;432        case VALID_PAGE:
;;;433            if (PageStatus1 == VALID_PAGE) /* Invalid state -> format eeprom */
;;;434            {
;;;435                /* Erase both Page0 and Page1 and set Page0 as valid page */
;;;436                FlashStatus = EE_Format();
;;;437                /* If erase/program operation was failed, a Flash error code is returned */
;;;438                if (FlashStatus != FLASH_COMPLETE)
;;;439                {
;;;440                    return FlashStatus;
;;;441                }
;;;442            }
;;;443            else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
;;;444            {
;;;445                /* Erase Page1 */
;;;446                FlashStatus = FLASH_ErasePage(PAGE1_BASE_ADDRESS);
;;;447                /* If erase operation was failed, a Flash error code is returned */
;;;448                if (FlashStatus != FLASH_COMPLETE)
;;;449                {
;;;450                    return FlashStatus;
;;;451                }
;;;452            }
;;;453            else /* Page0 valid, Page1 receive */
;;;454            {
;;;455                /* Transfer data from Page0 to Page1 */
;;;456                for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
;;;457                {
;;;458                    if ((*(__IO u16*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
;;;459                    {
;;;460                        x = VarIdx;
;;;461                    }
;;;462                    if (VarIdx != x)
;;;463                    {
;;;464                        /* Read the last variables' updates */
;;;465                        ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
;;;466                        /* In case variable corresponding to the virtual address was found */
;;;467                        if (ReadStatus != 0x1)
;;;468                        {
;;;469                            /* Transfer the variable to the Page1 */
;;;470                            EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
;;;471                            /* If program operation was failed, a Flash error code is returned */
;;;472                            if (EepromStatus != FLASH_COMPLETE)
;;;473                            {
;;;474                                return EepromStatus;
;;;475                            }
;;;476                        }
;;;477                    }
;;;478                }
;;;479                /* Mark Page1 as valid */
;;;480                FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
;;;481                /* If program operation was failed, a Flash error code is returned */
;;;482                if (FlashStatus != FLASH_COMPLETE)
;;;483                {
;;;484                    return FlashStatus;
;;;485                }
;;;486                /* Erase Page0 */
;;;487                FlashStatus = FLASH_ErasePage(PAGE0_BASE_ADDRESS);
;;;488                /* If erase operation was failed, a Flash error code is returned */
;;;489                if (FlashStatus != FLASH_COMPLETE)
;;;490                {
;;;491                    return FlashStatus;
;;;492                }
;;;493            }
;;;494            break;
;;;495            
;;;496        default:  /* Any other state -> format eeprom */
;;;497            /* Erase both Page0 and Page1 and set Page0 as valid page */
;;;498            FlashStatus = EE_Format();
;;;499            /* If erase/program operation was failed, a Flash error code is returned */
;;;500            if (FlashStatus != FLASH_COMPLETE)
000252  2804              CMP      r0,#4
                  |L1.596|
;;;501            {
;;;502                return FlashStatus;
;;;503            }
;;;504            break;
;;;505        }
;;;506        
;;;507        return FLASH_COMPLETE;
;;;508    }
000254  bdf8              POP      {r3-r7,pc}
                  |L1.598|
000256  2800              CMP      r0,#0                 ;433
000258  d0c6              BEQ      |L1.488|
00025a  4298              CMP      r0,r3                 ;443
00025c  d101              BNE      |L1.610|
                  |L1.606|
00025e  4854              LDR      r0,|L1.944|
000260  e7f5              B        |L1.590|
                  |L1.610|
000262  4853              LDR      r0,|L1.944|
000264  88c1              LDRH     r1,[r0,#6]            ;458
000266  0067              LSLS     r7,r4,#1              ;458
000268  5bf0              LDRH     r0,[r6,r7]            ;458
00026a  4281              CMP      r1,r0                 ;458
00026c  d100              BNE      |L1.624|
00026e  b225              SXTH     r5,r4                 ;460
                  |L1.624|
000270  42ac              CMP      r4,r5                 ;462
000272  d00d              BEQ      |L1.656|
000274  4967              LDR      r1,|L1.1044|
000276  3908              SUBS     r1,r1,#8              ;465
000278  f7fffffe          BL       EE_ReadVariable
00027c  2801              CMP      r0,#1                 ;467
00027e  d007              BEQ      |L1.656|
000280  4964              LDR      r1,|L1.1044|
000282  5bf0              LDRH     r0,[r6,r7]            ;470
000284  3908              SUBS     r1,r1,#8              ;470
000286  8809              LDRH     r1,[r1,#0]            ;470  ; DataVar
000288  f7fffffe          BL       EE_VerifyPageFullWriteVariable
00028c  2804              CMP      r0,#4                 ;472
00028e  d1e1              BNE      |L1.596|
                  |L1.656|
000290  1c64              ADDS     r4,r4,#1              ;456
000292  b2a4              UXTH     r4,r4                 ;456
000294  2c03              CMP      r4,#3                 ;456
000296  d3e4              BCC      |L1.610|
000298  2100              MOVS     r1,#0                 ;480
00029a  4845              LDR      r0,|L1.944|
00029c  f7fffffe          BL       FLASH_ProgramHalfWord
0002a0  2804              CMP      r0,#4                 ;482
0002a2  d1d7              BNE      |L1.596|
                  |L1.676|
0002a4  4841              LDR      r0,|L1.940|
0002a6  e7d2              B        |L1.590|
;;;509    
                          ENDP

                  eeprom_init PROC
;;;131     */
;;;132    static  os_err_t   eeprom_init   (os_device_t* dev)
0002a8  b510              PUSH     {r4,lr}
;;;133    {
;;;134        /* Unlock the Flash Program Erase controller */
;;;135        FLASH_Unlock();
0002aa  f7fffffe          BL       FLASH_Unlock
;;;136        /* EEPROM Init */
;;;137        EE_Init();
0002ae  f7fffffe          BL       EE_Init
;;;138        
;;;139        return SUCCESS;
0002b2  2001              MOVS     r0,#1
;;;140    }
0002b4  bd10              POP      {r4,pc}
;;;141    
                          ENDP

                  eeprom_register PROC
;;;72     
;;;73     os_err_t eeprom_register(u16 task_id)
0002b6  b510              PUSH     {r4,lr}
;;;74     {
0002b8  4604              MOV      r4,r0
;;;75         /*allocate specific amount memory*/
;;;76         eeprom_simulation=osmalloc(sizeof(usart_device));
0002ba  204c              MOVS     r0,#0x4c
0002bc  f7fffffe          BL       osmalloc
0002c0  4954              LDR      r1,|L1.1044|
0002c2  3908              SUBS     r1,r1,#8
;;;77         /*if memory alloated failed */
;;;78         if(eeprom_simulation == NULL)
0002c4  6048              STR      r0,[r1,#4]  ; eeprom_simulation
0002c6  2800              CMP      r0,#0
0002c8  d018              BEQ      |L1.764|
;;;79         {
;;;80             
;;;81     #ifdef DEVICE_DEBUG 
;;;82             printf("eeprom allocated failed");
;;;83     #endif
;;;84             return ERROR;
;;;85             
;;;86         }
;;;87         
;;;88         eeprom_simulation->pclk2=SYSCLK;
0002ca  2130              MOVS     r1,#0x30
;;;89         
;;;90         eeprom_simulation->bound=BOUND;
0002cc  6401              STR      r1,[r0,#0x40]
0002ce  21e1              MOVS     r1,#0xe1
0002d0  0249              LSLS     r1,r1,#9
;;;91         
;;;92         /*initilize device type*/
;;;93         eeprom_simulation->os_device.type = OS_Device_Class_Char;
0002d2  6441              STR      r1,[r0,#0x44]
0002d4  2100              MOVS     r1,#0
0002d6  7401              STRB     r1,[r0,#0x10]
;;;94         
;;;95         /*registor device id*/
;;;96         eeprom_simulation->os_device.device_id = OS_DEVICE_USART_ID;
0002d8  2101              MOVS     r1,#1
0002da  7581              STRB     r1,[r0,#0x16]
;;;97         
;;;98         /*registor task id*/
;;;99         eeprom_simulation->register_taskid = task_id;
0002dc  8784              STRH     r4,[r0,#0x3c]
;;;100        
;;;101        /*initiate the function poniter to the device structor*/
;;;102        eeprom_simulation->os_device.init  = eeprom_init;
0002de  494f              LDR      r1,|L1.1052|
;;;103        
;;;104        /*open function poniter initialized*/
;;;105        eeprom_simulation->os_device.open  = eeprom_open;
0002e0  6201              STR      r1,[r0,#0x20]
0002e2  494f              LDR      r1,|L1.1056|
;;;106        
;;;107        /*close function poniter initialized*/
;;;108        eeprom_simulation->os_device.close  = eeprom_close;
0002e4  6241              STR      r1,[r0,#0x24]
0002e6  494f              LDR      r1,|L1.1060|
;;;109        
;;;110        /*write function poniter initialized*/
;;;111        eeprom_simulation->os_device.write = eeprom_write;
0002e8  6281              STR      r1,[r0,#0x28]
0002ea  494f              LDR      r1,|L1.1064|
;;;112        
;;;113        /*read function poniter initialized*/
;;;114        eeprom_simulation->os_device.read  = eeprom_read; 
0002ec  6301              STR      r1,[r0,#0x30]
0002ee  494f              LDR      r1,|L1.1068|
;;;115        
;;;116        /*return registor status*/
;;;117        return os_device_register(&(eeprom_simulation->os_device), EEPROM_NAME, OS_DEVICE_FLAG_INACTIVATED);
0002f0  62c1              STR      r1,[r0,#0x2c]
0002f2  2202              MOVS     r2,#2
0002f4  a14e              ADR      r1,|L1.1072|
0002f6  f7fffffe          BL       os_device_register
;;;118    }
0002fa  bd10              POP      {r4,pc}
                  |L1.764|
0002fc  a04e              ADR      r0,|L1.1080|
0002fe  f7fffffe          BL       __2printf
000302  2000              MOVS     r0,#0                 ;84
000304  bd10              POP      {r4,pc}
;;;119    
                          ENDP

                  EE_PageTransfer PROC
;;;773      */
;;;774    static u16 EE_PageTransfer(u16 VirtAddress, u16 Data)
000306  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;775    {
;;;776        FLASH_Status FlashStatus = FLASH_COMPLETE;
;;;777        u32 NewPageAddress = 0x080103FF, OldPageAddress = 0x08010000;
;;;778        u16 ValidPage = PAGE0, VarIdx = 0;
000308  2400              MOVS     r4,#0
00030a  b081              SUB      sp,sp,#4              ;775
00030c  460d              MOV      r5,r1                 ;775
;;;779        u16 EepromStatus = 0, ReadStatus = 0;
;;;780        
;;;781        /* Get active Page for read operation */
;;;782        ValidPage = EE_FindValidPage(READ_FROM_VALID_PAGE);
00030e  4620              MOV      r0,r4
000310  f7fffffe          BL       EE_FindValidPage
;;;783        
;;;784        if (ValidPage == PAGE1)       /* Page1 valid */
;;;785        {
;;;786            /* New page address where variable will be moved to */
;;;787            NewPageAddress = PAGE0_BASE_ADDRESS;
000314  4f25              LDR      r7,|L1.940|
;;;788            
;;;789            /* Old page address where variable will be taken from */
;;;790            OldPageAddress = PAGE1_BASE_ADDRESS;
000316  4926              LDR      r1,|L1.944|
000318  2801              CMP      r0,#1                 ;784
00031a  d003              BEQ      |L1.804|
;;;791        }
;;;792        else if (ValidPage == PAGE0)  /* Page0 valid */
00031c  2800              CMP      r0,#0
00031e  d004              BEQ      |L1.810|
;;;793        {
;;;794            /* New page address where variable will be moved to */
;;;795            NewPageAddress = PAGE1_BASE_ADDRESS;
;;;796            
;;;797            /* Old page address where variable will be taken from */
;;;798            OldPageAddress = PAGE0_BASE_ADDRESS;
;;;799        }
;;;800        else
;;;801        {
;;;802            return NO_VALID_PAGE;       /* No valid Page */
000320  20ab              MOVS     r0,#0xab
                  |L1.802|
;;;803        }
;;;804        
;;;805        /* Set the new Page status to RECEIVE_DATA status */
;;;806        FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, RECEIVE_DATA);
;;;807        /* If program operation was failed, a Flash error code is returned */
;;;808        if (FlashStatus != FLASH_COMPLETE)
;;;809        {
;;;810            return FlashStatus;
;;;811        }
;;;812        
;;;813        /* Write the variable passed as parameter in the new active page */
;;;814        EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
;;;815        /* If program operation was failed, a Flash error code is returned */
;;;816        if (EepromStatus != FLASH_COMPLETE)
;;;817        {
;;;818            return EepromStatus;
;;;819        }
;;;820        
;;;821        /* Transfer process: transfer variables from old to the new active page */
;;;822        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
;;;823        {
;;;824            if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
;;;825            {
;;;826                /* Read the other last variable updates */
;;;827                ReadStatus = EE_ReadVariable(VirtAddVarTab[VarIdx], &DataVar);
;;;828                /* In case variable corresponding to the virtual address was found */
;;;829                if (ReadStatus != 0x1)
;;;830                {
;;;831                    /* Transfer the variable to the new active page */
;;;832                    EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
;;;833                    /* If program operation was failed, a Flash error code is returned */
;;;834                    if (EepromStatus != FLASH_COMPLETE)
;;;835                    {
;;;836                        return EepromStatus;
;;;837                    }
;;;838                }
;;;839            }
;;;840        }
;;;841        
;;;842        /* Erase the old Page: Set old Page status to ERASED status */
;;;843        FlashStatus = FLASH_ErasePage(OldPageAddress);
;;;844        /* If erase operation was failed, a Flash error code is returned */
;;;845        if (FlashStatus != FLASH_COMPLETE)
;;;846        {
;;;847            return FlashStatus;
;;;848        }
;;;849        
;;;850        /* Set new Page status to VALID_PAGE status */
;;;851        FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, VALID_PAGE);
;;;852        /* If program operation was failed, a Flash error code is returned */
;;;853        if (FlashStatus != FLASH_COMPLETE)
;;;854        {
;;;855            return FlashStatus;
;;;856        }
;;;857        
;;;858        /* Return last operation flash status */
;;;859        return FlashStatus;
;;;860    }
000322  bdfe              POP      {r1-r7,pc}
                  |L1.804|
000324  9700              STR      r7,[sp,#0]            ;790
000326  460f              MOV      r7,r1                 ;790
000328  e000              B        |L1.812|
                  |L1.810|
00032a  9100              STR      r1,[sp,#0]            ;795
                  |L1.812|
00032c  4921              LDR      r1,|L1.948|
00032e  9800              LDR      r0,[sp,#0]            ;806
000330  f7fffffe          BL       FLASH_ProgramHalfWord
000334  2804              CMP      r0,#4                 ;808
000336  d1f4              BNE      |L1.802|
000338  4629              MOV      r1,r5                 ;814
00033a  9801              LDR      r0,[sp,#4]            ;814
00033c  f7fffffe          BL       EE_VerifyPageFullWriteVariable
000340  2804              CMP      r0,#4                 ;816
000342  d1ee              BNE      |L1.802|
000344  4e33              LDR      r6,|L1.1044|
                  |L1.838|
000346  0065              LSLS     r5,r4,#1              ;824
000348  5b70              LDRH     r0,[r6,r5]            ;824
00034a  9901              LDR      r1,[sp,#4]            ;824
00034c  4288              CMP      r0,r1                 ;824
00034e  d00d              BEQ      |L1.876|
000350  4930              LDR      r1,|L1.1044|
000352  3908              SUBS     r1,r1,#8              ;827
000354  f7fffffe          BL       EE_ReadVariable
000358  2801              CMP      r0,#1                 ;829
00035a  d007              BEQ      |L1.876|
00035c  492d              LDR      r1,|L1.1044|
00035e  5b70              LDRH     r0,[r6,r5]            ;832
000360  3908              SUBS     r1,r1,#8              ;832
000362  8809              LDRH     r1,[r1,#0]            ;832  ; DataVar
000364  f7fffffe          BL       EE_VerifyPageFullWriteVariable
000368  2804              CMP      r0,#4                 ;834
00036a  d1da              BNE      |L1.802|
                  |L1.876|
00036c  1c64              ADDS     r4,r4,#1              ;822
00036e  b2a4              UXTH     r4,r4                 ;822
000370  2c03              CMP      r4,#3                 ;822
000372  d3e8              BCC      |L1.838|
000374  4638              MOV      r0,r7                 ;843
000376  f7fffffe          BL       FLASH_ErasePage
00037a  2804              CMP      r0,#4                 ;845
00037c  d1d1              BNE      |L1.802|
00037e  2100              MOVS     r1,#0                 ;851
000380  9800              LDR      r0,[sp,#0]            ;851
000382  f7fffffe          BL       FLASH_ProgramHalfWord
000386  bdfe              POP      {r1-r7,pc}
;;;861    
                          ENDP

                  EE_Format PROC
;;;602      */
;;;603    static FLASH_Status EE_Format(void)
000388  b510              PUSH     {r4,lr}
;;;604    {
;;;605        FLASH_Status FlashStatus = FLASH_COMPLETE;
;;;606        
;;;607        /* Erase Page0 */
;;;608        FlashStatus = FLASH_ErasePage(PAGE0_BASE_ADDRESS);
00038a  4c08              LDR      r4,|L1.940|
00038c  4620              MOV      r0,r4
00038e  f7fffffe          BL       FLASH_ErasePage
;;;609        
;;;610        /* If erase operation was failed, a Flash error code is returned */
;;;611        if (FlashStatus != FLASH_COMPLETE)
000392  2804              CMP      r0,#4
000394  d108              BNE      |L1.936|
;;;612        {
;;;613            return FlashStatus;
;;;614        }
;;;615        
;;;616        /* Set Page0 as valid page: Write VALID_PAGE at Page0 base address */
;;;617        FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
000396  2100              MOVS     r1,#0
000398  4620              MOV      r0,r4
00039a  f7fffffe          BL       FLASH_ProgramHalfWord
;;;618        
;;;619        /* If program operation was failed, a Flash error code is returned */
;;;620        if (FlashStatus != FLASH_COMPLETE)
00039e  2804              CMP      r0,#4
0003a0  d102              BNE      |L1.936|
;;;621        {
;;;622            return FlashStatus;
;;;623        }
;;;624        
;;;625        /* Erase Page1 */
;;;626        FlashStatus = FLASH_ErasePage(PAGE1_BASE_ADDRESS);
0003a2  4803              LDR      r0,|L1.944|
0003a4  f7fffffe          BL       FLASH_ErasePage
                  |L1.936|
;;;627        
;;;628        /* Return Page1 erase operation status */
;;;629        return FlashStatus;
;;;630    }
0003a8  bd10              POP      {r4,pc}
;;;631    
                          ENDP

0003aa  0000              DCW      0x0000
                  |L1.940|
                          DCD      0x0800e000
                  |L1.944|
                          DCD      0x0800e400
                  |L1.948|
                          DCD      0x0000eeee
                  |L1.952|
0003b8  2e2e5c64          DCB      "..\\drivers\\stm32f051x\\char\\eeprom\\eeprom.c",0
0003bc  72697665
0003c0  72735c73
0003c4  746d3332
0003c8  66303531
0003cc  785c6368
0003d0  61725c65
0003d4  6570726f
0003d8  6d5c6565
0003dc  70726f6d
0003e0  2e6300  
0003e3  00                DCB      0
                  |L1.996|
0003e4  45455052          DCB      "EEPROM Read failed[%s]:%d",0
0003e8  4f4d2052
0003ec  65616420
0003f0  6661696c
0003f4  65645b25
0003f8  735d3a25
0003fc  6400    
0003fe  00                DCB      0
0003ff  00                DCB      0
                  |L1.1024|
000400  45455052          DCB      "EEPROM write failed",0
000404  4f4d2077
000408  72697465
00040c  20666169
000410  6c656400
                  |L1.1044|
                          DCD      ||.data||+0x8
                  |L1.1048|
                          DCD      0xffffeeef
                  |L1.1052|
                          DCD      eeprom_init
                  |L1.1056|
                          DCD      eeprom_open
                  |L1.1060|
                          DCD      eeprom_close
                  |L1.1064|
                          DCD      eeprom_write
                  |L1.1068|
                          DCD      eeprom_read
                  |L1.1072|
000430  45455052          DCB      "EEPROM",0
000434  4f4d00  
000437  00                DCB      0
                  |L1.1080|
000438  65657072          DCB      "eeprom allocated failed",0
00043c  6f6d2061
000440  6c6c6f63
000444  61746564
000448  20666169
00044c  6c656400

                          AREA ||.data||, DATA, ALIGN=2

                  DataVar
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  eeprom_simulation
                          DCD      0x00000000
                  VirtAddVarTab
                          DCD      0x00000000
00000c  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\drivers\\stm32f051x\\char\\eeprom\\eeprom.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_eeprom_c_DataVar____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_eeprom_c_DataVar____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_eeprom_c_DataVar____REVSH|
#line 144
|__asm___8_eeprom_c_DataVar____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
