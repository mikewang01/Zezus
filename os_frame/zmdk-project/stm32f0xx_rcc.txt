; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\stm32f0xx_rcc.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f0xx_rcc.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\stm32f0xx_rcc.crf ..\arch\arm\stm32f05x\lib\src\stm32f0xx_rcc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;145      */
;;;146    void RCC_DeInit(void)
000000  48f7              LDR      r0,|L1.992|
;;;147    {
;;;148      /* Set HSION bit 开内部高速时钟*/
;;;149      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  2201              MOVS     r2,#1
000006  4311              ORRS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;150    
;;;151      /* 时钟配置寄存器Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
;;;152    	//MCO关：000; PLL输入时钟X16;高速外部时钟被PLL/2;ADC时钟/2;PCLK,HCLK无分频；软件选择HSI作为系统时钟；
;;;153      RCC->CFGR &= (uint32_t)0xF8FFB80C;
00000a  6841              LDR      r1,[r0,#4]
00000c  4af5              LDR      r2,|L1.996|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;154      
;;;155      /* Reset HSEON, CSSON and PLLON bits */
;;;156      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  4af4              LDR      r2,|L1.1000|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;157    
;;;158      /* Reset HSEBYP bit */
;;;159      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001a  6801              LDR      r1,[r0,#0]
00001c  2201              MOVS     r2,#1
00001e  0492              LSLS     r2,r2,#18
000020  4391              BICS     r1,r1,r2
000022  6001              STR      r1,[r0,#0]
;;;160    
;;;161      /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;162      RCC->CFGR &= (uint32_t)0xFFC0FFFF;
000024  6841              LDR      r1,[r0,#4]
000026  223f              MOVS     r2,#0x3f
000028  0412              LSLS     r2,r2,#16
00002a  4391              BICS     r1,r1,r2
00002c  6041              STR      r1,[r0,#4]
;;;163    
;;;164      /* Reset PREDIV1[3:0] bits */
;;;165      RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
00002e  6ac1              LDR      r1,[r0,#0x2c]
000030  0909              LSRS     r1,r1,#4
000032  0109              LSLS     r1,r1,#4
000034  62c1              STR      r1,[r0,#0x2c]
;;;166    
;;;167      /* Reset USARTSW[1:0], I2CSW, CECSW and ADCSW bits */
;;;168      RCC->CFGR3 &= (uint32_t)0xFFFFFEAC;
000036  6b01              LDR      r1,[r0,#0x30]
000038  22ff              MOVS     r2,#0xff
00003a  3254              ADDS     r2,r2,#0x54
00003c  4391              BICS     r1,r1,r2
00003e  6301              STR      r1,[r0,#0x30]
;;;169      
;;;170      /* Reset HSI14 bit */
;;;171      RCC->CR2 &= (uint32_t)0xFFFFFFFE;
000040  6b41              LDR      r1,[r0,#0x34]
000042  0849              LSRS     r1,r1,#1
000044  0049              LSLS     r1,r1,#1
000046  6341              STR      r1,[r0,#0x34]
;;;172    
;;;173      /* Disable all interrupts */
;;;174      RCC->CIR = 0x00000000;
000048  2100              MOVS     r1,#0
00004a  6081              STR      r1,[r0,#8]
;;;175    }
00004c  4770              BX       lr
;;;176    
                          ENDP

                  RCC_HSEConfig PROC
;;;197      */
;;;198    void RCC_HSEConfig(uint8_t RCC_HSE)
00004e  49e4              LDR      r1,|L1.992|
;;;199    {
;;;200      /* Check the parameters */
;;;201      assert_param(IS_RCC_HSE(RCC_HSE));
;;;202    
;;;203      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;204      *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
000050  2200              MOVS     r2,#0
000052  708a              STRB     r2,[r1,#2]
;;;205    
;;;206      /* Set the new HSE configuration -------------------------------------------*/
;;;207      *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
000054  7088              STRB     r0,[r1,#2]
;;;208    
;;;209    }
000056  4770              BX       lr
;;;210    
                          ENDP

                  RCC_GetFlagStatus PROC
;;;1426     */
;;;1427   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000058  4603              MOV      r3,r0
;;;1428   {
;;;1429     uint32_t tmp = 0;
;;;1430     uint32_t statusreg = 0;
;;;1431     FlagStatus bitstatus = RESET;
00005a  2000              MOVS     r0,#0
;;;1432   
;;;1433     /* Check the parameters */
;;;1434     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1435   
;;;1436     /* Get the RCC register index */
;;;1437     tmp = RCC_FLAG >> 5;
;;;1438   
;;;1439     if (tmp == 0)               /* The flag to check is in CR register */
;;;1440     {
;;;1441       statusreg = RCC->CR;
00005c  4ae0              LDR      r2,|L1.992|
00005e  0959              LSRS     r1,r3,#5              ;1437
000060  d00c              BEQ      |L1.124|
;;;1442     }
;;;1443     else if (tmp == 1)          /* The flag to check is in BDCR register */
000062  2901              CMP      r1,#1
000064  d00c              BEQ      |L1.128|
;;;1444     {
;;;1445       statusreg = RCC->BDCR;
;;;1446     }
;;;1447     else if (tmp == 2)          /* The flag to check is in CSR register */
000066  2902              CMP      r1,#2
000068  d00c              BEQ      |L1.132|
;;;1448     {
;;;1449       statusreg = RCC->CSR;
;;;1450     }
;;;1451     else                        /* The flag to check is in CR2 register */
;;;1452     {
;;;1453       statusreg = RCC->CR2;
00006a  6b51              LDR      r1,[r2,#0x34]
                  |L1.108|
;;;1454     }    
;;;1455   
;;;1456     /* Get the flag position */
;;;1457     tmp = RCC_FLAG & FLAG_MASK;
00006c  06da              LSLS     r2,r3,#27
00006e  0ed2              LSRS     r2,r2,#27
;;;1458   
;;;1459     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000070  2301              MOVS     r3,#1
000072  4093              LSLS     r3,r3,r2
000074  420b              TST      r3,r1
000076  d000              BEQ      |L1.122|
;;;1460     {
;;;1461       bitstatus = SET;
000078  2001              MOVS     r0,#1
                  |L1.122|
;;;1462     }
;;;1463     else
;;;1464     {
;;;1465       bitstatus = RESET;
;;;1466     }
;;;1467     /* Return the flag status */
;;;1468     return bitstatus;
;;;1469   }
00007a  4770              BX       lr
                  |L1.124|
00007c  6811              LDR      r1,[r2,#0]            ;1441
00007e  e7f5              B        |L1.108|
                  |L1.128|
000080  6a11              LDR      r1,[r2,#0x20]         ;1445
000082  e7f3              B        |L1.108|
                  |L1.132|
000084  6a51              LDR      r1,[r2,#0x24]         ;1449
000086  e7f1              B        |L1.108|
;;;1470   
                          ENDP

                  RCC_WaitForHSEStartUp PROC
;;;223      */
;;;224    ErrorStatus RCC_WaitForHSEStartUp(void)
000088  b518              PUSH     {r3,r4,lr}
;;;225    {
;;;226      __IO uint32_t StartUpCounter = 0;
00008a  2000              MOVS     r0,#0
;;;227      ErrorStatus status = ERROR;
;;;228      FlagStatus HSEStatus = RESET;
;;;229      
;;;230      /* Wait till HSE is ready and if timeout is reached exit */
;;;231      do
;;;232      {
;;;233        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;234        StartUpCounter++;  
;;;235      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
00008c  2405              MOVS     r4,#5
00008e  0224              LSLS     r4,r4,#8
000090  9000              STR      r0,[sp,#0]
                  |L1.146|
000092  2011              MOVS     r0,#0x11              ;233
000094  f7fffffe          BL       RCC_GetFlagStatus
000098  9900              LDR      r1,[sp,#0]            ;234
00009a  1c49              ADDS     r1,r1,#1              ;234
00009c  9100              STR      r1,[sp,#0]
00009e  42a1              CMP      r1,r4
0000a0  d001              BEQ      |L1.166|
0000a2  2800              CMP      r0,#0
0000a4  d0f5              BEQ      |L1.146|
                  |L1.166|
;;;236      
;;;237      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
0000a6  2011              MOVS     r0,#0x11
0000a8  f7fffffe          BL       RCC_GetFlagStatus
0000ac  2800              CMP      r0,#0
0000ae  d000              BEQ      |L1.178|
;;;238      {
;;;239        status = SUCCESS;
0000b0  2001              MOVS     r0,#1
                  |L1.178|
;;;240      }
;;;241      else
;;;242      {
;;;243        status = ERROR;
;;;244      }  
;;;245      return (status);
;;;246    }
0000b2  bd18              POP      {r3,r4,pc}
;;;247    
                          ENDP

                  RCC_AdjustHSICalibrationValue PROC
;;;257      */
;;;258    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
0000b4  4aca              LDR      r2,|L1.992|
;;;259    {
;;;260      uint32_t tmpreg = 0;
;;;261      
;;;262      /* Check the parameters */
;;;263      assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
;;;264      
;;;265      tmpreg = RCC->CR;
0000b6  6811              LDR      r1,[r2,#0]
;;;266      
;;;267      /* Clear HSITRIM[4:0] bits */
;;;268      tmpreg &= ~RCC_CR_HSITRIM;
0000b8  23f8              MOVS     r3,#0xf8
0000ba  4399              BICS     r1,r1,r3
;;;269      
;;;270      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;271      tmpreg |= (uint32_t)HSICalibrationValue << 3;
0000bc  00c0              LSLS     r0,r0,#3
0000be  4308              ORRS     r0,r0,r1
;;;272    
;;;273      /* Store the new value */
;;;274      RCC->CR = tmpreg;
0000c0  6010              STR      r0,[r2,#0]
;;;275    }
0000c2  4770              BX       lr
;;;276    
                          ENDP

                  RCC_HSICmd PROC
;;;291      */
;;;292    void RCC_HSICmd(FunctionalState NewState)
0000c4  49c6              LDR      r1,|L1.992|
;;;293    {
;;;294      /* Check the parameters */
;;;295      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;296      
;;;297      if (NewState != DISABLE)
0000c6  2800              CMP      r0,#0
;;;298      {
;;;299        RCC->CR |= RCC_CR_HSION;
;;;300      }
;;;301      else
;;;302      {
;;;303        RCC->CR &= ~RCC_CR_HSION;
0000c8  6808              LDR      r0,[r1,#0]
0000ca  d002              BEQ      |L1.210|
0000cc  2201              MOVS     r2,#1                 ;299
0000ce  4310              ORRS     r0,r0,r2              ;299
0000d0  e001              B        |L1.214|
                  |L1.210|
0000d2  0840              LSRS     r0,r0,#1
0000d4  0040              LSLS     r0,r0,#1
                  |L1.214|
0000d6  6008              STR      r0,[r1,#0]            ;299
;;;304      }
;;;305    }
0000d8  4770              BX       lr
;;;306    
                          ENDP

                  RCC_AdjustHSI14CalibrationValue PROC
;;;317      */
;;;318    void RCC_AdjustHSI14CalibrationValue(uint8_t HSI14CalibrationValue)
0000da  4ac1              LDR      r2,|L1.992|
;;;319    {
;;;320      uint32_t tmpreg = 0;
;;;321      
;;;322      /* Check the parameters */
;;;323      assert_param(IS_RCC_HSI14_CALIBRATION_VALUE(HSI14CalibrationValue));
;;;324      
;;;325      tmpreg = RCC->CR2;
0000dc  6b51              LDR      r1,[r2,#0x34]
;;;326      
;;;327      /* Clear HSI14TRIM[4:0] bits */
;;;328      tmpreg &= ~RCC_CR2_HSI14TRIM;
0000de  23f8              MOVS     r3,#0xf8
0000e0  4399              BICS     r1,r1,r3
;;;329      
;;;330      /* Set the HSITRIM14[4:0] bits according to HSI14CalibrationValue value */
;;;331      tmpreg |= (uint32_t)HSI14CalibrationValue << 3;
0000e2  00c0              LSLS     r0,r0,#3
0000e4  4308              ORRS     r0,r0,r1
;;;332    
;;;333      /* Store the new value */
;;;334      RCC->CR2 = tmpreg;
0000e6  6350              STR      r0,[r2,#0x34]
;;;335    }
0000e8  4770              BX       lr
;;;336    
                          ENDP

                  RCC_HSI14Cmd PROC
;;;348      */
;;;349    void RCC_HSI14Cmd(FunctionalState NewState)
0000ea  49bd              LDR      r1,|L1.992|
;;;350    {
;;;351      /* Check the parameters */
;;;352      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;353      
;;;354      if (NewState != DISABLE)
0000ec  2800              CMP      r0,#0
;;;355      {
;;;356        RCC->CR2 |= RCC_CR2_HSI14ON;
;;;357      }
;;;358      else
;;;359      {
;;;360        RCC->CR2 &= ~RCC_CR2_HSI14ON;
0000ee  6b48              LDR      r0,[r1,#0x34]
0000f0  d002              BEQ      |L1.248|
0000f2  2201              MOVS     r2,#1                 ;356
0000f4  4310              ORRS     r0,r0,r2              ;356
0000f6  e001              B        |L1.252|
                  |L1.248|
0000f8  0840              LSRS     r0,r0,#1
0000fa  0040              LSLS     r0,r0,#1
                  |L1.252|
0000fc  6348              STR      r0,[r1,#0x34]         ;356
;;;361      }
;;;362    }
0000fe  4770              BX       lr
;;;363    
                          ENDP

                  RCC_HSI14ADCRequestCmd PROC
;;;369      */
;;;370    void RCC_HSI14ADCRequestCmd(FunctionalState NewState)
000100  49b7              LDR      r1,|L1.992|
;;;371    {
;;;372      /* Check the parameters */
;;;373      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;374      
;;;375      if (NewState != DISABLE)
;;;376      {
;;;377        RCC->CR2 &= ~RCC_CR2_HSI14DIS;
000102  2204              MOVS     r2,#4
000104  2800              CMP      r0,#0                 ;375
;;;378      }
;;;379      else
;;;380      {
;;;381        RCC->CR2 |= RCC_CR2_HSI14DIS;
000106  6b48              LDR      r0,[r1,#0x34]
000108  d001              BEQ      |L1.270|
00010a  4390              BICS     r0,r0,r2              ;377
00010c  e000              B        |L1.272|
                  |L1.270|
00010e  4310              ORRS     r0,r0,r2
                  |L1.272|
000110  6348              STR      r0,[r1,#0x34]         ;377
;;;382      }
;;;383    }
000112  4770              BX       lr
;;;384    
                          ENDP

                  RCC_LSEConfig PROC
;;;401      */
;;;402    void RCC_LSEConfig(uint32_t RCC_LSE)
000114  49b2              LDR      r1,|L1.992|
;;;403    {
;;;404      /* Check the parameters */
;;;405      assert_param(IS_RCC_LSE(RCC_LSE));
;;;406    
;;;407      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;408      /* Reset LSEON bit */
;;;409      RCC->BDCR &= ~(RCC_BDCR_LSEON);
000116  6a0a              LDR      r2,[r1,#0x20]
000118  0852              LSRS     r2,r2,#1
00011a  0052              LSLS     r2,r2,#1
00011c  620a              STR      r2,[r1,#0x20]
;;;410    
;;;411      /* Reset LSEBYP bit */
;;;412      RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
00011e  6a0a              LDR      r2,[r1,#0x20]
000120  2304              MOVS     r3,#4
000122  439a              BICS     r2,r2,r3
000124  620a              STR      r2,[r1,#0x20]
;;;413    
;;;414      /* Configure LSE */
;;;415      RCC->BDCR |= RCC_LSE;
000126  6a0a              LDR      r2,[r1,#0x20]
000128  4302              ORRS     r2,r2,r0
00012a  620a              STR      r2,[r1,#0x20]
;;;416    }
00012c  4770              BX       lr
;;;417    
                          ENDP

                  RCC_LSEDriveConfig PROC
;;;427      */
;;;428    void RCC_LSEDriveConfig(uint32_t RCC_LSEDrive)
00012e  49ac              LDR      r1,|L1.992|
;;;429    {
;;;430      /* Check the parameters */
;;;431      assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
;;;432      
;;;433      /* Clear LSEDRV[1:0] bits */
;;;434      RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
000130  6a0a              LDR      r2,[r1,#0x20]
000132  2318              MOVS     r3,#0x18
000134  439a              BICS     r2,r2,r3
000136  620a              STR      r2,[r1,#0x20]
;;;435    
;;;436      /* Set the LSE Drive */
;;;437      RCC->BDCR |= RCC_LSEDrive;
000138  6a0a              LDR      r2,[r1,#0x20]
00013a  4302              ORRS     r2,r2,r0
00013c  620a              STR      r2,[r1,#0x20]
;;;438    }
00013e  4770              BX       lr
;;;439    
                          ENDP

                  RCC_LSICmd PROC
;;;451      */
;;;452    void RCC_LSICmd(FunctionalState NewState)
000140  49a7              LDR      r1,|L1.992|
;;;453    {
;;;454      /* Check the parameters */
;;;455      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;456      
;;;457      if (NewState != DISABLE)
000142  2800              CMP      r0,#0
;;;458      {
;;;459        RCC->CSR |= RCC_CSR_LSION;
;;;460      }
;;;461      else
;;;462      {
;;;463        RCC->CSR &= ~RCC_CSR_LSION;
000144  6a48              LDR      r0,[r1,#0x24]
000146  d002              BEQ      |L1.334|
000148  2201              MOVS     r2,#1                 ;459
00014a  4310              ORRS     r0,r0,r2              ;459
00014c  e001              B        |L1.338|
                  |L1.334|
00014e  0840              LSRS     r0,r0,#1
000150  0040              LSLS     r0,r0,#1
                  |L1.338|
000152  6248              STR      r0,[r1,#0x24]         ;459
;;;464      }
;;;465    }
000154  4770              BX       lr
;;;466    
                          ENDP

                  RCC_PLLConfig PROC
;;;482      */
;;;483    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000156  b510              PUSH     {r4,lr}
;;;484    {
;;;485      /* Check the parameters */
;;;486      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;487      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;488    
;;;489      /* Clear PLL Source [16] and Multiplier [21:18] bits */
;;;490      RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
000158  4aa1              LDR      r2,|L1.992|
00015a  6853              LDR      r3,[r2,#4]
00015c  243d              MOVS     r4,#0x3d
00015e  0424              LSLS     r4,r4,#16
000160  43a3              BICS     r3,r3,r4
000162  6053              STR      r3,[r2,#4]
;;;491    
;;;492      /* Set the PLL Source and Multiplier */
;;;493      RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
000164  6853              LDR      r3,[r2,#4]
000166  4308              ORRS     r0,r0,r1
000168  4303              ORRS     r3,r3,r0
00016a  6053              STR      r3,[r2,#4]
;;;494    }
00016c  bd10              POP      {r4,pc}
;;;495    
                          ENDP

                  RCC_PLLCmd PROC
;;;506      */
;;;507    void RCC_PLLCmd(FunctionalState NewState)
00016e  2201              MOVS     r2,#1
;;;508    {
;;;509      /* Check the parameters */
;;;510      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;511      
;;;512      if (NewState != DISABLE)
;;;513      {
;;;514        RCC->CR |= RCC_CR_PLLON;
000170  499b              LDR      r1,|L1.992|
000172  0612              LSLS     r2,r2,#24
000174  2800              CMP      r0,#0                 ;512
;;;515      }
;;;516      else
;;;517      {
;;;518        RCC->CR &= ~RCC_CR_PLLON;
000176  6808              LDR      r0,[r1,#0]
000178  d001              BEQ      |L1.382|
00017a  4310              ORRS     r0,r0,r2              ;514
00017c  e000              B        |L1.384|
                  |L1.382|
00017e  4390              BICS     r0,r0,r2
                  |L1.384|
000180  6008              STR      r0,[r1,#0]            ;514
;;;519      }
;;;520    }
000182  4770              BX       lr
;;;521    
                          ENDP

                  RCC_PREDIV1Config PROC
;;;528      */
;;;529    void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div)
000184  4a96              LDR      r2,|L1.992|
;;;530    {
;;;531      uint32_t tmpreg = 0;
;;;532      
;;;533      /* Check the parameters */
;;;534      assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
;;;535    
;;;536      tmpreg = RCC->CFGR2;
000186  6ad1              LDR      r1,[r2,#0x2c]
;;;537      /* Clear PREDIV1[3:0] bits */
;;;538      tmpreg &= ~(RCC_CFGR2_PREDIV1);
000188  0909              LSRS     r1,r1,#4
00018a  0109              LSLS     r1,r1,#4
;;;539      /* Set the PREDIV1 division factor */
;;;540      tmpreg |= RCC_PREDIV1_Div;
00018c  4301              ORRS     r1,r1,r0
;;;541      /* Store the new value */
;;;542      RCC->CFGR2 = tmpreg;
00018e  62d1              STR      r1,[r2,#0x2c]
;;;543    }
000190  4770              BX       lr
;;;544    
                          ENDP

                  RCC_ClockSecuritySystemCmd PROC
;;;555      */
;;;556    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000192  2201              MOVS     r2,#1
;;;557    {
;;;558      /* Check the parameters */
;;;559      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;560      
;;;561      if (NewState != DISABLE)
;;;562      {
;;;563        RCC->CR |= RCC_CR_CSSON;
000194  4992              LDR      r1,|L1.992|
000196  04d2              LSLS     r2,r2,#19
000198  2800              CMP      r0,#0                 ;561
;;;564      }
;;;565      else
;;;566      {
;;;567        RCC->CR &= ~RCC_CR_CSSON;
00019a  6808              LDR      r0,[r1,#0]
00019c  d001              BEQ      |L1.418|
00019e  4310              ORRS     r0,r0,r2              ;563
0001a0  e000              B        |L1.420|
                  |L1.418|
0001a2  4390              BICS     r0,r0,r2
                  |L1.420|
0001a4  6008              STR      r0,[r1,#0]            ;563
;;;568      }
;;;569    }
0001a6  4770              BX       lr
;;;570    
                          ENDP

                  RCC_MCOConfig PROC
;;;585      */
;;;586    void RCC_MCOConfig(uint8_t RCC_MCOSource)
0001a8  498d              LDR      r1,|L1.992|
;;;587    {
;;;588      /* Check the parameters */
;;;589      assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
;;;590        
;;;591      /* Select MCO clock source and prescaler */
;;;592      *(__IO uint8_t *) CFGR_BYTE3_ADDRESS =  RCC_MCOSource;
0001aa  71c8              STRB     r0,[r1,#7]
;;;593    }
0001ac  4770              BX       lr
;;;594    
                          ENDP

                  RCC_SYSCLKConfig PROC
;;;690      */
;;;691    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
0001ae  4a8c              LDR      r2,|L1.992|
;;;692    {
;;;693      uint32_t tmpreg = 0;
;;;694      
;;;695      /* Check the parameters */
;;;696      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;697      
;;;698      tmpreg = RCC->CFGR;
0001b0  6851              LDR      r1,[r2,#4]
;;;699      
;;;700      /* Clear SW[1:0] bits */
;;;701      tmpreg &= ~RCC_CFGR_SW;
0001b2  0889              LSRS     r1,r1,#2
0001b4  0089              LSLS     r1,r1,#2
;;;702      
;;;703      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;704      tmpreg |= RCC_SYSCLKSource;
0001b6  4301              ORRS     r1,r1,r0
;;;705      
;;;706      /* Store the new value */
;;;707      RCC->CFGR = tmpreg;
0001b8  6051              STR      r1,[r2,#4]
;;;708    }
0001ba  4770              BX       lr
;;;709    
                          ENDP

                  RCC_GetSYSCLKSource PROC
;;;718      */
;;;719    uint8_t RCC_GetSYSCLKSource(void)
0001bc  4888              LDR      r0,|L1.992|
;;;720    {
;;;721      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
0001be  6840              LDR      r0,[r0,#4]
0001c0  210c              MOVS     r1,#0xc
0001c2  4008              ANDS     r0,r0,r1
;;;722    }
0001c4  4770              BX       lr
;;;723    
                          ENDP

                  RCC_HCLKConfig PROC
;;;739      */
;;;740    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
0001c6  4a86              LDR      r2,|L1.992|
;;;741    {
;;;742      uint32_t tmpreg = 0;
;;;743      
;;;744      /* Check the parameters */
;;;745      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;746      
;;;747      tmpreg = RCC->CFGR;
0001c8  6851              LDR      r1,[r2,#4]
;;;748      
;;;749      /* Clear HPRE[3:0] bits */
;;;750      tmpreg &= ~RCC_CFGR_HPRE;
0001ca  23f0              MOVS     r3,#0xf0
0001cc  4399              BICS     r1,r1,r3
;;;751      
;;;752      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;753      tmpreg |= RCC_SYSCLK;
0001ce  4301              ORRS     r1,r1,r0
;;;754      
;;;755      /* Store the new value */
;;;756      RCC->CFGR = tmpreg;
0001d0  6051              STR      r1,[r2,#4]
;;;757    }
0001d2  4770              BX       lr
;;;758    
                          ENDP

                  RCC_PCLKConfig PROC
;;;770      */
;;;771    void RCC_PCLKConfig(uint32_t RCC_HCLK)
0001d4  4a82              LDR      r2,|L1.992|
;;;772    {
;;;773      uint32_t tmpreg = 0;
;;;774      
;;;775      /* Check the parameters */
;;;776      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;777      
;;;778      tmpreg = RCC->CFGR;
0001d6  6851              LDR      r1,[r2,#4]
;;;779      
;;;780      /* Clear PPRE[2:0] bits */
;;;781      tmpreg &= ~RCC_CFGR_PPRE;
0001d8  2307              MOVS     r3,#7
0001da  021b              LSLS     r3,r3,#8
0001dc  4399              BICS     r1,r1,r3
;;;782      
;;;783      /* Set PPRE[2:0] bits according to RCC_HCLK value */
;;;784      tmpreg |= RCC_HCLK;
0001de  4301              ORRS     r1,r1,r0
;;;785      
;;;786      /* Store the new value */
;;;787      RCC->CFGR = tmpreg;
0001e0  6051              STR      r1,[r2,#4]
;;;788    }
0001e2  4770              BX       lr
;;;789    
                          ENDP

                  RCC_ADCCLKConfig PROC
;;;799      */
;;;800    void RCC_ADCCLKConfig(uint32_t RCC_ADCCLK)
0001e4  497e              LDR      r1,|L1.992|
;;;801    { 
;;;802      /* Check the parameters */
;;;803      assert_param(IS_RCC_ADCCLK(RCC_ADCCLK));
;;;804    
;;;805      /* Clear ADCPRE bit */
;;;806      RCC->CFGR &= ~RCC_CFGR_ADCPRE;
0001e6  684a              LDR      r2,[r1,#4]
0001e8  2301              MOVS     r3,#1
0001ea  039b              LSLS     r3,r3,#14
0001ec  439a              BICS     r2,r2,r3
0001ee  604a              STR      r2,[r1,#4]
;;;807      /* Set ADCPRE bits according to RCC_PCLK value */
;;;808      RCC->CFGR |= RCC_ADCCLK & 0xFFFF;
0001f0  684a              LDR      r2,[r1,#4]
0001f2  b283              UXTH     r3,r0
0001f4  431a              ORRS     r2,r2,r3
0001f6  604a              STR      r2,[r1,#4]
;;;809    
;;;810      /* Clear ADCSW bit */
;;;811      RCC->CFGR3 &= ~RCC_CFGR3_ADCSW; 
0001f8  6b0a              LDR      r2,[r1,#0x30]
0001fa  158b              ASRS     r3,r1,#22
0001fc  439a              BICS     r2,r2,r3
0001fe  630a              STR      r2,[r1,#0x30]
;;;812      /* Set ADCSW bits according to RCC_ADCCLK value */
;;;813      RCC->CFGR3 |= RCC_ADCCLK >> 16;  
000200  6b0a              LDR      r2,[r1,#0x30]
000202  0c00              LSRS     r0,r0,#16
000204  4302              ORRS     r2,r2,r0
000206  630a              STR      r2,[r1,#0x30]
;;;814    }
000208  4770              BX       lr
;;;815    
                          ENDP

                  RCC_CECCLKConfig PROC
;;;824      */
;;;825    void RCC_CECCLKConfig(uint32_t RCC_CECCLK)
00020a  4975              LDR      r1,|L1.992|
;;;826    { 
;;;827      /* Check the parameters */
;;;828      assert_param(IS_RCC_CECCLK(RCC_CECCLK));
;;;829    
;;;830      /* Clear CECSW bit */
;;;831      RCC->CFGR3 &= ~RCC_CFGR3_CECSW;
00020c  6b0a              LDR      r2,[r1,#0x30]
00020e  2340              MOVS     r3,#0x40
000210  439a              BICS     r2,r2,r3
000212  630a              STR      r2,[r1,#0x30]
;;;832      /* Set CECSW bits according to RCC_CECCLK value */
;;;833      RCC->CFGR3 |= RCC_CECCLK;
000214  6b0a              LDR      r2,[r1,#0x30]
000216  4302              ORRS     r2,r2,r0
000218  630a              STR      r2,[r1,#0x30]
;;;834    }
00021a  4770              BX       lr
;;;835    
                          ENDP

                  RCC_I2CCLKConfig PROC
;;;844      */
;;;845    void RCC_I2CCLKConfig(uint32_t RCC_I2CCLK)
00021c  4970              LDR      r1,|L1.992|
;;;846    { 
;;;847      /* Check the parameters */
;;;848      assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));
;;;849    
;;;850      /* Clear I2CSW bit */
;;;851      RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
00021e  6b0a              LDR      r2,[r1,#0x30]
000220  2310              MOVS     r3,#0x10
000222  439a              BICS     r2,r2,r3
000224  630a              STR      r2,[r1,#0x30]
;;;852      /* Set I2CSW bits according to RCC_I2CCLK value */
;;;853      RCC->CFGR3 |= RCC_I2CCLK;
000226  6b0a              LDR      r2,[r1,#0x30]
000228  4302              ORRS     r2,r2,r0
00022a  630a              STR      r2,[r1,#0x30]
;;;854    }
00022c  4770              BX       lr
;;;855    
                          ENDP

                  RCC_USARTCLKConfig PROC
;;;866      */
;;;867    void RCC_USARTCLKConfig(uint32_t RCC_USARTCLK)
00022e  496c              LDR      r1,|L1.992|
;;;868    { 
;;;869      /* Check the parameters */
;;;870      assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));
;;;871    
;;;872      /* Clear USARTSW[1:0] bit */
;;;873      RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
000230  6b0a              LDR      r2,[r1,#0x30]
000232  0892              LSRS     r2,r2,#2
000234  0092              LSLS     r2,r2,#2
000236  630a              STR      r2,[r1,#0x30]
;;;874      /* Set USARTSW bits according to RCC_USARTCLK value */
;;;875      RCC->CFGR3 |= RCC_USARTCLK;
000238  6b0a              LDR      r2,[r1,#0x30]
00023a  4302              ORRS     r2,r2,r0
00023c  630a              STR      r2,[r1,#0x30]
;;;876    }
00023e  4770              BX       lr
;;;877    
                          ENDP

                  RCC_GetClocksFreq PROC
;;;913      */
;;;914    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000240  b5f8              PUSH     {r3-r7,lr}
;;;915    {
;;;916      uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0;
;;;917    
;;;918      /* Get SYSCLK source -------------------------------------------------------*/
;;;919      tmp = RCC->CFGR & RCC_CFGR_SWS;
000242  4e67              LDR      r6,|L1.992|
000244  4604              MOV      r4,r0                 ;915
000246  6870              LDR      r0,[r6,#4]
000248  210c              MOVS     r1,#0xc
;;;920      
;;;921      switch (tmp)
;;;922      {
;;;923        case 0x00:  /* HSI used as system clock */
;;;924          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
00024a  4d68              LDR      r5,|L1.1004|
00024c  4008              ANDS     r0,r0,r1              ;919
00024e  d003              BEQ      |L1.600|
000250  2804              CMP      r0,#4                 ;921
000252  d001              BEQ      |L1.600|
000254  2808              CMP      r0,#8                 ;921
000256  d001              BEQ      |L1.604|
                  |L1.600|
;;;925          break;
000258  6025              STR      r5,[r4,#0]
00025a  e012              B        |L1.642|
                  |L1.604|
;;;926        case 0x04:  /* HSE used as system clock */
;;;927          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
;;;928          break;
;;;929        case 0x08:  /* PLL used as system clock */
;;;930          /* Get PLL clock source and multiplication factor ----------------------*/
;;;931          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
00025c  6871              LDR      r1,[r6,#4]
;;;932          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
00025e  6870              LDR      r0,[r6,#4]
000260  2201              MOVS     r2,#1
;;;933          pllmull = ( pllmull >> 18) + 2;
;;;934          
;;;935          if (pllsource == 0x00)
;;;936          {
;;;937            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;938            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;939          }
;;;940          else
;;;941          {
;;;942            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;943            /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;944            RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
;;;945          }      
;;;946          break;
;;;947        default: /* HSI used as system clock */
;;;948          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;949          break;
;;;950      }
;;;951      /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
;;;952      /* Get HCLK prescaler */
;;;953      tmp = RCC->CFGR & RCC_CFGR_HPRE;
;;;954      tmp = tmp >> 4;
;;;955      presc = APBAHBPrescTable[tmp]; 
;;;956      /* HCLK clock frequency */
;;;957      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;958    
;;;959      /* Get PCLK prescaler */
;;;960      tmp = RCC->CFGR & RCC_CFGR_PPRE;
;;;961      tmp = tmp >> 8;
;;;962      presc = APBAHBPrescTable[tmp];
;;;963      /* PCLK clock frequency */
;;;964      RCC_Clocks->PCLK_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;965    
;;;966      /* ADCCLK clock frequency */
;;;967      if((RCC->CFGR3 & RCC_CFGR3_ADCSW) != RCC_CFGR3_ADCSW)
;;;968      {
;;;969        /* ADC Clock is HSI14 Osc. */
;;;970        RCC_Clocks->ADCCLK_Frequency = HSI14_VALUE;
;;;971      }
;;;972      else
;;;973      {
;;;974        if((RCC->CFGR & RCC_CFGR_ADCPRE) != RCC_CFGR_ADCPRE)
;;;975        {
;;;976          /* ADC Clock is derived from PCLK/2 */
;;;977          RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 1;
;;;978        }
;;;979        else
;;;980        {
;;;981          /* ADC Clock is derived from PCLK/4 */
;;;982          RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 2;
;;;983        }
;;;984        
;;;985      }
;;;986    
;;;987      /* CECCLK clock frequency */
;;;988      if((RCC->CFGR3 & RCC_CFGR3_CECSW) != RCC_CFGR3_CECSW)
;;;989      {
;;;990        /* CEC Clock is HSI/256 */
;;;991        RCC_Clocks->CECCLK_Frequency = HSI_VALUE / 244;
;;;992      }
;;;993      else
;;;994      {
;;;995        /* CECC Clock is LSE Osc. */
;;;996        RCC_Clocks->CECCLK_Frequency = LSE_VALUE;
;;;997      }
;;;998    
;;;999      /* I2C1CLK clock frequency */
;;;1000     if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
;;;1001     {
;;;1002       /* I2C1 Clock is HSI Osc. */
;;;1003       RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
;;;1004     }
;;;1005     else
;;;1006     {
;;;1007       /* I2C1 Clock is System Clock */
;;;1008       RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;1009     }
;;;1010   
;;;1011     /* USART1CLK clock frequency */
;;;1012     if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
;;;1013     {
;;;1014       /* USART1 Clock is PCLK */
;;;1015       RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK_Frequency;
;;;1016     }
;;;1017     else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
;;;1018     {
;;;1019       /* USART1 Clock is System Clock */
;;;1020       RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;1021     }
;;;1022     else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
;;;1023     {
;;;1024       /* USART1 Clock is LSE Osc. */
;;;1025       RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
;;;1026     }
;;;1027     else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
;;;1028     {
;;;1029       /* USART1 Clock is HSI Osc. */
;;;1030       RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
;;;1031     }
;;;1032   
;;;1033   }
000262  0289              LSLS     r1,r1,#10
000264  0412              LSLS     r2,r2,#16             ;932
000266  0f0f              LSRS     r7,r1,#28
000268  4010              ANDS     r0,r0,r2              ;932
00026a  1cbf              ADDS     r7,r7,#2              ;933
00026c  2800              CMP      r0,#0                 ;935
00026e  d01c              BEQ      |L1.682|
000270  6af0              LDR      r0,[r6,#0x2c]         ;942
000272  0701              LSLS     r1,r0,#28             ;942
000274  0f09              LSRS     r1,r1,#28             ;942
000276  1c49              ADDS     r1,r1,#1              ;942
000278  4628              MOV      r0,r5                 ;944
00027a  f7fffffe          BL       __aeabi_uidivmod
00027e  4378              MULS     r0,r7,r0              ;944
000280  6020              STR      r0,[r4,#0]            ;944
                  |L1.642|
000282  6870              LDR      r0,[r6,#4]            ;953
000284  4b5a              LDR      r3,|L1.1008|
000286  0600              LSLS     r0,r0,#24
000288  0f00              LSRS     r0,r0,#28
00028a  5c1a              LDRB     r2,[r3,r0]            ;955
00028c  6820              LDR      r0,[r4,#0]            ;957
00028e  4601              MOV      r1,r0                 ;957
000290  40d1              LSRS     r1,r1,r2              ;957
000292  6061              STR      r1,[r4,#4]            ;960
000294  6872              LDR      r2,[r6,#4]            ;960
000296  0552              LSLS     r2,r2,#21
000298  0f52              LSRS     r2,r2,#29
00029a  5c9a              LDRB     r2,[r3,r2]            ;962
00029c  40d1              LSRS     r1,r1,r2              ;964
00029e  60a1              STR      r1,[r4,#8]            ;967
0002a0  6b32              LDR      r2,[r6,#0x30]         ;967
0002a2  05d2              LSLS     r2,r2,#23             ;967
0002a4  d405              BMI      |L1.690|
0002a6  4a53              LDR      r2,|L1.1012|
0002a8  e009              B        |L1.702|
                  |L1.682|
0002aa  4853              LDR      r0,|L1.1016|
0002ac  4347              MULS     r7,r0,r7              ;938
0002ae  6027              STR      r7,[r4,#0]            ;938
0002b0  e7e7              B        |L1.642|
                  |L1.690|
0002b2  6872              LDR      r2,[r6,#4]            ;974
0002b4  0452              LSLS     r2,r2,#17             ;974
0002b6  d401              BMI      |L1.700|
0002b8  084a              LSRS     r2,r1,#1              ;977
0002ba  e000              B        |L1.702|
                  |L1.700|
0002bc  088a              LSRS     r2,r1,#2              ;982
                  |L1.702|
0002be  60e2              STR      r2,[r4,#0xc]          ;988
0002c0  6b32              LDR      r2,[r6,#0x30]         ;988
0002c2  4b4e              LDR      r3,|L1.1020|
0002c4  0652              LSLS     r2,r2,#25             ;988
0002c6  d403              BMI      |L1.720|
0002c8  4a4c              LDR      r2,|L1.1020|
0002ca  3212              ADDS     r2,r2,#0x12           ;991
0002cc  6122              STR      r2,[r4,#0x10]         ;991
0002ce  e000              B        |L1.722|
                  |L1.720|
0002d0  6123              STR      r3,[r4,#0x10]         ;996
                  |L1.722|
0002d2  6b32              LDR      r2,[r6,#0x30]         ;1000
0002d4  06d2              LSLS     r2,r2,#27             ;1000
0002d6  d401              BMI      |L1.732|
0002d8  6165              STR      r5,[r4,#0x14]         ;1003
0002da  e000              B        |L1.734|
                  |L1.732|
0002dc  6160              STR      r0,[r4,#0x14]         ;1008
                  |L1.734|
0002de  6b32              LDR      r2,[r6,#0x30]         ;1012
0002e0  0792              LSLS     r2,r2,#30             ;1012
0002e2  d00f              BEQ      |L1.772|
0002e4  6b31              LDR      r1,[r6,#0x30]         ;1017
0002e6  0789              LSLS     r1,r1,#30             ;1017
0002e8  0f89              LSRS     r1,r1,#30             ;1017
0002ea  2901              CMP      r1,#1                 ;1017
0002ec  d00c              BEQ      |L1.776|
0002ee  6b30              LDR      r0,[r6,#0x30]         ;1022
0002f0  0780              LSLS     r0,r0,#30             ;1022
0002f2  0f80              LSRS     r0,r0,#30             ;1022
0002f4  2802              CMP      r0,#2                 ;1022
0002f6  d009              BEQ      |L1.780|
0002f8  6b30              LDR      r0,[r6,#0x30]         ;1027
0002fa  43c0              MVNS     r0,r0                 ;1027
0002fc  0780              LSLS     r0,r0,#30             ;1027
0002fe  d100              BNE      |L1.770|
000300  61a5              STR      r5,[r4,#0x18]         ;1030
                  |L1.770|
000302  bdf8              POP      {r3-r7,pc}
                  |L1.772|
000304  61a1              STR      r1,[r4,#0x18]         ;1015
000306  bdf8              POP      {r3-r7,pc}
                  |L1.776|
000308  61a0              STR      r0,[r4,#0x18]         ;1020
00030a  bdf8              POP      {r3-r7,pc}
                  |L1.780|
00030c  61a3              STR      r3,[r4,#0x18]         ;1025
00030e  bdf8              POP      {r3-r7,pc}
;;;1034   
                          ENDP

                  RCC_RTCCLKConfig PROC
;;;1087     */
;;;1088   void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000310  4933              LDR      r1,|L1.992|
;;;1089   {
;;;1090     /* Check the parameters */
;;;1091     assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;1092     
;;;1093     /* Select the RTC clock source */
;;;1094     RCC->BDCR |= RCC_RTCCLKSource;
000312  6a0a              LDR      r2,[r1,#0x20]
000314  4302              ORRS     r2,r2,r0
000316  620a              STR      r2,[r1,#0x20]
;;;1095   }
000318  4770              BX       lr
;;;1096   
                          ENDP

                  RCC_RTCCLKCmd PROC
;;;1104     */
;;;1105   void RCC_RTCCLKCmd(FunctionalState NewState)
00031a  4931              LDR      r1,|L1.992|
;;;1106   {
;;;1107     /* Check the parameters */
;;;1108     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1109     
;;;1110     if (NewState != DISABLE)
00031c  2800              CMP      r0,#0
;;;1111     {
;;;1112       RCC->BDCR |= RCC_BDCR_RTCEN;
00031e  4a37              LDR      r2,|L1.1020|
;;;1113     }
;;;1114     else
;;;1115     {
;;;1116       RCC->BDCR &= ~RCC_BDCR_RTCEN;
000320  6a08              LDR      r0,[r1,#0x20]
000322  d001              BEQ      |L1.808|
000324  4310              ORRS     r0,r0,r2              ;1112
000326  e000              B        |L1.810|
                  |L1.808|
000328  4390              BICS     r0,r0,r2
                  |L1.810|
00032a  6208              STR      r0,[r1,#0x20]         ;1112
;;;1117     }
;;;1118   }
00032c  4770              BX       lr
;;;1119   
                          ENDP

                  RCC_BackupResetCmd PROC
;;;1127     */
;;;1128   void RCC_BackupResetCmd(FunctionalState NewState)
00032e  2201              MOVS     r2,#1
;;;1129   {
;;;1130     /* Check the parameters */
;;;1131     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1132     
;;;1133     if (NewState != DISABLE)
;;;1134     {
;;;1135       RCC->BDCR |= RCC_BDCR_BDRST;
000330  492b              LDR      r1,|L1.992|
000332  0412              LSLS     r2,r2,#16
000334  2800              CMP      r0,#0                 ;1133
;;;1136     }
;;;1137     else
;;;1138     {
;;;1139       RCC->BDCR &= ~RCC_BDCR_BDRST;
000336  6a08              LDR      r0,[r1,#0x20]
000338  d001              BEQ      |L1.830|
00033a  4310              ORRS     r0,r0,r2              ;1135
00033c  e000              B        |L1.832|
                  |L1.830|
00033e  4390              BICS     r0,r0,r2
                  |L1.832|
000340  6208              STR      r0,[r1,#0x20]         ;1135
;;;1140     }
;;;1141   }
000342  4770              BX       lr
;;;1142   
                          ENDP

                  RCC_AHBPeriphClockCmd PROC
;;;1163     */
;;;1164   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000344  4a26              LDR      r2,|L1.992|
;;;1165   {
;;;1166     /* Check the parameters */
;;;1167     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1168     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1169     
;;;1170     if (NewState != DISABLE)
000346  2900              CMP      r1,#0
;;;1171     {
;;;1172       RCC->AHBENR |= RCC_AHBPeriph;
;;;1173     }
;;;1174     else
;;;1175     {
;;;1176       RCC->AHBENR &= ~RCC_AHBPeriph;
000348  6951              LDR      r1,[r2,#0x14]
00034a  d001              BEQ      |L1.848|
00034c  4301              ORRS     r1,r1,r0              ;1172
00034e  e000              B        |L1.850|
                  |L1.848|
000350  4381              BICS     r1,r1,r0
                  |L1.850|
000352  6151              STR      r1,[r2,#0x14]         ;1172
;;;1177     }
;;;1178   }
000354  4770              BX       lr
;;;1179   
                          ENDP

                  RCC_APB2PeriphClockCmd PROC
;;;1199     */
;;;1200   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000356  4a22              LDR      r2,|L1.992|
;;;1201   {
;;;1202     /* Check the parameters */
;;;1203     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1204     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1205   
;;;1206     if (NewState != DISABLE)
000358  2900              CMP      r1,#0
;;;1207     {
;;;1208       RCC->APB2ENR |= RCC_APB2Periph;
;;;1209     }
;;;1210     else
;;;1211     {
;;;1212       RCC->APB2ENR &= ~RCC_APB2Periph;
00035a  6991              LDR      r1,[r2,#0x18]
00035c  d001              BEQ      |L1.866|
00035e  4301              ORRS     r1,r1,r0              ;1208
000360  e000              B        |L1.868|
                  |L1.866|
000362  4381              BICS     r1,r1,r0
                  |L1.868|
000364  6191              STR      r1,[r2,#0x18]         ;1208
;;;1213     }
;;;1214   }
000366  4770              BX       lr
;;;1215   
                          ENDP

                  RCC_APB1PeriphClockCmd PROC
;;;1238     */
;;;1239   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000368  4a1d              LDR      r2,|L1.992|
;;;1240   {
;;;1241     /* Check the parameters */
;;;1242     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1243     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1244   
;;;1245     if (NewState != DISABLE)
00036a  2900              CMP      r1,#0
;;;1246     {
;;;1247       RCC->APB1ENR |= RCC_APB1Periph;
;;;1248     }
;;;1249     else
;;;1250     {
;;;1251       RCC->APB1ENR &= ~RCC_APB1Periph;
00036c  69d1              LDR      r1,[r2,#0x1c]
00036e  d001              BEQ      |L1.884|
000370  4301              ORRS     r1,r1,r0              ;1247
000372  e000              B        |L1.886|
                  |L1.884|
000374  4381              BICS     r1,r1,r0
                  |L1.886|
000376  61d1              STR      r1,[r2,#0x1c]         ;1247
;;;1252     }
;;;1253   }
000378  4770              BX       lr
;;;1254   
                          ENDP

                  RCC_AHBPeriphResetCmd PROC
;;;1268     */
;;;1269   void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
00037a  4a19              LDR      r2,|L1.992|
;;;1270   {
;;;1271     /* Check the parameters */
;;;1272     assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
;;;1273     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1274   
;;;1275     if (NewState != DISABLE)
00037c  2900              CMP      r1,#0
;;;1276     {
;;;1277       RCC->AHBRSTR |= RCC_AHBPeriph;
;;;1278     }
;;;1279     else
;;;1280     {
;;;1281       RCC->AHBRSTR &= ~RCC_AHBPeriph;
00037e  6a91              LDR      r1,[r2,#0x28]
000380  d001              BEQ      |L1.902|
000382  4301              ORRS     r1,r1,r0              ;1277
000384  e000              B        |L1.904|
                  |L1.902|
000386  4381              BICS     r1,r1,r0
                  |L1.904|
000388  6291              STR      r1,[r2,#0x28]         ;1277
;;;1282     }
;;;1283   }
00038a  4770              BX       lr
;;;1284   
                          ENDP

                  RCC_APB2PeriphResetCmd PROC
;;;1301     */
;;;1302   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
00038c  4a14              LDR      r2,|L1.992|
;;;1303   {
;;;1304     /* Check the parameters */
;;;1305     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1306     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1307   
;;;1308     if (NewState != DISABLE)
00038e  2900              CMP      r1,#0
;;;1309     {
;;;1310       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1311     }
;;;1312     else
;;;1313     {
;;;1314       RCC->APB2RSTR &= ~RCC_APB2Periph;
000390  68d1              LDR      r1,[r2,#0xc]
000392  d001              BEQ      |L1.920|
000394  4301              ORRS     r1,r1,r0              ;1310
000396  e000              B        |L1.922|
                  |L1.920|
000398  4381              BICS     r1,r1,r0
                  |L1.922|
00039a  60d1              STR      r1,[r2,#0xc]          ;1310
;;;1315     }
;;;1316   }
00039c  4770              BX       lr
;;;1317   
                          ENDP

                  RCC_APB1PeriphResetCmd PROC
;;;1337     */
;;;1338   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
00039e  4a10              LDR      r2,|L1.992|
;;;1339   {
;;;1340     /* Check the parameters */
;;;1341     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1342     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1343   
;;;1344     if (NewState != DISABLE)
0003a0  2900              CMP      r1,#0
;;;1345     {
;;;1346       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1347     }
;;;1348     else
;;;1349     {
;;;1350       RCC->APB1RSTR &= ~RCC_APB1Periph;
0003a2  6911              LDR      r1,[r2,#0x10]
0003a4  d001              BEQ      |L1.938|
0003a6  4301              ORRS     r1,r1,r0              ;1346
0003a8  e000              B        |L1.940|
                  |L1.938|
0003aa  4381              BICS     r1,r1,r0
                  |L1.940|
0003ac  6111              STR      r1,[r2,#0x10]         ;1346
;;;1351     }
;;;1352   }
0003ae  4770              BX       lr
;;;1353   
                          ENDP

                  RCC_ITConfig PROC
;;;1388     */
;;;1389   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
0003b0  4a0b              LDR      r2,|L1.992|
;;;1390   {
;;;1391     /* Check the parameters */
;;;1392     assert_param(IS_RCC_IT(RCC_IT));
;;;1393     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1394     
;;;1395     if (NewState != DISABLE)
0003b2  2900              CMP      r1,#0
;;;1396     {
;;;1397       /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
;;;1398       *(__IO uint8_t *) CIR_BYTE1_ADDRESS |= RCC_IT;
;;;1399     }
;;;1400     else
;;;1401     {
;;;1402       /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
;;;1403       *(__IO uint8_t *) CIR_BYTE1_ADDRESS &= (uint8_t)~RCC_IT;
0003b4  7a51              LDRB     r1,[r2,#9]
0003b6  d001              BEQ      |L1.956|
0003b8  4301              ORRS     r1,r1,r0              ;1398
0003ba  e000              B        |L1.958|
                  |L1.956|
0003bc  4381              BICS     r1,r1,r0
                  |L1.958|
0003be  7251              STRB     r1,[r2,#9]            ;1398
;;;1404     }
;;;1405   }
0003c0  4770              BX       lr
;;;1406   
                          ENDP

                  RCC_ClearFlag PROC
;;;1478     */
;;;1479   void RCC_ClearFlag(void)
0003c2  4807              LDR      r0,|L1.992|
;;;1480   {
;;;1481     /* Set RMVF bit to clear the reset flags */
;;;1482     RCC->CSR |= RCC_CSR_RMVF;
0003c4  6a41              LDR      r1,[r0,#0x24]
0003c6  2201              MOVS     r2,#1
0003c8  0612              LSLS     r2,r2,#24
0003ca  4311              ORRS     r1,r1,r2
0003cc  6241              STR      r1,[r0,#0x24]
;;;1483   }
0003ce  4770              BX       lr
;;;1484   
                          ENDP

                  RCC_GetITStatus PROC
;;;1497     */
;;;1498   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
0003d0  4a03              LDR      r2,|L1.992|
;;;1499   {
0003d2  4601              MOV      r1,r0
;;;1500     ITStatus bitstatus = RESET;
;;;1501     
;;;1502     /* Check the parameters */
;;;1503     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1504     
;;;1505     /* Check the status of the specified RCC interrupt */
;;;1506     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
0003d4  6892              LDR      r2,[r2,#8]
0003d6  2000              MOVS     r0,#0                 ;1500
0003d8  420a              TST      r2,r1
0003da  d000              BEQ      |L1.990|
;;;1507     {
;;;1508       bitstatus = SET;
0003dc  2001              MOVS     r0,#1
                  |L1.990|
;;;1509     }
;;;1510     else
;;;1511     {
;;;1512       bitstatus = RESET;
;;;1513     }
;;;1514     /* Return the RCC_IT status */
;;;1515     return  bitstatus;
;;;1516   }
0003de  4770              BX       lr
                  |L1.992|
                          DCD      0x40021000
                  |L1.996|
                          DCD      0xf8ffb80c
                  |L1.1000|
                          DCD      0xfef6ffff
                  |L1.1004|
                          DCD      0x007a1200
                  |L1.1008|
                          DCD      ||.data||
                  |L1.1012|
                          DCD      0x00d59f80
                  |L1.1016|
                          DCD      0x003d0900
                  |L1.1020|
                          DCD      0x00008000
                          ENDP

                  RCC_ClearITPendingBit PROC
;;;1530     */
;;;1531   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000400  4901              LDR      r1,|L1.1032|
;;;1532   {
;;;1533     /* Check the parameters */
;;;1534     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1535     
;;;1536     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1537        pending bits */
;;;1538     *(__IO uint8_t *) CIR_BYTE2_ADDRESS = RCC_IT;
000402  7288              STRB     r0,[r1,#0xa]
;;;1539   }
000404  e7eb              B        |L1.990|
;;;1540   
                          ENDP

000406  0000              DCW      0x0000
                  |L1.1032|
                          DCD      0x40021000

                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\arch\\arm\\stm32f05x\\lib\\src\\stm32f0xx_rcc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_rcc_c_49e27980____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f0xx_rcc_c_49e27980____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_rcc_c_49e27980____REVSH|
#line 144
|__asm___15_stm32f0xx_rcc_c_49e27980____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
