; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\stm32f0xx_usart.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f0xx_usart.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\stm32f0xx_usart.crf ..\arch\arm\stm32f05x\lib\src\stm32f0xx_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;171      */
;;;172    void USART_DeInit(USART_TypeDef* USARTx)
000000  49f8              LDR      r1,|L1.996|
;;;173    {
000002  b510              PUSH     {r4,lr}
;;;174      /* Check the parameters */
;;;175      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;176    
;;;177      if (USARTx == USART1)
000004  4288              CMP      r0,r1
000006  d109              BNE      |L1.28|
;;;178      {
;;;179        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  038c              LSLS     r4,r1,#14
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;180        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000012  2100              MOVS     r1,#0
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L1.26|
;;;181      }
;;;182      else 
;;;183      {
;;;184        if  (USARTx == USART2)
;;;185        {
;;;186          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
;;;187          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
;;;188        }
;;;189      }
;;;190    }
00001a  bd10              POP      {r4,pc}
                  |L1.28|
00001c  49f2              LDR      r1,|L1.1000|
00001e  4288              CMP      r0,r1                 ;184
000020  d1fb              BNE      |L1.26|
000022  2101              MOVS     r1,#1                 ;186
000024  044c              LSLS     r4,r1,#17             ;186
000026  4620              MOV      r0,r4                 ;186
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
00002c  2100              MOVS     r1,#0                 ;187
00002e  4620              MOV      r0,r4                 ;187
000030  f7fffffe          BL       RCC_APB1PeriphResetCmd
000034  bd10              POP      {r4,pc}
;;;191    
                          ENDP

                  USART_Init PROC
;;;199      */
;;;200    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000036  b570              PUSH     {r4-r6,lr}
;;;201    {
000038  4604              MOV      r4,r0
;;;202      uint32_t tmpreg = 0, apbclock = 0;
;;;203      uint32_t integerdivider = 0;
;;;204      uint32_t fractionaldivider = 0;
;;;205      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;206    
;;;207      /* Check the parameters */
;;;208      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;209      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;210      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;211      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;212      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;213      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;214      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;215      
;;;216      /* Disable USART */
;;;217      USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
00003a  6800              LDR      r0,[r0,#0]
00003c  b088              SUB      sp,sp,#0x20           ;201
00003e  460d              MOV      r5,r1                 ;201
000040  0840              LSRS     r0,r0,#1
000042  0040              LSLS     r0,r0,#1
000044  6020              STR      r0,[r4,#0]
;;;218      
;;;219    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;220      tmpreg = USARTx->CR2;
000046  6860              LDR      r0,[r4,#4]
;;;221      /* Clear STOP[13:12] bits */
;;;222      tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
000048  2103              MOVS     r1,#3
00004a  0309              LSLS     r1,r1,#12
00004c  4388              BICS     r0,r0,r1
;;;223    
;;;224      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;225      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;226      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
00004e  68a9              LDR      r1,[r5,#8]
000050  4301              ORRS     r1,r1,r0
;;;227      
;;;228      /* Write to USART CR2 */
;;;229      USARTx->CR2 = tmpreg;
000052  6061              STR      r1,[r4,#4]
;;;230    
;;;231    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;232      tmpreg = USARTx->CR1;
000054  6820              LDR      r0,[r4,#0]
;;;233      /* Clear M, PCE, PS, TE and RE bits */
;;;234      tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
000056  49e5              LDR      r1,|L1.1004|
;;;235    
;;;236      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;237      /* Set the M bits according to USART_WordLength value */
;;;238      /* Set PCE and PS bits according to USART_Parity value */
;;;239      /* Set TE and RE bits according to USART_Mode value */
;;;240      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
000058  68ea              LDR      r2,[r5,#0xc]
00005a  4008              ANDS     r0,r0,r1              ;234
00005c  6869              LDR      r1,[r5,#4]
00005e  4311              ORRS     r1,r1,r2
000060  692a              LDR      r2,[r5,#0x10]
000062  4302              ORRS     r2,r2,r0
000064  4311              ORRS     r1,r1,r2
;;;241                USART_InitStruct->USART_Mode;
;;;242    
;;;243      /* Write to USART CR1 */
;;;244      USARTx->CR1 = tmpreg;
000066  6021              STR      r1,[r4,#0]
;;;245    
;;;246    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;247      tmpreg = USARTx->CR3;
000068  68a0              LDR      r0,[r4,#8]
;;;248      /* Clear CTSE and RTSE bits */
;;;249      tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
00006a  2103              MOVS     r1,#3
00006c  0209              LSLS     r1,r1,#8
00006e  4388              BICS     r0,r0,r1
;;;250    
;;;251      /* Configure the USART HFC -------------------------------------------------*/
;;;252      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;253      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000070  6969              LDR      r1,[r5,#0x14]
000072  4301              ORRS     r1,r1,r0
;;;254    
;;;255      /* Write to USART CR3 */
;;;256      USARTx->CR3 = tmpreg;
000074  60a1              STR      r1,[r4,#8]
;;;257    
;;;258    /*---------------------------- USART BRR Configuration -----------------------*/
;;;259      /* Configure the USART Baud Rate -------------------------------------------*/
;;;260      RCC_GetClocksFreq(&RCC_ClocksStatus);
000076  4668              MOV      r0,sp
000078  f7fffffe          BL       RCC_GetClocksFreq
;;;261      
;;;262      if (USARTx == USART1)
00007c  48d9              LDR      r0,|L1.996|
00007e  4284              CMP      r4,r0
000080  d101              BNE      |L1.134|
;;;263      {
;;;264        apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
000082  9806              LDR      r0,[sp,#0x18]
000084  e000              B        |L1.136|
                  |L1.134|
;;;265      }
;;;266      else
;;;267      {
;;;268        apbclock = RCC_ClocksStatus.PCLK_Frequency;
000086  9802              LDR      r0,[sp,#8]
                  |L1.136|
;;;269      }
;;;270      /* Determine the integer part */
;;;271      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
000088  6821              LDR      r1,[r4,#0]
00008a  0409              LSLS     r1,r1,#16
00008c  6829              LDR      r1,[r5,#0]
00008e  d501              BPL      |L1.148|
;;;272      {
;;;273        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;274        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
000090  0049              LSLS     r1,r1,#1
000092  e000              B        |L1.150|
                  |L1.148|
;;;275      }
;;;276      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;277      {
;;;278        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;279        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
000094  0089              LSLS     r1,r1,#2
                  |L1.150|
000096  2219              MOVS     r2,#0x19
000098  4350              MULS     r0,r2,r0
00009a  f7fffffe          BL       __aeabi_uidivmod
00009e  4606              MOV      r6,r0
;;;280      }
;;;281      tmpreg = (integerdivider / 100) << 4;
0000a0  2164              MOVS     r1,#0x64
0000a2  f7fffffe          BL       __aeabi_uidivmod
0000a6  0105              LSLS     r5,r0,#4
;;;282    
;;;283      /* Determine the fractional part */
;;;284      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
0000a8  0928              LSRS     r0,r5,#4
0000aa  2164              MOVS     r1,#0x64
0000ac  4348              MULS     r0,r1,r0
;;;285    
;;;286      /* Implement the fractional part in the register */
;;;287      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
0000ae  6821              LDR      r1,[r4,#0]
0000b0  1a30              SUBS     r0,r6,r0              ;284
0000b2  0409              LSLS     r1,r1,#16
0000b4  d507              BPL      |L1.198|
;;;288      {
;;;289        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
0000b6  00c0              LSLS     r0,r0,#3
0000b8  3032              ADDS     r0,r0,#0x32
0000ba  2164              MOVS     r1,#0x64
0000bc  f7fffffe          BL       __aeabi_uidivmod
0000c0  0740              LSLS     r0,r0,#29
0000c2  0f40              LSRS     r0,r0,#29
0000c4  e006              B        |L1.212|
                  |L1.198|
;;;290      }
;;;291      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;292      {
;;;293        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
0000c6  0100              LSLS     r0,r0,#4
0000c8  3032              ADDS     r0,r0,#0x32
0000ca  2164              MOVS     r1,#0x64
0000cc  f7fffffe          BL       __aeabi_uidivmod
0000d0  0700              LSLS     r0,r0,#28
0000d2  0f00              LSRS     r0,r0,#28
                  |L1.212|
0000d4  4328              ORRS     r0,r0,r5
;;;294      }
;;;295     
;;;296      /* Write to USART BRR */
;;;297      USARTx->BRR = (uint16_t)tmpreg;
0000d6  81a0              STRH     r0,[r4,#0xc]
;;;298    }
0000d8  b008              ADD      sp,sp,#0x20
0000da  bd70              POP      {r4-r6,pc}
;;;299    
                          ENDP

                  USART_StructInit PROC
;;;305      */
;;;306    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
0000dc  214b              MOVS     r1,#0x4b
;;;307    {
;;;308      /* USART_InitStruct members default value */
;;;309      USART_InitStruct->USART_BaudRate = 9600;
0000de  01c9              LSLS     r1,r1,#7
;;;310      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
0000e0  6001              STR      r1,[r0,#0]
0000e2  2100              MOVS     r1,#0
;;;311      USART_InitStruct->USART_StopBits = USART_StopBits_1;
0000e4  6041              STR      r1,[r0,#4]
;;;312      USART_InitStruct->USART_Parity = USART_Parity_No ;
0000e6  6081              STR      r1,[r0,#8]
;;;313      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0000e8  220c              MOVS     r2,#0xc
;;;314      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
0000ea  60c1              STR      r1,[r0,#0xc]
0000ec  6102              STR      r2,[r0,#0x10]
0000ee  6141              STR      r1,[r0,#0x14]
;;;315    }
0000f0  4770              BX       lr
;;;316    
                          ENDP

                  USART_ClockInit PROC
;;;325      */
;;;326    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
0000f2  b510              PUSH     {r4,lr}
;;;327    {
;;;328      uint32_t tmpreg = 0;
;;;329      /* Check the parameters */
;;;330      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;331      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;332      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;333      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;334      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;335    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;336      tmpreg = USARTx->CR2;
0000f4  6843              LDR      r3,[r0,#4]
;;;337      /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
;;;338      tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
0000f6  220f              MOVS     r2,#0xf
0000f8  0212              LSLS     r2,r2,#8
0000fa  4393              BICS     r3,r3,r2
;;;339      /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
;;;340      /* Set CLKEN bit according to USART_Clock value */
;;;341      /* Set CPOL bit according to USART_CPOL value */
;;;342      /* Set CPHA bit according to USART_CPHA value */
;;;343      /* Set LBCL bit according to USART_LastBit value */
;;;344      tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
0000fc  684c              LDR      r4,[r1,#4]
0000fe  680a              LDR      r2,[r1,#0]
000100  4322              ORRS     r2,r2,r4
000102  688c              LDR      r4,[r1,#8]
000104  68c9              LDR      r1,[r1,#0xc]
000106  430c              ORRS     r4,r4,r1
000108  4322              ORRS     r2,r2,r4
00010a  431a              ORRS     r2,r2,r3
;;;345                           USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit);
;;;346      /* Write to USART CR2 */
;;;347      USARTx->CR2 = tmpreg;
00010c  6042              STR      r2,[r0,#4]
;;;348    }
00010e  bd10              POP      {r4,pc}
;;;349    
                          ENDP

                  USART_ClockStructInit PROC
;;;355      */
;;;356    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000110  2100              MOVS     r1,#0
;;;357    {
;;;358      /* USART_ClockInitStruct members default value */
;;;359      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
;;;360      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000112  6001              STR      r1,[r0,#0]
;;;361      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000114  6041              STR      r1,[r0,#4]
;;;362      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000116  6081              STR      r1,[r0,#8]
000118  60c1              STR      r1,[r0,#0xc]
;;;363    }
00011a  4770              BX       lr
;;;364    
                          ENDP

                  USART_Cmd PROC
;;;371      */
;;;372    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
00011c  2900              CMP      r1,#0
;;;373    {
;;;374      /* Check the parameters */
;;;375      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;376      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;377      
;;;378      if (NewState != DISABLE)
;;;379      {
;;;380        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;381        USARTx->CR1 |= USART_CR1_UE;
;;;382      }
;;;383      else
;;;384      {
;;;385        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;386        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
00011e  6801              LDR      r1,[r0,#0]
000120  d002              BEQ      |L1.296|
000122  2201              MOVS     r2,#1                 ;381
000124  4311              ORRS     r1,r1,r2              ;381
000126  e001              B        |L1.300|
                  |L1.296|
000128  0849              LSRS     r1,r1,#1
00012a  0049              LSLS     r1,r1,#1
                  |L1.300|
00012c  6001              STR      r1,[r0,#0]            ;381
;;;387      }
;;;388    }
00012e  4770              BX       lr
;;;389    
                          ENDP

                  USART_DirectionModeCmd PROC
;;;400      */
;;;401    void USART_DirectionModeCmd(USART_TypeDef* USARTx, uint32_t USART_DirectionMode, FunctionalState NewState)
000130  2a00              CMP      r2,#0
;;;402    {
;;;403      /* Check the parameters */
;;;404      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;405      assert_param(IS_USART_MODE(USART_DirectionMode));
;;;406      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;407    
;;;408      if (NewState != DISABLE)
;;;409      {
;;;410        /* Enable the USART's transfer interface by setting the TE and/or RE bits 
;;;411           in the USART CR1 register */
;;;412        USARTx->CR1 |= USART_DirectionMode;
;;;413      }
;;;414      else
;;;415      {
;;;416        /* Disable the USART's transfer interface by clearing the TE and/or RE bits
;;;417           in the USART CR3 register */
;;;418        USARTx->CR1 &= (uint32_t)~USART_DirectionMode;
000132  6802              LDR      r2,[r0,#0]
000134  d001              BEQ      |L1.314|
000136  430a              ORRS     r2,r2,r1              ;412
000138  e000              B        |L1.316|
                  |L1.314|
00013a  438a              BICS     r2,r2,r1
                  |L1.316|
00013c  6002              STR      r2,[r0,#0]            ;412
;;;419      }
;;;420    }
00013e  4770              BX       lr
;;;421    
                          ENDP

                  USART_OverSampling8Cmd PROC
;;;431      */
;;;432    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000140  2201              MOVS     r2,#1
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;436      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;437      
;;;438      if (NewState != DISABLE)
;;;439      {
;;;440        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;441        USARTx->CR1 |= USART_CR1_OVER8;
000142  03d2              LSLS     r2,r2,#15
000144  2900              CMP      r1,#0                 ;438
;;;442      }
;;;443      else
;;;444      {
;;;445        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;446        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_OVER8);
000146  6801              LDR      r1,[r0,#0]
000148  d001              BEQ      |L1.334|
00014a  4311              ORRS     r1,r1,r2              ;441
00014c  e000              B        |L1.336|
                  |L1.334|
00014e  4391              BICS     r1,r1,r2
                  |L1.336|
000150  6001              STR      r1,[r0,#0]            ;441
;;;447      }
;;;448    }  
000152  4770              BX       lr
;;;449    
                          ENDP

                  USART_OneBitMethodCmd PROC
;;;458      */
;;;459    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000154  2201              MOVS     r2,#1
;;;460    {
;;;461      /* Check the parameters */
;;;462      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;463      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;464      
;;;465      if (NewState != DISABLE)
;;;466      {
;;;467        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;468        USARTx->CR3 |= USART_CR3_ONEBIT;
000156  02d2              LSLS     r2,r2,#11
000158  2900              CMP      r1,#0                 ;465
;;;469      }
;;;470      else
;;;471      {
;;;472        /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
;;;473        USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT);
00015a  6881              LDR      r1,[r0,#8]
00015c  d001              BEQ      |L1.354|
00015e  4311              ORRS     r1,r1,r2              ;468
000160  e000              B        |L1.356|
                  |L1.354|
000162  4391              BICS     r1,r1,r2
                  |L1.356|
000164  6081              STR      r1,[r0,#8]            ;468
;;;474      }
;;;475    }
000166  4770              BX       lr
;;;476    
                          ENDP

                  USART_MSBFirstCmd PROC
;;;487      */
;;;488    void USART_MSBFirstCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000168  2201              MOVS     r2,#1
;;;489    {
;;;490      /* Check the parameters */
;;;491      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;492      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;493      
;;;494      if (NewState != DISABLE)
;;;495      {
;;;496        /* Enable the most significant bit first transmitted/received following the 
;;;497           start bit by setting the MSBFIRST bit in the CR2 register */
;;;498        USARTx->CR2 |= USART_CR2_MSBFIRST;
00016a  04d2              LSLS     r2,r2,#19
00016c  2900              CMP      r1,#0                 ;494
;;;499      }
;;;500      else
;;;501      {
;;;502        /* Disable the most significant bit first transmitted/received following the 
;;;503           start bit by clearing the MSBFIRST bit in the CR2 register */
;;;504        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_MSBFIRST);
00016e  6841              LDR      r1,[r0,#4]
000170  d001              BEQ      |L1.374|
000172  4311              ORRS     r1,r1,r2              ;498
000174  e000              B        |L1.376|
                  |L1.374|
000176  4391              BICS     r1,r1,r2
                  |L1.376|
000178  6041              STR      r1,[r0,#4]            ;498
;;;505      }
;;;506    }
00017a  4770              BX       lr
;;;507    
                          ENDP

                  USART_DataInvCmd PROC
;;;520      */
;;;521    void USART_DataInvCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00017c  2201              MOVS     r2,#1
;;;522    {
;;;523      /* Check the parameters */
;;;524      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;525      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;526    
;;;527      if (NewState != DISABLE)
;;;528      {
;;;529        /* Enable the binary data inversion feature by setting the DATAINV bit in 
;;;530           the CR2 register */
;;;531        USARTx->CR2 |= USART_CR2_DATAINV;
00017e  0492              LSLS     r2,r2,#18
000180  2900              CMP      r1,#0                 ;527
;;;532      }
;;;533      else
;;;534      {
;;;535        /* Disable the binary data inversion feature by clearing the DATAINV bit in 
;;;536           the CR2 register */
;;;537        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_DATAINV);
000182  6841              LDR      r1,[r0,#4]
000184  d001              BEQ      |L1.394|
000186  4311              ORRS     r1,r1,r2              ;531
000188  e000              B        |L1.396|
                  |L1.394|
00018a  4391              BICS     r1,r1,r2
                  |L1.396|
00018c  6041              STR      r1,[r0,#4]            ;531
;;;538      }
;;;539    }
00018e  4770              BX       lr
;;;540    
                          ENDP

                  USART_InvPinCmd PROC
;;;555      */
;;;556    void USART_InvPinCmd(USART_TypeDef* USARTx, uint32_t USART_InvPin, FunctionalState NewState)
000190  2a00              CMP      r2,#0
;;;557    {
;;;558      /* Check the parameters */
;;;559      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;560      assert_param(IS_USART_INVERSTION_PIN(USART_InvPin));  
;;;561      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;562    
;;;563      if (NewState != DISABLE)
;;;564      {
;;;565        /* Enable the active level inversion for selected pins by setting the TXINV 
;;;566           and/or RXINV bits in the USART CR2 register */
;;;567        USARTx->CR2 |= USART_InvPin;
;;;568      }
;;;569      else
;;;570      {
;;;571        /* Disable the active level inversion for selected requests by clearing the 
;;;572           TXINV and/or RXINV bits in the USART CR2 register */
;;;573        USARTx->CR2 &= (uint32_t)~USART_InvPin;
000192  6842              LDR      r2,[r0,#4]
000194  d001              BEQ      |L1.410|
000196  430a              ORRS     r2,r2,r1              ;567
000198  e000              B        |L1.412|
                  |L1.410|
00019a  438a              BICS     r2,r2,r1
                  |L1.412|
00019c  6042              STR      r2,[r0,#4]            ;567
;;;574      }
;;;575    }
00019e  4770              BX       lr
;;;576    
                          ENDP

                  USART_SWAPPinCmd PROC
;;;587      */
;;;588    void USART_SWAPPinCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0001a0  2201              MOVS     r2,#1
;;;589    {
;;;590      /* Check the parameters */
;;;591      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;592      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;593    
;;;594      if (NewState != DISABLE)
;;;595      {
;;;596        /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
;;;597        USARTx->CR2 |= USART_CR2_SWAP;
0001a2  03d2              LSLS     r2,r2,#15
0001a4  2900              CMP      r1,#0                 ;594
;;;598      }
;;;599      else
;;;600      {
;;;601        /* Disable the SWAP feature by clearing the SWAP bit in the CR2 register */
;;;602        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_SWAP);
0001a6  6841              LDR      r1,[r0,#4]
0001a8  d001              BEQ      |L1.430|
0001aa  4311              ORRS     r1,r1,r2              ;597
0001ac  e000              B        |L1.432|
                  |L1.430|
0001ae  4391              BICS     r1,r1,r2
                  |L1.432|
0001b0  6041              STR      r1,[r0,#4]            ;597
;;;603      }
;;;604    }
0001b2  4770              BX       lr
;;;605    
                          ENDP

                  USART_ReceiverTimeOutCmd PROC
;;;612      */
;;;613    void USART_ReceiverTimeOutCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0001b4  2201              MOVS     r2,#1
;;;614    {
;;;615      /* Check the parameters */
;;;616      assert_param(IS_USART_1_PERIPH(USARTx));
;;;617      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;618    
;;;619      if (NewState != DISABLE)
;;;620      {
;;;621        /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
;;;622           register */
;;;623        USARTx->CR2 |= USART_CR2_RTOEN;
0001b6  05d2              LSLS     r2,r2,#23
0001b8  2900              CMP      r1,#0                 ;619
;;;624      }
;;;625      else
;;;626      {
;;;627        /* Disable the receiver time out feature by clearing the RTOEN bit in the CR2 
;;;628           register */
;;;629        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_RTOEN);
0001ba  6841              LDR      r1,[r0,#4]
0001bc  d001              BEQ      |L1.450|
0001be  4311              ORRS     r1,r1,r2              ;623
0001c0  e000              B        |L1.452|
                  |L1.450|
0001c2  4391              BICS     r1,r1,r2
                  |L1.452|
0001c4  6041              STR      r1,[r0,#4]            ;623
;;;630      }
;;;631    }
0001c6  4770              BX       lr
;;;632    
                          ENDP

                  USART_SetReceiverTimeOut PROC
;;;638      */
;;;639    void USART_SetReceiverTimeOut(USART_TypeDef* USARTx, uint32_t USART_ReceiverTimeOut)
0001c8  6942              LDR      r2,[r0,#0x14]
;;;640    {    
;;;641      /* Check the parameters */
;;;642      assert_param(IS_USART_1_PERIPH(USARTx));
;;;643      assert_param(IS_USART_TIMEOUT(USART_ReceiverTimeOut));
;;;644    
;;;645      /* Clear the receiver Time Out value by clearing the RTO[23:0] bits in the RTOR
;;;646         register  */
;;;647      USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_RTO);
0001ca  0e12              LSRS     r2,r2,#24
0001cc  0612              LSLS     r2,r2,#24
0001ce  6142              STR      r2,[r0,#0x14]
;;;648      /* Set the receiver Time Out value by setting the RTO[23:0] bits in the RTOR
;;;649         register  */
;;;650      USARTx->RTOR |= USART_ReceiverTimeOut;
0001d0  6942              LDR      r2,[r0,#0x14]
0001d2  430a              ORRS     r2,r2,r1
0001d4  6142              STR      r2,[r0,#0x14]
;;;651    }
0001d6  4770              BX       lr
;;;652    
                          ENDP

                  USART_SetPrescaler PROC
;;;660      */
;;;661    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
0001d8  8a02              LDRH     r2,[r0,#0x10]
;;;662    { 
;;;663      /* Check the parameters */
;;;664      assert_param(IS_USART_1_PERIPH(USARTx));
;;;665      
;;;666      /* Clear the USART prescaler */
;;;667      USARTx->GTPR &= USART_GTPR_GT;
0001da  0a12              LSRS     r2,r2,#8
0001dc  0212              LSLS     r2,r2,#8
0001de  8202              STRH     r2,[r0,#0x10]
;;;668      /* Set the USART prescaler */
;;;669      USARTx->GTPR |= USART_Prescaler;
0001e0  8a02              LDRH     r2,[r0,#0x10]
0001e2  430a              ORRS     r2,r2,r1
0001e4  8202              STRH     r2,[r0,#0x10]
;;;670    }
0001e6  4770              BX       lr
;;;671    
                          ENDP

                  USART_STOPModeCmd PROC
;;;708      */
;;;709    void USART_STOPModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0001e8  2202              MOVS     r2,#2
;;;710    {
;;;711      /* Check the parameters */
;;;712      assert_param(IS_USART_1_PERIPH(USARTx));
;;;713      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;714      
;;;715      if (NewState != DISABLE)
0001ea  2900              CMP      r1,#0
;;;716      {
;;;717        /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
;;;718           register */
;;;719        USARTx->CR1 |= USART_CR1_UESM;
;;;720      }
;;;721      else
;;;722      {
;;;723        /* Disable the selected USART in STOP mode by clearing the UE bit in the CR1
;;;724           register */
;;;725        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UESM);
0001ec  6801              LDR      r1,[r0,#0]
0001ee  d001              BEQ      |L1.500|
0001f0  4311              ORRS     r1,r1,r2              ;719
0001f2  e000              B        |L1.502|
                  |L1.500|
0001f4  4391              BICS     r1,r1,r2
                  |L1.502|
0001f6  6001              STR      r1,[r0,#0]            ;719
;;;726      }
;;;727    }
0001f8  4770              BX       lr
;;;728    
                          ENDP

                  USART_StopModeWakeUpSourceConfig PROC
;;;740      */
;;;741    void USART_StopModeWakeUpSourceConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUpSource)
0001fa  6882              LDR      r2,[r0,#8]
;;;742    {
;;;743      /* Check the parameters */
;;;744      assert_param(IS_USART_1_PERIPH(USARTx));
;;;745      assert_param(IS_USART_STOPMODE_WAKEUPSOURCE(USART_WakeUpSource));
;;;746    
;;;747      USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_WUS);
0001fc  2303              MOVS     r3,#3
0001fe  051b              LSLS     r3,r3,#20
000200  439a              BICS     r2,r2,r3
000202  6082              STR      r2,[r0,#8]
;;;748      USARTx->CR3 |= USART_WakeUpSource;
000204  6882              LDR      r2,[r0,#8]
000206  430a              ORRS     r2,r2,r1
000208  6082              STR      r2,[r0,#8]
;;;749    }
00020a  4770              BX       lr
;;;750    
                          ENDP

                  USART_AutoBaudRateCmd PROC
;;;790      */
;;;791    void USART_AutoBaudRateCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00020c  2201              MOVS     r2,#1
;;;792    {
;;;793      /* Check the parameters */
;;;794      assert_param(IS_USART_1_PERIPH(USARTx));
;;;795      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;796    
;;;797      if (NewState != DISABLE)
;;;798      {
;;;799        /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
;;;800           register */
;;;801        USARTx->CR2 |= USART_CR2_ABREN;
00020e  0512              LSLS     r2,r2,#20
000210  2900              CMP      r1,#0                 ;797
;;;802      }
;;;803      else
;;;804      {
;;;805        /* Disable the auto baud rate feature by clearing the ABREN bit in the CR2 
;;;806           register */
;;;807        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABREN);
000212  6841              LDR      r1,[r0,#4]
000214  d001              BEQ      |L1.538|
000216  4311              ORRS     r1,r1,r2              ;801
000218  e000              B        |L1.540|
                  |L1.538|
00021a  4391              BICS     r1,r1,r2
                  |L1.540|
00021c  6041              STR      r1,[r0,#4]            ;801
;;;808      }
;;;809    }
00021e  4770              BX       lr
;;;810    
                          ENDP

                  USART_AutoBaudRateConfig PROC
;;;821      */
;;;822    void USART_AutoBaudRateConfig(USART_TypeDef* USARTx, uint32_t USART_AutoBaudRate)
000220  6842              LDR      r2,[r0,#4]
;;;823    {
;;;824      /* Check the parameters */
;;;825      assert_param(IS_USART_1_PERIPH(USARTx));
;;;826      assert_param(IS_USART_AUTOBAUDRATE_MODE(USART_AutoBaudRate));
;;;827    
;;;828      USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABRMODE);
000222  2303              MOVS     r3,#3
000224  055b              LSLS     r3,r3,#21
000226  439a              BICS     r2,r2,r3
000228  6042              STR      r2,[r0,#4]
;;;829      USARTx->CR2 |= USART_AutoBaudRate;
00022a  6842              LDR      r2,[r0,#4]
00022c  430a              ORRS     r2,r2,r1
00022e  6042              STR      r2,[r0,#4]
;;;830    }
000230  4770              BX       lr
;;;831    
                          ENDP

                  USART_AutoBaudRateNewRequest PROC
;;;836      */
;;;837    void USART_AutoBaudRateNewRequest(USART_TypeDef* USARTx)
000232  69c1              LDR      r1,[r0,#0x1c]
;;;838    {
;;;839      /* Check the parameters */
;;;840      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;841    
;;;842      USARTx->ISR &= (uint32_t)~((uint32_t)USART_FLAG_ABRF);
000234  2201              MOVS     r2,#1
000236  03d2              LSLS     r2,r2,#15
000238  4391              BICS     r1,r1,r2
00023a  61c1              STR      r1,[r0,#0x1c]
;;;843    }
00023c  4770              BX       lr
;;;844    
                          ENDP

                  USART_SendData PROC
;;;876      */
;;;877    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
00023e  05c9              LSLS     r1,r1,#23
;;;878    {
;;;879      /* Check the parameters */
;;;880      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;881      assert_param(IS_USART_DATA(Data)); 
;;;882        
;;;883      /* Transmit Data */
;;;884      USARTx->TDR = (Data & (uint16_t)0x01FF);
000240  0dc9              LSRS     r1,r1,#23
000242  8501              STRH     r1,[r0,#0x28]
;;;885    }
000244  4770              BX       lr
;;;886    
                          ENDP

                  USART_ReceiveData PROC
;;;891      */
;;;892    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000246  8c80              LDRH     r0,[r0,#0x24]
;;;893    {
;;;894      /* Check the parameters */
;;;895      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;896      
;;;897      /* Receive Data */
;;;898      return (uint16_t)(USARTx->RDR & (uint16_t)0x01FF);
000248  05c0              LSLS     r0,r0,#23
00024a  0dc0              LSRS     r0,r0,#23
;;;899    }
00024c  4770              BX       lr
;;;900    
                          ENDP

                  USART_SetAddress PROC
;;;940      */
;;;941    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
00024e  6842              LDR      r2,[r0,#4]
;;;942    {
;;;943      /* Check the parameters */
;;;944      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;945      
;;;946      /* Clear the USART address */
;;;947      USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
000250  0212              LSLS     r2,r2,#8
000252  0a12              LSRS     r2,r2,#8
000254  6042              STR      r2,[r0,#4]
;;;948      /* Set the USART address node */
;;;949      USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
000256  6842              LDR      r2,[r0,#4]
000258  0609              LSLS     r1,r1,#24
00025a  430a              ORRS     r2,r2,r1
00025c  6042              STR      r2,[r0,#4]
;;;950    }
00025e  4770              BX       lr
;;;951    
                          ENDP

                  USART_MuteModeCmd PROC
;;;958      */
;;;959    void USART_MuteModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000260  2201              MOVS     r2,#1
;;;960    {
;;;961      /* Check the parameters */
;;;962      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;963      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;964      
;;;965      if (NewState != DISABLE)
;;;966      {
;;;967        /* Enable the USART mute mode by setting the MME bit in the CR1 register */
;;;968        USARTx->CR1 |= USART_CR1_MME;
000262  0352              LSLS     r2,r2,#13
000264  2900              CMP      r1,#0                 ;965
;;;969      }
;;;970      else
;;;971      {
;;;972        /* Disable the USART mute mode by clearing the MME bit in the CR1 register */
;;;973        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_MME);
000266  6801              LDR      r1,[r0,#0]
000268  d001              BEQ      |L1.622|
00026a  4311              ORRS     r1,r1,r2              ;968
00026c  e000              B        |L1.624|
                  |L1.622|
00026e  4391              BICS     r1,r1,r2
                  |L1.624|
000270  6001              STR      r1,[r0,#0]            ;968
;;;974      }
;;;975    }
000272  4770              BX       lr
;;;976    
                          ENDP

                  USART_MuteModeWakeUpConfig PROC
;;;985      */
;;;986    void USART_MuteModeWakeUpConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUp)
000274  6802              LDR      r2,[r0,#0]
;;;987    {
;;;988      /* Check the parameters */
;;;989      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;990      assert_param(IS_USART_MUTEMODE_WAKEUP(USART_WakeUp));
;;;991    
;;;992      USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_WAKE);
000276  2301              MOVS     r3,#1
000278  02db              LSLS     r3,r3,#11
00027a  439a              BICS     r2,r2,r3
00027c  6002              STR      r2,[r0,#0]
;;;993      USARTx->CR1 |= USART_WakeUp;
00027e  6802              LDR      r2,[r0,#0]
000280  430a              ORRS     r2,r2,r1
000282  6002              STR      r2,[r0,#0]
;;;994    }
000284  4770              BX       lr
;;;995    
                          ENDP

                  USART_AddressDetectionConfig PROC
;;;1004     */
;;;1005   void USART_AddressDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_AddressLength)
000286  6842              LDR      r2,[r0,#4]
;;;1006   {
;;;1007     /* Check the parameters */
;;;1008     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1009     assert_param(IS_USART_ADDRESS_DETECTION(USART_AddressLength));
;;;1010   
;;;1011     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADDM7);
000288  2310              MOVS     r3,#0x10
00028a  439a              BICS     r2,r2,r3
00028c  6042              STR      r2,[r0,#4]
;;;1012     USARTx->CR2 |= USART_AddressLength;
00028e  6842              LDR      r2,[r0,#4]
000290  430a              ORRS     r2,r2,r1
000292  6042              STR      r2,[r0,#4]
;;;1013   }
000294  4770              BX       lr
;;;1014   
                          ENDP

                  USART_LINBreakDetectLengthConfig PROC
;;;1067     */
;;;1068   void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint32_t USART_LINBreakDetectLength)
000296  6842              LDR      r2,[r0,#4]
;;;1069   {
;;;1070     /* Check the parameters */
;;;1071     assert_param(IS_USART_1_PERIPH(USARTx));
;;;1072     assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;1073   
;;;1074     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LBDL);
000298  2320              MOVS     r3,#0x20
00029a  439a              BICS     r2,r2,r3
00029c  6042              STR      r2,[r0,#4]
;;;1075     USARTx->CR2 |= USART_LINBreakDetectLength;  
00029e  6842              LDR      r2,[r0,#4]
0002a0  430a              ORRS     r2,r2,r1
0002a2  6042              STR      r2,[r0,#4]
;;;1076   }
0002a4  4770              BX       lr
;;;1077   
                          ENDP

                  USART_LINCmd PROC
;;;1084     */
;;;1085   void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002a6  2201              MOVS     r2,#1
;;;1086   {
;;;1087     /* Check the parameters */
;;;1088     assert_param(IS_USART_1_PERIPH(USARTx));
;;;1089     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1090   
;;;1091     if (NewState != DISABLE)
;;;1092     {
;;;1093       /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;1094       USARTx->CR2 |= USART_CR2_LINEN;
0002a8  0392              LSLS     r2,r2,#14
0002aa  2900              CMP      r1,#0                 ;1091
;;;1095     }
;;;1096     else
;;;1097     {
;;;1098       /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;1099       USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LINEN);
0002ac  6841              LDR      r1,[r0,#4]
0002ae  d001              BEQ      |L1.692|
0002b0  4311              ORRS     r1,r1,r2              ;1094
0002b2  e000              B        |L1.694|
                  |L1.692|
0002b4  4391              BICS     r1,r1,r2
                  |L1.694|
0002b6  6041              STR      r1,[r0,#4]            ;1094
;;;1100     }
;;;1101   }
0002b8  4770              BX       lr
;;;1102   
                          ENDP

                  USART_HalfDuplexCmd PROC
;;;1140     */
;;;1141   void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002ba  2208              MOVS     r2,#8
;;;1142   {
;;;1143     /* Check the parameters */
;;;1144     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1145     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1146     
;;;1147     if (NewState != DISABLE)
0002bc  2900              CMP      r1,#0
;;;1148     {
;;;1149       /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;1150       USARTx->CR3 |= USART_CR3_HDSEL;
;;;1151     }
;;;1152     else
;;;1153     {
;;;1154       /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;1155       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_HDSEL);
0002be  6881              LDR      r1,[r0,#8]
0002c0  d001              BEQ      |L1.710|
0002c2  4311              ORRS     r1,r1,r2              ;1150
0002c4  e000              B        |L1.712|
                  |L1.710|
0002c6  4391              BICS     r1,r1,r2
                  |L1.712|
0002c8  6081              STR      r1,[r0,#8]            ;1150
;;;1156     }
;;;1157   }
0002ca  4770              BX       lr
;;;1158   
                          ENDP

                  USART_SetGuardTime PROC
;;;1220     */
;;;1221   void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
0002cc  8a02              LDRH     r2,[r0,#0x10]
;;;1222   {    
;;;1223     /* Check the parameters */
;;;1224     assert_param(IS_USART_1_PERIPH(USARTx));
;;;1225   
;;;1226     /* Clear the USART Guard time */
;;;1227     USARTx->GTPR &= USART_GTPR_PSC;
0002ce  b2d2              UXTB     r2,r2
0002d0  8202              STRH     r2,[r0,#0x10]
;;;1228     /* Set the USART guard time */
;;;1229     USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
0002d2  8a02              LDRH     r2,[r0,#0x10]
0002d4  0209              LSLS     r1,r1,#8
0002d6  430a              ORRS     r2,r2,r1
0002d8  8202              STRH     r2,[r0,#0x10]
;;;1230   }
0002da  4770              BX       lr
;;;1231   
                          ENDP

                  USART_SmartCardCmd PROC
;;;1238     */
;;;1239   void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002dc  2220              MOVS     r2,#0x20
;;;1240   {
;;;1241     /* Check the parameters */
;;;1242     assert_param(IS_USART_1_PERIPH(USARTx));
;;;1243     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1244     if (NewState != DISABLE)
0002de  2900              CMP      r1,#0
;;;1245     {
;;;1246       /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;1247       USARTx->CR3 |= USART_CR3_SCEN;
;;;1248     }
;;;1249     else
;;;1250     {
;;;1251       /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;1252       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCEN);
0002e0  6881              LDR      r1,[r0,#8]
0002e2  d001              BEQ      |L1.744|
0002e4  4311              ORRS     r1,r1,r2              ;1247
0002e6  e000              B        |L1.746|
                  |L1.744|
0002e8  4391              BICS     r1,r1,r2
                  |L1.746|
0002ea  6081              STR      r1,[r0,#8]            ;1247
;;;1253     }
;;;1254   }
0002ec  4770              BX       lr
;;;1255   
                          ENDP

                  USART_SmartCardNACKCmd PROC
;;;1262     */
;;;1263   void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002ee  2210              MOVS     r2,#0x10
;;;1264   {
;;;1265     /* Check the parameters */
;;;1266     assert_param(IS_USART_1_PERIPH(USARTx)); 
;;;1267     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1268     if (NewState != DISABLE)
0002f0  2900              CMP      r1,#0
;;;1269     {
;;;1270       /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;1271       USARTx->CR3 |= USART_CR3_NACK;
;;;1272     }
;;;1273     else
;;;1274     {
;;;1275       /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;1276       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_NACK);
0002f2  6881              LDR      r1,[r0,#8]
0002f4  d001              BEQ      |L1.762|
0002f6  4311              ORRS     r1,r1,r2              ;1271
0002f8  e000              B        |L1.764|
                  |L1.762|
0002fa  4391              BICS     r1,r1,r2
                  |L1.764|
0002fc  6081              STR      r1,[r0,#8]            ;1271
;;;1277     }
;;;1278   }
0002fe  4770              BX       lr
;;;1279   
                          ENDP

                  USART_SetAutoRetryCount PROC
;;;1285     */
;;;1286   void USART_SetAutoRetryCount(USART_TypeDef* USARTx, uint8_t USART_AutoCount)
000300  6882              LDR      r2,[r0,#8]
;;;1287   {    
;;;1288     /* Check the parameters */
;;;1289     assert_param(IS_USART_1_PERIPH(USARTx));
;;;1290     assert_param(IS_USART_AUTO_RETRY_COUNTER(USART_AutoCount));
;;;1291     /* Clear the USART auto retry count */
;;;1292     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCARCNT);
000302  2307              MOVS     r3,#7
000304  045b              LSLS     r3,r3,#17
000306  439a              BICS     r2,r2,r3
000308  6082              STR      r2,[r0,#8]
;;;1293     /* Set the USART auto retry count*/
;;;1294     USARTx->CR3 |= (uint32_t)((uint32_t)USART_AutoCount << 0x11);
00030a  6882              LDR      r2,[r0,#8]
00030c  0449              LSLS     r1,r1,#17
00030e  430a              ORRS     r2,r2,r1
000310  6082              STR      r2,[r0,#8]
;;;1295   }
000312  4770              BX       lr
;;;1296   
                          ENDP

                  USART_SetBlockLength PROC
;;;1302     */
;;;1303   void USART_SetBlockLength(USART_TypeDef* USARTx, uint8_t USART_BlockLength)
000314  6942              LDR      r2,[r0,#0x14]
;;;1304   {    
;;;1305     /* Check the parameters */
;;;1306     assert_param(IS_USART_1_PERIPH(USARTx));
;;;1307   
;;;1308     /* Clear the Smart card block length */
;;;1309     USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_BLEN);
000316  0212              LSLS     r2,r2,#8
000318  0a12              LSRS     r2,r2,#8
00031a  6142              STR      r2,[r0,#0x14]
;;;1310     /* Set the Smart Card block length */
;;;1311     USARTx->RTOR |= (uint32_t)((uint32_t)USART_BlockLength << 0x18);
00031c  6942              LDR      r2,[r0,#0x14]
00031e  0609              LSLS     r1,r1,#24
000320  430a              ORRS     r2,r2,r1
000322  6142              STR      r2,[r0,#0x14]
;;;1312   }
000324  4770              BX       lr
;;;1313   
                          ENDP

                  USART_IrDAConfig PROC
;;;1364     */
;;;1365   void USART_IrDAConfig(USART_TypeDef* USARTx, uint32_t USART_IrDAMode)
000326  6882              LDR      r2,[r0,#8]
;;;1366   {
;;;1367     /* Check the parameters */
;;;1368     assert_param(IS_USART_1_PERIPH(USARTx));
;;;1369     assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;1370   
;;;1371     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IRLP);
000328  2304              MOVS     r3,#4
00032a  439a              BICS     r2,r2,r3
00032c  6082              STR      r2,[r0,#8]
;;;1372     USARTx->CR3 |= USART_IrDAMode;
00032e  6882              LDR      r2,[r0,#8]
000330  430a              ORRS     r2,r2,r1
000332  6082              STR      r2,[r0,#8]
;;;1373   }
000334  4770              BX       lr
;;;1374   
                          ENDP

                  USART_IrDACmd PROC
;;;1381     */
;;;1382   void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000336  2202              MOVS     r2,#2
;;;1383   {
;;;1384     /* Check the parameters */
;;;1385     assert_param(IS_USART_1_PERIPH(USARTx));
;;;1386     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1387   
;;;1388     if (NewState != DISABLE)
000338  2900              CMP      r1,#0
;;;1389     {
;;;1390       /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;1391       USARTx->CR3 |= USART_CR3_IREN;
;;;1392     }
;;;1393     else
;;;1394     {
;;;1395       /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;1396       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IREN);
00033a  6881              LDR      r1,[r0,#8]
00033c  d001              BEQ      |L1.834|
00033e  4311              ORRS     r1,r1,r2              ;1391
000340  e000              B        |L1.836|
                  |L1.834|
000342  4391              BICS     r1,r1,r2
                  |L1.836|
000344  6081              STR      r1,[r0,#8]            ;1391
;;;1397     }
;;;1398   }
000346  4770              BX       lr
;;;1399   /**
                          ENDP

                  USART_DECmd PROC
;;;1438     */
;;;1439   void USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState)
000348  2201              MOVS     r2,#1
;;;1440   {
;;;1441     /* Check the parameters */
;;;1442     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1443     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1444     if (NewState != DISABLE)
;;;1445     {
;;;1446       /* Enable the DE functionality by setting the DEM bit in the CR3 register */
;;;1447       USARTx->CR3 |= USART_CR3_DEM;
00034a  0392              LSLS     r2,r2,#14
00034c  2900              CMP      r1,#0                 ;1444
;;;1448     }
;;;1449     else
;;;1450     {
;;;1451       /* Disable the DE functionality by clearing the DEM bit in the CR3 register */
;;;1452       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEM);
00034e  6881              LDR      r1,[r0,#8]
000350  d001              BEQ      |L1.854|
000352  4311              ORRS     r1,r1,r2              ;1447
000354  e000              B        |L1.856|
                  |L1.854|
000356  4391              BICS     r1,r1,r2
                  |L1.856|
000358  6081              STR      r1,[r0,#8]            ;1447
;;;1453     }
;;;1454   }
00035a  4770              BX       lr
;;;1455   
                          ENDP

                  USART_DEPolarityConfig PROC
;;;1464     */
;;;1465   void USART_DEPolarityConfig(USART_TypeDef* USARTx, uint32_t USART_DEPolarity)
00035c  6882              LDR      r2,[r0,#8]
;;;1466   {
;;;1467     /* Check the parameters */
;;;1468     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1469     assert_param(IS_USART_DE_POLARITY(USART_DEPolarity));
;;;1470   
;;;1471     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEP);
00035e  2301              MOVS     r3,#1
000360  03db              LSLS     r3,r3,#15
000362  439a              BICS     r2,r2,r3
000364  6082              STR      r2,[r0,#8]
;;;1472     USARTx->CR3 |= USART_DEPolarity;
000366  6882              LDR      r2,[r0,#8]
000368  430a              ORRS     r2,r2,r1
00036a  6082              STR      r2,[r0,#8]
;;;1473   }
00036c  4770              BX       lr
;;;1474   
                          ENDP

                  USART_SetDEAssertionTime PROC
;;;1481     */
;;;1482   void USART_SetDEAssertionTime(USART_TypeDef* USARTx, uint32_t USART_DEAssertionTime)
00036e  6802              LDR      r2,[r0,#0]
;;;1483   {
;;;1484     /* Check the parameters */
;;;1485     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1486     assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 
;;;1487   
;;;1488     /* Clear the DE assertion time */
;;;1489     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
000370  231f              MOVS     r3,#0x1f
000372  055b              LSLS     r3,r3,#21
000374  439a              BICS     r2,r2,r3
000376  6002              STR      r2,[r0,#0]
;;;1490     /* Set the new value for the DE assertion time */
;;;1491     USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
000378  6802              LDR      r2,[r0,#0]
00037a  0549              LSLS     r1,r1,#21
00037c  430a              ORRS     r2,r2,r1
00037e  6002              STR      r2,[r0,#0]
;;;1492   }
000380  4770              BX       lr
;;;1493   
                          ENDP

                  USART_SetDEDeassertionTime PROC
;;;1500     */
;;;1501   void USART_SetDEDeassertionTime(USART_TypeDef* USARTx, uint32_t USART_DEDeassertionTime)
000382  6802              LDR      r2,[r0,#0]
;;;1502   {
;;;1503     /* Check the parameters */
;;;1504     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1505     assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 
;;;1506   
;;;1507     /* Clear the DE deassertion time */
;;;1508     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
000384  231f              MOVS     r3,#0x1f
000386  041b              LSLS     r3,r3,#16
000388  439a              BICS     r2,r2,r3
00038a  6002              STR      r2,[r0,#0]
;;;1509     /* Set the new value for the DE deassertion time */
;;;1510     USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
00038c  6802              LDR      r2,[r0,#0]
00038e  0409              LSLS     r1,r1,#16
000390  430a              ORRS     r2,r2,r1
000392  6002              STR      r2,[r0,#0]
;;;1511   }
000394  4770              BX       lr
;;;1512   
                          ENDP

                  USART_DMACmd PROC
;;;1546     */
;;;1547   void USART_DMACmd(USART_TypeDef* USARTx, uint32_t USART_DMAReq, FunctionalState NewState)
000396  2a00              CMP      r2,#0
;;;1548   {
;;;1549     /* Check the parameters */
;;;1550     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1551     assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;1552     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1553   
;;;1554     if (NewState != DISABLE)
;;;1555     {
;;;1556       /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;1557          DMAR bits in the USART CR3 register */
;;;1558       USARTx->CR3 |= USART_DMAReq;
;;;1559     }
;;;1560     else
;;;1561     {
;;;1562       /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;1563          DMAR bits in the USART CR3 register */
;;;1564       USARTx->CR3 &= (uint32_t)~USART_DMAReq;
000398  6882              LDR      r2,[r0,#8]
00039a  d001              BEQ      |L1.928|
00039c  430a              ORRS     r2,r2,r1              ;1558
00039e  e000              B        |L1.930|
                  |L1.928|
0003a0  438a              BICS     r2,r2,r1
                  |L1.930|
0003a2  6082              STR      r2,[r0,#8]            ;1558
;;;1565     }
;;;1566   }
0003a4  4770              BX       lr
;;;1567   
                          ENDP

                  USART_DMAReceptionErrorConfig PROC
;;;1578     */
;;;1579   void USART_DMAReceptionErrorConfig(USART_TypeDef* USARTx, uint32_t USART_DMAOnError)
0003a6  6882              LDR      r2,[r0,#8]
;;;1580   {
;;;1581     /* Check the parameters */
;;;1582     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1583     assert_param(IS_USART_DMAONERROR(USART_DMAOnError)); 
;;;1584     
;;;1585     /* Clear the DMA Reception error detection bit */
;;;1586     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DDRE);
0003a8  2301              MOVS     r3,#1
0003aa  035b              LSLS     r3,r3,#13
0003ac  439a              BICS     r2,r2,r3
0003ae  6082              STR      r2,[r0,#8]
;;;1587     /* Set the new value for the DMA Reception error detection bit */
;;;1588     USARTx->CR3 |= USART_DMAOnError;
0003b0  6882              LDR      r2,[r0,#8]
0003b2  430a              ORRS     r2,r2,r1
0003b4  6082              STR      r2,[r0,#8]
;;;1589   }
0003b6  4770              BX       lr
;;;1590   
                          ENDP

                  USART_ITConfig PROC
;;;1710     */
;;;1711   void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
0003b8  b510              PUSH     {r4,lr}
;;;1712   {
;;;1713     uint32_t usartreg = 0, itpos = 0, itmask = 0;
;;;1714     uint32_t usartxbase = 0;
;;;1715     /* Check the parameters */
;;;1716     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1717     assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;1718     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1719     
;;;1720     usartxbase = (uint32_t)USARTx;
;;;1721     
;;;1722     /* Get the USART register index */
;;;1723     usartreg = (((uint16_t)USART_IT) >> 0x08);
0003ba  040b              LSLS     r3,r1,#16
0003bc  0e1c              LSRS     r4,r3,#24
;;;1724     
;;;1725     /* Get the interrupt position */
;;;1726     itpos = USART_IT & IT_MASK;
;;;1727     itmask = (((uint32_t)0x01) << itpos);
0003be  2301              MOVS     r3,#1
0003c0  408b              LSLS     r3,r3,r1
;;;1728     
;;;1729     if (usartreg == 0x02) /* The IT is in CR2 register */
0003c2  2c02              CMP      r4,#2
0003c4  d002              BEQ      |L1.972|
;;;1730     {
;;;1731       usartxbase += 0x04;
;;;1732     }
;;;1733     else if (usartreg == 0x03) /* The IT is in CR3 register */
0003c6  2c03              CMP      r4,#3
0003c8  d002              BEQ      |L1.976|
0003ca  e002              B        |L1.978|
                  |L1.972|
0003cc  1d00              ADDS     r0,r0,#4              ;1731
0003ce  e000              B        |L1.978|
                  |L1.976|
;;;1734     {
;;;1735       usartxbase += 0x08;
0003d0  3008              ADDS     r0,r0,#8
                  |L1.978|
;;;1736     }
;;;1737     else /* The IT is in CR1 register */
;;;1738     {
;;;1739     }
;;;1740     if (NewState != DISABLE)
;;;1741     {
;;;1742       *(__IO uint32_t*)usartxbase  |= itmask;
;;;1743     }
;;;1744     else
;;;1745     {
;;;1746       *(__IO uint32_t*)usartxbase &= ~itmask;
0003d2  6801              LDR      r1,[r0,#0]
0003d4  2a00              CMP      r2,#0                 ;1740
0003d6  d001              BEQ      |L1.988|
0003d8  4319              ORRS     r1,r1,r3              ;1742
0003da  e000              B        |L1.990|
                  |L1.988|
0003dc  4399              BICS     r1,r1,r3
                  |L1.990|
0003de  6001              STR      r1,[r0,#0]            ;1742
;;;1747     }
;;;1748   }
0003e0  bd10              POP      {r4,pc}
0003e2  0000              DCW      0x0000
                  |L1.996|
                          DCD      0x40013800
                  |L1.1000|
                          DCD      0x40004400
                  |L1.1004|
                          DCD      0xffffe9f3
                          ENDP

                  USART_RequestCmd PROC
;;;1763     */
;;;1764   void USART_RequestCmd(USART_TypeDef* USARTx, uint32_t USART_Request, FunctionalState NewState)
0003f0  2a00              CMP      r2,#0
;;;1765   {
;;;1766     /* Check the parameters */
;;;1767     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1768     assert_param(IS_USART_REQUEST(USART_Request));
;;;1769     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1770   
;;;1771     if (NewState != DISABLE)
;;;1772     {
;;;1773       /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
;;;1774          register.*/
;;;1775         USARTx->RQR |= USART_Request;
;;;1776     }
;;;1777     else
;;;1778     {
;;;1779       /* Disable the USART ReQuest by clearing the dedicated request bit in the RQR
;;;1780          register.*/
;;;1781       USARTx->RQR &= (uint32_t)~USART_Request;
0003f2  8b02              LDRH     r2,[r0,#0x18]
0003f4  d001              BEQ      |L1.1018|
0003f6  430a              ORRS     r2,r2,r1              ;1775
0003f8  e000              B        |L1.1020|
                  |L1.1018|
0003fa  438a              BICS     r2,r2,r1
                  |L1.1020|
0003fc  8302              STRH     r2,[r0,#0x18]         ;1775
;;;1782     }
;;;1783   }
0003fe  4770              BX       lr
;;;1784   
                          ENDP

                  USART_OverrunDetectionConfig PROC
;;;1795     */
;;;1796   void USART_OverrunDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_OVRDetection)
000400  6882              LDR      r2,[r0,#8]
;;;1797   {
;;;1798     /* Check the parameters */
;;;1799     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1800     assert_param(IS_USART_OVRDETECTION(USART_OVRDetection));
;;;1801     
;;;1802     /* Clear the OVR detection bit */
;;;1803     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_OVRDIS);
000402  2301              MOVS     r3,#1
000404  031b              LSLS     r3,r3,#12
000406  439a              BICS     r2,r2,r3
000408  6082              STR      r2,[r0,#8]
;;;1804     /* Set the new value for the OVR detection bit */
;;;1805     USARTx->CR3 |= USART_OVRDetection;
00040a  6882              LDR      r2,[r0,#8]
00040c  430a              ORRS     r2,r2,r1
00040e  6082              STR      r2,[r0,#8]
;;;1806   }
000410  4770              BX       lr
;;;1807   
                          ENDP

                  USART_GetFlagStatus PROC
;;;1836     */
;;;1837   FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint32_t USART_FLAG)
000412  4602              MOV      r2,r0
;;;1838   {
;;;1839     FlagStatus bitstatus = RESET;
;;;1840     /* Check the parameters */
;;;1841     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1842     assert_param(IS_USART_FLAG(USART_FLAG));
;;;1843     
;;;1844     if ((USARTx->ISR & USART_FLAG) != (uint16_t)RESET)
000414  69d2              LDR      r2,[r2,#0x1c]
000416  2000              MOVS     r0,#0                 ;1839
000418  420a              TST      r2,r1
00041a  d000              BEQ      |L1.1054|
;;;1845     {
;;;1846       bitstatus = SET;
00041c  2001              MOVS     r0,#1
                  |L1.1054|
;;;1847     }
;;;1848     else
;;;1849     {
;;;1850       bitstatus = RESET;
;;;1851     }
;;;1852     return bitstatus;
;;;1853   }
00041e  4770              BX       lr
;;;1854   
                          ENDP

                  USART_ClearFlag PROC
;;;1884     */
;;;1885   void USART_ClearFlag(USART_TypeDef* USARTx, uint32_t USART_FLAG)
000420  6201              STR      r1,[r0,#0x20]
;;;1886   {
;;;1887     /* Check the parameters */
;;;1888     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1889     assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;1890        
;;;1891     USARTx->ICR = USART_FLAG;
;;;1892   }
000422  4770              BX       lr
;;;1893   
                          ENDP

                  USART_GetITStatus PROC
;;;1914     */
;;;1915   ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT)
000424  b530              PUSH     {r4,r5,lr}
;;;1916   {
;;;1917     uint32_t bitpos = 0, itmask = 0, usartreg = 0;
;;;1918     ITStatus bitstatus = RESET;
;;;1919     /* Check the parameters */
;;;1920     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1921     assert_param(IS_USART_GET_IT(USART_IT)); 
;;;1922     
;;;1923     /* Get the USART register index */
;;;1924     usartreg = (((uint16_t)USART_IT) >> 0x08);
000426  040a              LSLS     r2,r1,#16
000428  0e13              LSRS     r3,r2,#24
;;;1925     /* Get the interrupt position */
;;;1926     itmask = USART_IT & IT_MASK;
;;;1927     itmask = (uint32_t)0x01 << itmask;
00042a  2501              MOVS     r5,#1
00042c  462a              MOV      r2,r5
00042e  2400              MOVS     r4,#0                 ;1918
000430  408a              LSLS     r2,r2,r1
;;;1928     
;;;1929     if (usartreg == 0x01) /* The IT  is in CR1 register */
000432  2b01              CMP      r3,#1
000434  d00e              BEQ      |L1.1108|
;;;1930     {
;;;1931       itmask &= USARTx->CR1;
;;;1932     }
;;;1933     else if (usartreg == 0x02) /* The IT  is in CR2 register */
000436  2b02              CMP      r3,#2
000438  d00e              BEQ      |L1.1112|
;;;1934     {
;;;1935       itmask &= USARTx->CR2;
;;;1936     }
;;;1937     else /* The IT  is in CR3 register */
;;;1938     {
;;;1939       itmask &= USARTx->CR3;
00043a  6883              LDR      r3,[r0,#8]
                  |L1.1084|
;;;1940     }
;;;1941     
;;;1942     bitpos = USART_IT >> 0x10;
00043c  0c09              LSRS     r1,r1,#16
00043e  4013              ANDS     r3,r3,r2              ;1935
;;;1943     bitpos = (uint32_t)0x01 << bitpos;
;;;1944     bitpos &= USARTx->ISR;
000440  69c0              LDR      r0,[r0,#0x1c]
000442  408d              LSLS     r5,r5,r1              ;1943
000444  4028              ANDS     r0,r0,r5
;;;1945     if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
000446  2b00              CMP      r3,#0
000448  d002              BEQ      |L1.1104|
00044a  2800              CMP      r0,#0
00044c  d000              BEQ      |L1.1104|
;;;1946     {
;;;1947       bitstatus = SET;
00044e  2401              MOVS     r4,#1
                  |L1.1104|
;;;1948     }
;;;1949     else
;;;1950     {
;;;1951       bitstatus = RESET;
;;;1952     }
;;;1953     
;;;1954     return bitstatus;  
000450  4620              MOV      r0,r4
;;;1955   }
000452  bd30              POP      {r4,r5,pc}
                  |L1.1108|
000454  6803              LDR      r3,[r0,#0]            ;1931
000456  e7f1              B        |L1.1084|
                  |L1.1112|
000458  6843              LDR      r3,[r0,#4]            ;1935
00045a  e7ef              B        |L1.1084|
;;;1956   
                          ENDP

                  USART_ClearITPendingBit PROC
;;;1985     */
;;;1986   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint32_t USART_IT)
00045c  0c09              LSRS     r1,r1,#16
;;;1987   {
;;;1988     uint32_t bitpos = 0, itmask = 0;
;;;1989     /* Check the parameters */
;;;1990     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1991     assert_param(IS_USART_CLEAR_IT(USART_IT)); 
;;;1992     
;;;1993     bitpos = USART_IT >> 0x10;
;;;1994     itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
00045e  2201              MOVS     r2,#1
000460  408a              LSLS     r2,r2,r1
;;;1995     USARTx->ICR = (uint32_t)itmask;
000462  6202              STR      r2,[r0,#0x20]
;;;1996   }
000464  4770              BX       lr
;;;1997   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\arch\\arm\\stm32f05x\\lib\\src\\stm32f0xx_usart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f0xx_usart_c_9565154b____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f0xx_usart_c_9565154b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f0xx_usart_c_9565154b____REVSH|
#line 144
|__asm___17_stm32f0xx_usart_c_9565154b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
