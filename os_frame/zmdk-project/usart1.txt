; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\usart1.o --asm_dir=.\ --list_dir=.\ --depend=.\usart1.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\usart1.crf ..\drivers\stm32f051x\char\usart\usart1.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart1_rx_indicator PROC
;;;322    extern os_err_t  calibration_rx_callback(u8 data);
;;;323    static os_err_t  uart1_rx_indicator(os_device_t* dev,os_size_t size)
000000  b510              PUSH     {r4,lr}
;;;324    {
;;;325        
;;;326        //  return  Q_Sh_rx_callback(*((char*)dev->user_data));
;;;327        return calibration_rx_callback(*((char*)dev->user_data));
000002  6b80              LDR      r0,[r0,#0x38]
000004  7800              LDRB     r0,[r0,#0]
000006  f7fffffe          BL       calibration_rx_callback
;;;328        
;;;329    }
00000a  bd10              POP      {r4,pc}
;;;330    
                          ENDP

                  uart1_write PROC
;;;283    
;;;284    static os_size_t  uart1_write(os_device_t* dev, os_off_t pos, const void *buffer, os_size_t size)
00000c  b510              PUSH     {r4,lr}
;;;285    {
;;;286        
;;;287        if(pos>=size||buffer==NULL||size>USART_TX_BUFFER_SIZE)
00000e  4299              CMP      r1,r3
000010  d203              BCS      |L1.26|
000012  2a00              CMP      r2,#0
000014  d001              BEQ      |L1.26|
000016  2b40              CMP      r3,#0x40
000018  d901              BLS      |L1.30|
                  |L1.26|
;;;288        {
;;;289            return  NULL;
00001a  2000              MOVS     r0,#0
;;;290        }else
;;;291        {
;;;292            char* temp=(char*)buffer; 
;;;293            if(pos>0)
;;;294            {
;;;295                temp=temp+pos;
;;;296            }				 
;;;297            
;;;298            while(size>0)
;;;299            {
;;;300                USART1->TDR=*(char*)temp;
;;;301                temp++;
;;;302                size--;
;;;303                while(!(USART1->ISR&(1<<7)));//Transmit data register empty
;;;304            }
;;;305        }
;;;306        
;;;307        return SUCCESS;
;;;308    }	
00001c  bd10              POP      {r4,pc}
                  |L1.30|
00001e  2900              CMP      r1,#0                 ;293
000020  d000              BEQ      |L1.36|
000022  1852              ADDS     r2,r2,r1              ;295
                  |L1.36|
000024  486f              LDR      r0,|L1.484|
000026  4c6f              LDR      r4,|L1.484|
000028  3820              SUBS     r0,r0,#0x20           ;303
                  |L1.42|
00002a  2b00              CMP      r3,#0                 ;298
00002c  d007              BEQ      |L1.62|
00002e  7811              LDRB     r1,[r2,#0]            ;300
000030  1c52              ADDS     r2,r2,#1              ;300
000032  8121              STRH     r1,[r4,#8]            ;300
000034  1e5b              SUBS     r3,r3,#1              ;302
                  |L1.54|
000036  69c1              LDR      r1,[r0,#0x1c]         ;303
000038  0609              LSLS     r1,r1,#24             ;303
00003a  d5fc              BPL      |L1.54|
00003c  e7f5              B        |L1.42|
                  |L1.62|
00003e  2001              MOVS     r0,#1                 ;307
000040  bd10              POP      {r4,pc}
;;;309    
                          ENDP

                  uart1_open PROC
;;;244     */
;;;245    static os_err_t  uart1_open(os_device_t* dev, u16 oflag)
000042  b510              PUSH     {r4,lr}
;;;246    {
;;;247        os_clock_open("USART1");
000044  a068              ADR      r0,|L1.488|
000046  f7fffffe          BL       os_clock_open
;;;248        os_clock_open("GPIOA");
00004a  a069              ADR      r0,|L1.496|
00004c  f7fffffe          BL       os_clock_open
;;;249        
;;;250        return SUCCESS;	
000050  2001              MOVS     r0,#1
;;;251    }
000052  bd10              POP      {r4,pc}
;;;252    
                          ENDP

                  uart1_init PROC
;;;106    
;;;107    os_err_t  uart1_init   (os_device_t* dev)
000054  b570              PUSH     {r4-r6,lr}
;;;108    {  	 
;;;109        
;;;110        u32 temp_1,temp_2, tmpreg;
;;;111        u32 integerdivider,fractionaldivider;	
;;;112        
;;;113        os_device_t *__mptr = (dev);
;;;114        usart_device * console_dev=(usart_device *)( (char *)__mptr - offsetof(usart_device,os_device));	
000056  4604              MOV      r4,r0
;;;115        
;;;116        
;;;117        os_clock_open("USART1");
000058  a063              ADR      r0,|L1.488|
00005a  f7fffffe          BL       os_clock_open
;;;118        if ((USART1->CR1 & USART_CR1_OVER8) != 0)
00005e  4d61              LDR      r5,|L1.484|
000060  3d20              SUBS     r5,r5,#0x20
000062  6828              LDR      r0,[r5,#0]
000064  0400              LSLS     r0,r0,#16
000066  6c60              LDR      r0,[r4,#0x44]
000068  d501              BPL      |L1.110|
;;;119        {
;;;120            /* Integer part computing in case Oversampling mode is 8 Samples */
;;;121            integerdivider = ((25 * console_dev->pclk2*1000000) / (2 * (console_dev->bound)));    
00006a  0041              LSLS     r1,r0,#1
00006c  e000              B        |L1.112|
                  |L1.110|
;;;122        }
;;;123        else /* if ((USART1->CR1 & CR1_OVER8_Set) == 0) */
;;;124        {
;;;125            /* Integer part computing in case Oversampling mode is 16 Samples */
;;;126            integerdivider = ((25 * console_dev->pclk2*1000000) / (4 * (console_dev->bound)));    
00006e  0081              LSLS     r1,r0,#2
                  |L1.112|
000070  4a61              LDR      r2,|L1.504|
000072  6c20              LDR      r0,[r4,#0x40]
000074  4350              MULS     r0,r2,r0
000076  f7fffffe          BL       __aeabi_uidivmod
00007a  4606              MOV      r6,r0
;;;127        }
;;;128        tmpreg = (integerdivider / 100) << 4;
00007c  2164              MOVS     r1,#0x64
00007e  f7fffffe          BL       __aeabi_uidivmod
000082  0104              LSLS     r4,r0,#4
;;;129        
;;;130        /* Determine the fractional part */
;;;131        fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
000084  0920              LSRS     r0,r4,#4
000086  2164              MOVS     r1,#0x64
000088  4348              MULS     r0,r1,r0
;;;132        
;;;133        /* Implement the fractional part in the register */
;;;134        if ((USART1->CR1 & USART_CR1_OVER8) != 0)
00008a  6829              LDR      r1,[r5,#0]
00008c  1a30              SUBS     r0,r6,r0              ;131
00008e  0409              LSLS     r1,r1,#16
000090  d507              BPL      |L1.162|
;;;135        {
;;;136            tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
000092  00c0              LSLS     r0,r0,#3
000094  3032              ADDS     r0,r0,#0x32
000096  2164              MOVS     r1,#0x64
000098  f7fffffe          BL       __aeabi_uidivmod
00009c  0740              LSLS     r0,r0,#29
00009e  0f40              LSRS     r0,r0,#29
0000a0  e006              B        |L1.176|
                  |L1.162|
;;;137        }
;;;138        else /* if ((USART1->CR1 & CR1_OVER8_Set) == 0) */
;;;139        {
;;;140            tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
0000a2  0100              LSLS     r0,r0,#4
0000a4  3032              ADDS     r0,r0,#0x32
0000a6  2164              MOVS     r1,#0x64
0000a8  f7fffffe          BL       __aeabi_uidivmod
0000ac  0700              LSLS     r0,r0,#28
0000ae  0f00              LSRS     r0,r0,#28
                  |L1.176|
;;;141        }
;;;142        
;;;143        /* Write to USART BRR */
;;;144        
;;;145        
;;;146        
;;;147        /* Disable USART */
;;;148        USART1->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE); 
0000b0  6829              LDR      r1,[r5,#0]
0000b2  4320              ORRS     r0,r0,r4              ;140
0000b4  0849              LSRS     r1,r1,#1
0000b6  0049              LSLS     r1,r1,#1
0000b8  6029              STR      r1,[r5,#0]
;;;149        USART1->BRR = (uint16_t)tmpreg;
0000ba  81a8              STRH     r0,[r5,#0xc]
;;;150        
;;;151    #ifdef USART2_REMAP
;;;152        os_clock_open("GPIOB");
;;;153        GPIOB->CRL&=0X00FFFffF; 
;;;154        GPIOB->CRL|=0X8b000000;//IO×´Ì¬ÉèÖÃ
;;;155        RCC->APB1RSTR|=(1<<17); //¸´Î»´®¿Ú2
;;;156        AFIO->MAPR|=1<<2;
;;;157        os_clock_close("GPIOB");
;;;158    #else
;;;159        os_clock_open("GPIOA");
0000bc  a04c              ADR      r0,|L1.496|
0000be  f7fffffe          BL       os_clock_open
;;;160        
;;;161        /* alternate functions  configuration */ 
;;;162        temp_1 = ((u32)(GPIO_AF_1) << ((u32)((u32)UART1_PORT_TX & (u32)0x07) * 4));    
0000c2  2210              MOVS     r2,#0x10
;;;163        UART1_PORT->AFR[UART1_PORT_TX >> 0x03] &= ~((u32)0xF << ((u32)((u32)UART1_PORT_TX & (u32)0x07) * 4));
0000c4  2009              MOVS     r0,#9
0000c6  06c0              LSLS     r0,r0,#27
0000c8  6a41              LDR      r1,[r0,#0x24]
0000ca  23f0              MOVS     r3,#0xf0
0000cc  4399              BICS     r1,r1,r3
0000ce  6241              STR      r1,[r0,#0x24]
;;;164        temp_2 = UART1_PORT->AFR[UART1_PORT_TX >> 0x03] | temp_1;
0000d0  6a41              LDR      r1,[r0,#0x24]
0000d2  4311              ORRS     r1,r1,r2
;;;165        UART1_PORT->AFR[UART1_PORT_TX >> 0x03] = temp_2;
0000d4  6241              STR      r1,[r0,#0x24]
;;;166        
;;;167        temp_1 = ((u32)(GPIO_AF_1) << ((u32)((u32)UART1_PORT_RX & (u32)0x07) * 4));    
;;;168        UART1_PORT->AFR[UART1_PORT_RX >> 0x03] &= ~((u32)0xF << ((u32)((u32)UART1_PORT_RX & (u32)0x07) * 4));
0000d6  6a41              LDR      r1,[r0,#0x24]
0000d8  0112              LSLS     r2,r2,#4              ;167
0000da  011b              LSLS     r3,r3,#4
0000dc  4399              BICS     r1,r1,r3
0000de  6241              STR      r1,[r0,#0x24]
;;;169        temp_2 = UART1_PORT->AFR[UART1_PORT_RX >> 0x03] | temp_1;
0000e0  6a41              LDR      r1,[r0,#0x24]
0000e2  4311              ORRS     r1,r1,r2
;;;170        UART1_PORT->AFR[UART1_PORT_RX >> 0x03] = temp_2;
0000e4  6241              STR      r1,[r0,#0x24]
;;;171        
;;;172        /* Speed mode configuration */
;;;173        UART1_PORT->OSPEEDR &= ~((GPIO_Speed_50MHz << (UART1_PORT_TX <<1))|(GPIO_Speed_50MHz<<(UART1_PORT_TX<<1)));
0000e6  6882              LDR      r2,[r0,#8]
0000e8  2103              MOVS     r1,#3
0000ea  0489              LSLS     r1,r1,#18
0000ec  438a              BICS     r2,r2,r1
0000ee  6082              STR      r2,[r0,#8]
;;;174        UART1_PORT->OSPEEDR |= ((GPIO_Speed_50MHz << (UART1_PORT_TX <<1))|(GPIO_Speed_50MHz<<(UART1_PORT_TX<<1)));
0000f0  6882              LDR      r2,[r0,#8]
0000f2  430a              ORRS     r2,r2,r1
0000f4  6082              STR      r2,[r0,#8]
;;;175        
;;;176        /* Output mode configuration */
;;;177        UART1_PORT->OTYPER &= ~(((GPIO_OTYPER_OT_0) << ((uint16_t)UART1_PORT_TX))|((GPIO_OTYPER_OT_0) << ((uint16_t)UART1_PORT_RX)));
0000f6  8882              LDRH     r2,[r0,#4]
0000f8  124b              ASRS     r3,r1,#9
0000fa  439a              BICS     r2,r2,r3
0000fc  8082              STRH     r2,[r0,#4]
;;;178        UART1_PORT->OTYPER |=  (((GPIO_OType_PP) << ((uint16_t)UART1_PORT_TX))|((GPIO_OType_PP) << ((uint16_t)UART1_PORT_RX)));
0000fe  8882              LDRH     r2,[r0,#4]
000100  8082              STRH     r2,[r0,#4]
;;;179        
;;;180        UART1_PORT->MODER  &= ~((GPIO_MODER_MODER0 << (UART1_PORT_TX <<1))|(GPIO_MODER_MODER0<<(UART1_PORT_TX<<1)));
000102  6802              LDR      r2,[r0,#0]
000104  438a              BICS     r2,r2,r1
000106  6002              STR      r2,[r0,#0]
;;;181        
;;;182        UART1_PORT->MODER |= ((GPIO_Mode_AF << (UART1_PORT_TX <<1))|(GPIO_Mode_AF<<(UART1_PORT_RX<<1)));
000108  6802              LDR      r2,[r0,#0]
00010a  2305              MOVS     r3,#5
00010c  04db              LSLS     r3,r3,#19
00010e  431a              ORRS     r2,r2,r3
000110  6002              STR      r2,[r0,#0]
;;;183        
;;;184        /* Pull-up Pull down resistor configuration */
;;;185        
;;;186        UART1_PORT->PUPDR &= ~((GPIO_PUPDR_PUPDR0 << (UART1_PORT_TX <<1))|(GPIO_PUPDR_PUPDR0<<(UART1_PORT_TX<<1)));
000112  68c2              LDR      r2,[r0,#0xc]
000114  438a              BICS     r2,r2,r1
000116  60c2              STR      r2,[r0,#0xc]
;;;187        
;;;188        UART1_PORT->PUPDR |=  ((GPIO_PuPd_UP << (UART1_PORT_TX <<1))|(GPIO_PuPd_UP<<(UART1_PORT_TX<<1)));
000118  68c1              LDR      r1,[r0,#0xc]
00011a  2201              MOVS     r2,#1
00011c  0492              LSLS     r2,r2,#18
00011e  4311              ORRS     r1,r1,r2
000120  60c1              STR      r1,[r0,#0xc]
;;;189        
;;;190        os_clock_close("GPIOA");
000122  a033              ADR      r0,|L1.496|
000124  f7fffffe          BL       os_clock_close
;;;191    #endif	
;;;192        
;;;193        
;;;194        /*---------------------------- USART CR2 Configuration -----------------------*/
;;;195        tmpreg = USART1->CR2;
000128  6868              LDR      r0,[r5,#4]
;;;196        
;;;197        /* Clear STOP[13:12] bits */
;;;198        tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
00012a  2103              MOVS     r1,#3
00012c  0309              LSLS     r1,r1,#12
00012e  4388              BICS     r0,r0,r1
;;;199        
;;;200        /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;201        /* Set STOP[13:12] bits according to USART_StopBits value */
;;;202        tmpreg |= (uint32_t)0;
;;;203        
;;;204        /* Write to USART CR2 */
;;;205        USART1->CR2 = tmpreg;
000130  6068              STR      r0,[r5,#4]
;;;206        /*---------------------------- USART CR1 Configuration -----------------------*/
;;;207        tmpreg = USART1->CR1;
000132  6828              LDR      r0,[r5,#0]
;;;208        /* Clear M, PCE, PS, TE and RE bits */
;;;209        tmpreg &= (uint32_t)~(((uint32_t)(USART_CR1_M | USART_CR1_PCE | \
000134  4931              LDR      r1,|L1.508|
000136  4008              ANDS     r0,r0,r1
;;;210                                          USART_CR1_PS | USART_CR1_TE | \
;;;211                                          USART_CR1_RE)));
;;;212        
;;;213        /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;214        /* Set the M bits according to USART_WordLength value */
;;;215        /* Set PCE and PS bits according to USART_Parity value */
;;;216        /* Set TE and RE bits according to USART_Mode value */
;;;217        tmpreg |= (uint32_t)USART_CR1_RXNEIE|USART_CR1_RE|USART_CR1_TE|USART_CR1_UE;
000138  212d              MOVS     r1,#0x2d
00013a  4308              ORRS     r0,r0,r1
;;;218        
;;;219        /* Write to USART CR1 */
;;;220        USART1->CR1 = tmpreg;
00013c  6028              STR      r0,[r5,#0]
00013e  4830              LDR      r0,|L1.512|
000140  6801              LDR      r1,[r0,#0]
000142  0209              LSLS     r1,r1,#8
000144  0a09              LSRS     r1,r1,#8
000146  6001              STR      r1,[r0,#0]
000148  2001              MOVS     r0,#1
00014a  492e              LDR      r1,|L1.516|
00014c  06c0              LSLS     r0,r0,#27
00014e  6008              STR      r0,[r1,#0]
;;;221        
;;;222        NVIC_SetPriority(USART1_IRQn , 0x00);
;;;223        NVIC_EnableIRQ(USART1_IRQn);
;;;224        
;;;225        
;;;226        os_clock_close("USART1");	
000150  a025              ADR      r0,|L1.488|
000152  f7fffffe          BL       os_clock_close
;;;227        os_clock_open("USART1");
000156  a024              ADR      r0,|L1.488|
000158  f7fffffe          BL       os_clock_open
;;;228        os_clock_open("GPIOA");
00015c  a024              ADR      r0,|L1.496|
00015e  f7fffffe          BL       os_clock_open
;;;229        
;;;230        return SUCCESS;
000162  2001              MOVS     r0,#1
;;;231        
;;;232        
;;;233    }
000164  bd70              POP      {r4-r6,pc}
;;;234    
                          ENDP

                  usart1_register PROC
;;;66     #define USART1_NAME "USART1"
;;;67     os_err_t usart1_register(u16 task_id)
000166  b510              PUSH     {r4,lr}
;;;68     {
000168  4604              MOV      r4,r0
;;;69         
;;;70         console_dev=osmalloc(sizeof(usart_device));
00016a  204c              MOVS     r0,#0x4c
00016c  f7fffffe          BL       osmalloc
000170  4925              LDR      r1,|L1.520|
;;;71         
;;;72         
;;;73         console_dev->pclk2=SYSCLK;
;;;74         console_dev->bound=BOUND;
;;;75         
;;;76         console_dev->os_device.type = OS_Device_Class_Char;
;;;77         
;;;78         console_dev->os_device.device_id = OS_DEVICE_USART_ID;
;;;79         
;;;80         console_dev->register_taskid = task_id;
;;;81         
;;;82         console_dev->os_device.init  = uart1_init;
;;;83         
;;;84         console_dev->os_device.open  = uart1_open;
;;;85         console_dev->os_device.write = uart1_write;
;;;86         console_dev->os_device.rx_indicate = uart1_rx_indicator;
;;;87         
;;;88         return os_device_register(&(console_dev->os_device), USART1_NAME, OS_DEVICE_FLAG_INACTIVATED);
000172  2202              MOVS     r2,#2
000174  6008              STR      r0,[r1,#0]            ;73  ; console_dev
000176  2130              MOVS     r1,#0x30              ;73
000178  6401              STR      r1,[r0,#0x40]         ;74
00017a  21e1              MOVS     r1,#0xe1              ;74
00017c  0249              LSLS     r1,r1,#9              ;74
00017e  6441              STR      r1,[r0,#0x44]         ;76
000180  2100              MOVS     r1,#0                 ;76
000182  7401              STRB     r1,[r0,#0x10]         ;76
000184  2101              MOVS     r1,#1                 ;78
000186  7581              STRB     r1,[r0,#0x16]         ;78
000188  8784              STRH     r4,[r0,#0x3c]         ;80
00018a  4920              LDR      r1,|L1.524|
00018c  6201              STR      r1,[r0,#0x20]         ;84
00018e  4920              LDR      r1,|L1.528|
000190  6241              STR      r1,[r0,#0x24]         ;85
000192  4920              LDR      r1,|L1.532|
000194  6301              STR      r1,[r0,#0x30]         ;86
000196  4920              LDR      r1,|L1.536|
000198  6181              STR      r1,[r0,#0x18]
00019a  a113              ADR      r1,|L1.488|
00019c  f7fffffe          BL       os_device_register
;;;89     }
0001a0  bd10              POP      {r4,pc}
;;;90     
                          ENDP

                  uart1_close PROC
;;;262     */
;;;263    os_err_t  uart1_close(os_device_t* dev, u16 oflag)
0001a2  b510              PUSH     {r4,lr}
;;;264    {
;;;265        
;;;266        os_clock_close("USART1");
0001a4  a010              ADR      r0,|L1.488|
0001a6  f7fffffe          BL       os_clock_close
;;;267        os_clock_close("GPIOA");
0001aa  a011              ADR      r0,|L1.496|
0001ac  f7fffffe          BL       os_clock_close
;;;268        
;;;269        return SUCCESS;		
0001b0  2001              MOVS     r0,#1
;;;270        
;;;271    }
0001b2  bd10              POP      {r4,pc}
;;;272    /*********************************************************************
                          ENDP

                  USART1_IRQHandler PROC
;;;340     */  
;;;341    void USART1_IRQHandler(void)
0001b4  b538              PUSH     {r3-r5,lr}
;;;342    {
;;;343        
;;;344        u32 uart1_status;
;;;345        u8 usart_recieved;
;;;346        if(USART1->ISR&(1<<5))//Read data register not empty
0001b6  4c0b              LDR      r4,|L1.484|
0001b8  3c20              SUBS     r4,r4,#0x20
0001ba  69e0              LDR      r0,[r4,#0x1c]
;;;347        {	 
;;;348            usart_recieved=USART1->RDR;
0001bc  4d09              LDR      r5,|L1.484|
0001be  0680              LSLS     r0,r0,#26             ;346
0001c0  d50c              BPL      |L1.476|
0001c2  88a8              LDRH     r0,[r5,#4]
0001c4  4669              MOV      r1,sp
0001c6  7008              STRB     r0,[r1,#0]
;;;349            console_dev->os_device.user_data=(void*)&usart_recieved;
0001c8  480f              LDR      r0,|L1.520|
0001ca  6800              LDR      r0,[r0,#0]  ; console_dev
;;;350            console_dev->os_device.rx_indicate(&(console_dev->os_device), 1);
0001cc  6381              STR      r1,[r0,#0x38]
0001ce  6982              LDR      r2,[r0,#0x18]
0001d0  2101              MOVS     r1,#1
0001d2  4790              BLX      r2
;;;351            
;;;352            USART1->RQR|=(1<<3);
0001d4  8b20              LDRH     r0,[r4,#0x18]
0001d6  2108              MOVS     r1,#8
0001d8  4308              ORRS     r0,r0,r1
0001da  8320              STRH     r0,[r4,#0x18]
                  |L1.476|
;;;353        }
;;;354        usart_recieved=USART1->RDR; 	
0001dc  88a8              LDRH     r0,[r5,#4]
;;;355        uart1_status=USART1->ISR;
0001de  69e0              LDR      r0,[r4,#0x1c]
;;;356        USART1->ISR  =uart1_status;
0001e0  61e0              STR      r0,[r4,#0x1c]
;;;357        
;;;358        
;;;359    } 
0001e2  bd38              POP      {r3-r5,pc}
;;;360    
                          ENDP

                  |L1.484|
                          DCD      0x40013820
                  |L1.488|
0001e8  55534152          DCB      "USART1",0
0001ec  543100  
0001ef  00                DCB      0
                  |L1.496|
0001f0  4750494f          DCB      "GPIOA",0
0001f4  4100    
0001f6  00                DCB      0
0001f7  00                DCB      0
                  |L1.504|
                          DCD      0x017d7840
                  |L1.508|
                          DCD      0xffffe9f3
                  |L1.512|
                          DCD      0xe000e418
                  |L1.516|
                          DCD      0xe000e100
                  |L1.520|
                          DCD      ||.data||
                  |L1.524|
                          DCD      uart1_init
                  |L1.528|
                          DCD      uart1_open
                  |L1.532|
                          DCD      uart1_write
                  |L1.536|
                          DCD      uart1_rx_indicator

                          AREA ||.data||, DATA, ALIGN=2

                  console_dev
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\drivers\\stm32f051x\\char\\usart\\usart1.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_usart1_c_31e83443____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_usart1_c_31e83443____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_usart1_c_31e83443____REVSH|
#line 144
|__asm___8_usart1_c_31e83443____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
