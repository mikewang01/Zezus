; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\stm32f0xx_adc.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f0xx_adc.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\stm32f0xx_adc.crf ..\arch\arm\stm32f05x\lib\src\stm32f0xx_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;129      */
;;;130    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  4985              LDR      r1,|L1.536|
;;;131    {
000002  b510              PUSH     {r4,lr}
;;;132      /* Check the parameters */
;;;133      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;134    
;;;135      if(ADCx == ADC1)
000004  4288              CMP      r0,r1
000006  d108              BNE      |L1.26|
;;;136      {
;;;137        /* Enable ADC1 reset state */
;;;138        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
000008  1544              ASRS     r4,r0,#21
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;139    
;;;140        /* Release ADC1 from reset state */
;;;141        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
000012  2100              MOVS     r1,#0
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L1.26|
;;;142      }
;;;143    }
00001a  bd10              POP      {r4,pc}
;;;144    
                          ENDP

                  ADC_Init PROC
;;;155      */
;;;156    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
00001c  b530              PUSH     {r4,r5,lr}
;;;157    {
;;;158      uint32_t tmpreg = 0;
;;;159    
;;;160      /* Check the parameters */
;;;161      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;162      assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution));
;;;163      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
;;;164      assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge));
;;;165      assert_param(IS_ADC_EXTERNAL_TRIG_CONV(ADC_InitStruct->ADC_ExternalTrigConv));
;;;166      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign));
;;;167      assert_param(IS_ADC_SCAN_DIRECTION(ADC_InitStruct->ADC_ScanDirection)); 
;;;168    
;;;169      /* Get the ADCx CFGR value */
;;;170      tmpreg = ADCx->CFGR1;
00001e  68c2              LDR      r2,[r0,#0xc]
;;;171    
;;;172      /* Clear SCANDIR, RES[1:0], ALIGN, EXTSEL[2:0], EXTEN[1:0] and CONT bits */
;;;173      tmpreg &= CFGR1_CLEAR_MASK;
000020  4b7e              LDR      r3,|L1.540|
;;;174    
;;;175      /*---------------------------- ADCx CFGR Configuration ---------------------*/
;;;176    
;;;177      /* Set RES[1:0] bits according to ADC_Resolution value */
;;;178      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;179      /* Set EXTEN[1:0] bits according to ADC_ExternalTrigConvEdge value */
;;;180      /* Set EXTSEL[2:0] bits according to ADC_ExternalTrigConv value */
;;;181      /* Set ALIGN bit according to ADC_DataAlign value */
;;;182      /* Set SCANDIR bit according to ADC_ScanDirection value */
;;;183     
;;;184      tmpreg  |= (uint32_t)(ADC_InitStruct->ADC_Resolution | ((uint32_t)(ADC_InitStruct->ADC_ContinuousConvMode) << 13) |
000022  688c              LDR      r4,[r1,#8]
000024  401a              ANDS     r2,r2,r3              ;173
000026  680b              LDR      r3,[r1,#0]
000028  790d              LDRB     r5,[r1,#4]
00002a  4323              ORRS     r3,r3,r4
00002c  68cc              LDR      r4,[r1,#0xc]
00002e  036d              LSLS     r5,r5,#13
000030  432c              ORRS     r4,r4,r5
000032  4323              ORRS     r3,r3,r4
000034  690c              LDR      r4,[r1,#0x10]
000036  6949              LDR      r1,[r1,#0x14]
000038  4323              ORRS     r3,r3,r4
00003a  430b              ORRS     r3,r3,r1
00003c  4313              ORRS     r3,r3,r2
;;;185                 ADC_InitStruct->ADC_ExternalTrigConvEdge | ADC_InitStruct->ADC_ExternalTrigConv |
;;;186                 ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ScanDirection);
;;;187    
;;;188      /* Write to ADCx CFGR */
;;;189      ADCx->CFGR1 = tmpreg;
00003e  60c3              STR      r3,[r0,#0xc]
;;;190    }
000040  bd30              POP      {r4,r5,pc}
;;;191    
                          ENDP

                  ADC_StructInit PROC
;;;200      */
;;;201    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000042  2100              MOVS     r1,#0
;;;202    {
;;;203      /* Reset ADC init structure parameters values */
;;;204      /* Initialize the ADC_Resolution member */
;;;205      ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
;;;206    
;;;207       /* Initialize the ADC_ContinuousConvMode member */
;;;208      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000044  6001              STR      r1,[r0,#0]
000046  7101              STRB     r1,[r0,#4]
;;;209    
;;;210      /* Initialize the ADC_ExternalTrigConvEdge member */
;;;211      ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
;;;212    
;;;213      /* Initialize the ADC_ExternalTrigConv member */
;;;214      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_TRGO;
000048  6081              STR      r1,[r0,#8]
;;;215    
;;;216      /* Initialize the ADC_DataAlign member */
;;;217      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
00004a  60c1              STR      r1,[r0,#0xc]
;;;218    
;;;219      /* Initialize the ADC_ScanDirection member */
;;;220      ADC_InitStruct->ADC_ScanDirection = ADC_ScanDirection_Upward;
00004c  6101              STR      r1,[r0,#0x10]
00004e  6141              STR      r1,[r0,#0x14]
;;;221    }
000050  4770              BX       lr
;;;222    
                          ENDP

                  ADC_Cmd PROC
;;;229      */
;;;230    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000052  2900              CMP      r1,#0
;;;231    {
;;;232      /* Check the parameters */
;;;233      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;234      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;235    
;;;236      if (NewState != DISABLE)
;;;237      {
;;;238        /* Set the ADEN bit to Enable the ADC peripheral */
;;;239        ADCx->CR |= (uint32_t)ADC_CR_ADEN;
;;;240      }
;;;241      else
;;;242      {
;;;243        /* Set the ADDIS to Disable the ADC peripheral */
;;;244        ADCx->CR |= (uint32_t)ADC_CR_ADDIS;
000054  6881              LDR      r1,[r0,#8]
000056  d001              BEQ      |L1.92|
000058  2201              MOVS     r2,#1                 ;239
00005a  e000              B        |L1.94|
                  |L1.92|
00005c  2202              MOVS     r2,#2
                  |L1.94|
00005e  4311              ORRS     r1,r1,r2              ;239
000060  6081              STR      r1,[r0,#8]            ;239
;;;245      }
;;;246    }
000062  4770              BX       lr
;;;247    
                          ENDP

                  ADC_JitterCmd PROC
;;;258      */
;;;259    void ADC_JitterCmd(ADC_TypeDef* ADCx, uint32_t ADC_JitterOff, FunctionalState NewState)
000064  2a00              CMP      r2,#0
;;;260    {
;;;261      /* Check the parameters */
;;;262      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;263      assert_param(IS_ADC_JITTEROFF(ADC_JitterOff));
;;;264      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;265    
;;;266      if (NewState != DISABLE)
;;;267      {
;;;268        /* Disable Jitter */
;;;269        ADCx->CFGR2 |= (uint32_t)ADC_JitterOff;
;;;270      }
;;;271      else
;;;272      {
;;;273        /* Enable Jitter */
;;;274        ADCx->CFGR2 &= (uint32_t)(~ADC_JitterOff);
000066  6902              LDR      r2,[r0,#0x10]
000068  d001              BEQ      |L1.110|
00006a  430a              ORRS     r2,r2,r1              ;269
00006c  e000              B        |L1.112|
                  |L1.110|
00006e  438a              BICS     r2,r2,r1
                  |L1.112|
000070  6102              STR      r2,[r0,#0x10]         ;269
;;;275      }
;;;276    }
000072  4770              BX       lr
;;;277    
                          ENDP

                  ADC_AutoPowerOffCmd PROC
;;;316      */
;;;317    void ADC_AutoPowerOffCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000074  2201              MOVS     r2,#1
;;;318    {
;;;319      /* Check the parameters */
;;;320      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;321      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;322      
;;;323      if (NewState != DISABLE)
;;;324      {
;;;325        /* Enable the ADC Automatic Power-Off */
;;;326        ADCx->CFGR1 |= ADC_CFGR1_AUTOFF;
000076  03d2              LSLS     r2,r2,#15
000078  2900              CMP      r1,#0                 ;323
;;;327      }
;;;328      else
;;;329      {
;;;330        /* Disable the ADC Automatic Power-Off */
;;;331        ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AUTOFF;
00007a  68c1              LDR      r1,[r0,#0xc]
00007c  d001              BEQ      |L1.130|
00007e  4311              ORRS     r1,r1,r2              ;326
000080  e000              B        |L1.132|
                  |L1.130|
000082  4391              BICS     r1,r1,r2
                  |L1.132|
000084  60c1              STR      r1,[r0,#0xc]          ;326
;;;332      }
;;;333    }
000086  4770              BX       lr
;;;334    
                          ENDP

                  ADC_WaitModeCmd PROC
;;;351      */
;;;352    void ADC_WaitModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000088  2201              MOVS     r2,#1
;;;353    {
;;;354      /* Check the parameters */
;;;355      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;356      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;357      
;;;358      if (NewState != DISABLE)
;;;359      {
;;;360        /* Enable the ADC Automatic Delayed conversion */
;;;361        ADCx->CFGR1 |= ADC_CFGR1_AUTDLY ;
00008a  0392              LSLS     r2,r2,#14
00008c  2900              CMP      r1,#0                 ;358
;;;362      }
;;;363      else
;;;364      {
;;;365        /* Disable the ADC Automatic Delayed conversion */
;;;366        ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AUTDLY ;
00008e  68c1              LDR      r1,[r0,#0xc]
000090  d001              BEQ      |L1.150|
000092  4311              ORRS     r1,r1,r2              ;361
000094  e000              B        |L1.152|
                  |L1.150|
000096  4391              BICS     r1,r1,r2
                  |L1.152|
000098  60c1              STR      r1,[r0,#0xc]          ;361
;;;367      }
;;;368    }
00009a  4770              BX       lr
;;;369    
                          ENDP

                  ADC_AnalogWatchdogCmd PROC
;;;403      */
;;;404    void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00009c  2201              MOVS     r2,#1
;;;405    {
;;;406      /* Check the parameters */
;;;407      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;408      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;409      
;;;410      if (NewState != DISABLE)
;;;411      {
;;;412        /* Enable the ADC Analog Watchdog */
;;;413        ADCx->CFGR1 |= ADC_CFGR1_AWDEN;
00009e  05d2              LSLS     r2,r2,#23
0000a0  2900              CMP      r1,#0                 ;410
;;;414      }
;;;415      else
;;;416      {
;;;417        /* Disable the ADC Analog Watchdog */
;;;418        ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AWDEN;
0000a2  68c1              LDR      r1,[r0,#0xc]
0000a4  d001              BEQ      |L1.170|
0000a6  4311              ORRS     r1,r1,r2              ;413
0000a8  e000              B        |L1.172|
                  |L1.170|
0000aa  4391              BICS     r1,r1,r2
                  |L1.172|
0000ac  60c1              STR      r1,[r0,#0xc]          ;413
;;;419      }
;;;420    }
0000ae  4770              BX       lr
;;;421    
                          ENDP

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;430      */
;;;431    void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
0000b0  0409              LSLS     r1,r1,#16
;;;432                                            uint16_t LowThreshold)
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;436      assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;437      assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;438    
;;;439      /* Set the ADCx high and low threshold */
;;;440      ADCx->TR = LowThreshold | ((uint32_t)HighThreshold << 16);
0000b2  4311              ORRS     r1,r1,r2
0000b4  6201              STR      r1,[r0,#0x20]
;;;441    
;;;442    }
0000b6  4770              BX       lr
;;;443    
                          ENDP

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;471      */
;;;472    void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog_Channel)
0000b8  68c2              LDR      r2,[r0,#0xc]
;;;473    {
;;;474      uint32_t tmpreg = 0;
;;;475    
;;;476      /* Check the parameters */
;;;477      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;478      assert_param(IS_ADC_ANALOG_WATCHDOG_CHANNEL(ADC_AnalogWatchdog_Channel));
;;;479    
;;;480      /* Get the old register value */
;;;481      tmpreg = ADCx->CFGR1;
;;;482    
;;;483      /* Clear the Analog watchdog channel select bits */
;;;484      tmpreg &= ~ADC_CFGR1_AWDCH;
0000ba  231f              MOVS     r3,#0x1f
0000bc  069b              LSLS     r3,r3,#26
0000be  439a              BICS     r2,r2,r3
;;;485    
;;;486      /* Set the Analog watchdog channel */
;;;487      tmpreg |= ADC_AnalogWatchdog_Channel;
0000c0  430a              ORRS     r2,r2,r1
;;;488    
;;;489      /* Store the new register value */
;;;490      ADCx->CFGR1 = tmpreg;
0000c2  60c2              STR      r2,[r0,#0xc]
;;;491    }
0000c4  4770              BX       lr
;;;492    
                          ENDP

                  ADC_AnalogWatchdogSingleChannelCmd PROC
;;;499      */
;;;500    void ADC_AnalogWatchdogSingleChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0000c6  2201              MOVS     r2,#1
;;;501    {
;;;502      /* Check the parameters */
;;;503      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;504      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;505    
;;;506      if (NewState != DISABLE)
;;;507      {
;;;508        /* Enable the ADC Analog Watchdog Single Channel */
;;;509        ADCx->CFGR1 |= ADC_CFGR1_AWDSGL;
0000c8  0592              LSLS     r2,r2,#22
0000ca  2900              CMP      r1,#0                 ;506
;;;510      }
;;;511      else
;;;512      {
;;;513        /* Disable the ADC Analog Watchdog Single Channel */
;;;514        ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AWDSGL;
0000cc  68c1              LDR      r1,[r0,#0xc]
0000ce  d001              BEQ      |L1.212|
0000d0  4311              ORRS     r1,r1,r2              ;509
0000d2  e000              B        |L1.214|
                  |L1.212|
0000d4  4391              BICS     r1,r1,r2
                  |L1.214|
0000d6  60c1              STR      r1,[r0,#0xc]          ;509
;;;515      }
;;;516    }
0000d8  4770              BX       lr
;;;517    
                          ENDP

                  ADC_TempSensorCmd PROC
;;;551      */
;;;552    void ADC_TempSensorCmd(FunctionalState NewState)
0000da  2201              MOVS     r2,#1
;;;553    {
;;;554      /* Check the parameters */
;;;555      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;556    
;;;557      if (NewState != DISABLE)
;;;558      {
;;;559        /* Enable the temperature sensor channel*/
;;;560        ADC->CCR |= (uint32_t)ADC_CCR_TSEN;
0000dc  4950              LDR      r1,|L1.544|
0000de  05d2              LSLS     r2,r2,#23
0000e0  2800              CMP      r0,#0                 ;557
;;;561      }
;;;562      else
;;;563      {
;;;564        /* Disable the temperature sensor channel*/
;;;565        ADC->CCR &= (uint32_t)(~ADC_CCR_TSEN);
0000e2  6888              LDR      r0,[r1,#8]
0000e4  d001              BEQ      |L1.234|
0000e6  4310              ORRS     r0,r0,r2              ;560
0000e8  e000              B        |L1.236|
                  |L1.234|
0000ea  4390              BICS     r0,r0,r2
                  |L1.236|
0000ec  6088              STR      r0,[r1,#8]            ;560
;;;566      }
;;;567    }
0000ee  4770              BX       lr
;;;568    
                          ENDP

                  ADC_VrefintCmd PROC
;;;574      */
;;;575    void ADC_VrefintCmd(FunctionalState NewState)
0000f0  2201              MOVS     r2,#1
;;;576    {
;;;577      /* Check the parameters */
;;;578      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;579    
;;;580      if (NewState != DISABLE)
;;;581      {
;;;582        /* Enable the Vrefint channel*/
;;;583        ADC->CCR |= (uint32_t)ADC_CCR_VREFEN;
0000f2  494b              LDR      r1,|L1.544|
0000f4  0592              LSLS     r2,r2,#22
0000f6  2800              CMP      r0,#0                 ;580
;;;584      }
;;;585      else
;;;586      {
;;;587        /* Disable the Vrefint channel*/
;;;588        ADC->CCR &= (uint32_t)(~ADC_CCR_VREFEN);
0000f8  6888              LDR      r0,[r1,#8]
0000fa  d001              BEQ      |L1.256|
0000fc  4310              ORRS     r0,r0,r2              ;583
0000fe  e000              B        |L1.258|
                  |L1.256|
000100  4390              BICS     r0,r0,r2
                  |L1.258|
000102  6088              STR      r0,[r1,#8]            ;583
;;;589      }
;;;590    }
000104  4770              BX       lr
;;;591    
                          ENDP

                  ADC_VbatCmd PROC
;;;597      */
;;;598    void ADC_VbatCmd(FunctionalState NewState)
000106  2201              MOVS     r2,#1
;;;599    {
;;;600      /* Check the parameters */
;;;601      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;602    
;;;603      if (NewState != DISABLE)
;;;604      {
;;;605        /* Enable the Vbat channel*/
;;;606        ADC->CCR |= (uint32_t)ADC_CCR_VBATEN;
000108  4945              LDR      r1,|L1.544|
00010a  0612              LSLS     r2,r2,#24
00010c  2800              CMP      r0,#0                 ;603
;;;607      }
;;;608      else
;;;609      {
;;;610        /* Disable the Vbat channel*/
;;;611        ADC->CCR &= (uint32_t)(~ADC_CCR_VBATEN);
00010e  6888              LDR      r0,[r1,#8]
000110  d001              BEQ      |L1.278|
000112  4310              ORRS     r0,r0,r2              ;606
000114  e000              B        |L1.280|
                  |L1.278|
000116  4390              BICS     r0,r0,r2
                  |L1.280|
000118  6088              STR      r0,[r1,#8]            ;606
;;;612      }
;;;613    }
00011a  4770              BX       lr
;;;614    
                          ENDP

                  ADC_ChannelConfig PROC
;;;691      */
;;;692    void ADC_ChannelConfig(ADC_TypeDef* ADCx, uint32_t ADC_Channel, uint32_t ADC_SampleTime)
00011c  6a83              LDR      r3,[r0,#0x28]
;;;693    {
;;;694      uint32_t tmpreg = 0;
;;;695    
;;;696      /* Check the parameters */
;;;697      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;698      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;699      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;700    
;;;701      /* Configure the ADC Channel */
;;;702      ADCx->CHSELR |= (uint32_t)ADC_Channel;
00011e  430b              ORRS     r3,r3,r1
000120  6283              STR      r3,[r0,#0x28]
;;;703    
;;;704      /* Clear the Sampling time Selection bits */
;;;705      tmpreg &= ~ADC_SMPR1_SMPR;
;;;706    
;;;707      /* Set the ADC Sampling Time register */
;;;708      tmpreg |= (uint32_t)ADC_SampleTime;
;;;709    
;;;710      /* Configure the ADC Sample time register */
;;;711      ADCx->SMPR = tmpreg ;
000122  6142              STR      r2,[r0,#0x14]
;;;712    }
000124  4770              BX       lr
;;;713    
                          ENDP

                  ADC_ContinuousModeCmd PROC
;;;723      */
;;;724    void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000126  2201              MOVS     r2,#1
;;;725    {
;;;726      /* Check the parameters */
;;;727      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;728      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;729    
;;;730        if (NewState != DISABLE)
;;;731      {
;;;732        /* Enable the Continuous mode*/
;;;733        ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_CONT;
000128  0352              LSLS     r2,r2,#13
00012a  2900              CMP      r1,#0                 ;730
;;;734      }
;;;735      else
;;;736      {
;;;737        /* Disable the Continuous mode */
;;;738        ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_CONT);
00012c  68c1              LDR      r1,[r0,#0xc]
00012e  d001              BEQ      |L1.308|
000130  4311              ORRS     r1,r1,r2              ;733
000132  e000              B        |L1.310|
                  |L1.308|
000134  4391              BICS     r1,r1,r2
                  |L1.310|
000136  60c1              STR      r1,[r0,#0xc]          ;733
;;;739      }
;;;740    }
000138  4770              BX       lr
;;;741    
                          ENDP

                  ADC_DiscModeCmd PROC
;;;751      */
;;;752    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00013a  2201              MOVS     r2,#1
;;;753    {
;;;754      /* Check the parameters */
;;;755      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;756      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;757    
;;;758        if (NewState != DISABLE)
;;;759      {
;;;760        /* Enable the Discontinuous mode */
;;;761        ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_DISCEN;
00013c  0412              LSLS     r2,r2,#16
00013e  2900              CMP      r1,#0                 ;758
;;;762      }
;;;763      else
;;;764      {
;;;765        /* Disable the Discontinuous mode */
;;;766        ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_DISCEN);
000140  68c1              LDR      r1,[r0,#0xc]
000142  d001              BEQ      |L1.328|
000144  4311              ORRS     r1,r1,r2              ;761
000146  e000              B        |L1.330|
                  |L1.328|
000148  4391              BICS     r1,r1,r2
                  |L1.330|
00014a  60c1              STR      r1,[r0,#0xc]          ;761
;;;767      }
;;;768    }
00014c  4770              BX       lr
;;;769    
                          ENDP

                  ADC_OverrunModeCmd PROC
;;;776      */
;;;777    void ADC_OverrunModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00014e  2201              MOVS     r2,#1
;;;778    {
;;;779      /* Check the parameters */
;;;780      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;781      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;782    
;;;783        if (NewState != DISABLE)
;;;784      {
;;;785        /* Enable the Overrun mode */
;;;786        ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_OVRMOD;
000150  0312              LSLS     r2,r2,#12
000152  2900              CMP      r1,#0                 ;783
;;;787      }
;;;788      else
;;;789      {
;;;790        /* Disable the Overrun mode */
;;;791        ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_OVRMOD);
000154  68c1              LDR      r1,[r0,#0xc]
000156  d001              BEQ      |L1.348|
000158  4311              ORRS     r1,r1,r2              ;786
00015a  e000              B        |L1.350|
                  |L1.348|
00015c  4391              BICS     r1,r1,r2
                  |L1.350|
00015e  60c1              STR      r1,[r0,#0xc]          ;786
;;;792      }
;;;793    }
000160  4770              BX       lr
;;;794    
                          ENDP

                  ADC_GetCalibrationFactor PROC
;;;801      */
;;;802    uint32_t ADC_GetCalibrationFactor(ADC_TypeDef* ADCx)
000162  6882              LDR      r2,[r0,#8]
;;;803    {
;;;804      uint32_t tmpreg = 0, calibrationcounter = 0, calibrationstatus = 0;
000164  2100              MOVS     r1,#0
;;;805    
;;;806      /* Check the parameters */
;;;807      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;808      
;;;809      /* Set the ADC calibartion */
;;;810      ADCx->CR |= (uint32_t)ADC_CR_ADCAL;
000166  2301              MOVS     r3,#1
000168  07db              LSLS     r3,r3,#31
00016a  431a              ORRS     r2,r2,r3
00016c  6082              STR      r2,[r0,#8]
;;;811      
;;;812      /* Wait until no ADC calibration is completed */
;;;813      do
;;;814      {
;;;815        calibrationstatus = ADCx->CR & ADC_CR_ADCAL;
;;;816        calibrationcounter++;  
;;;817      } while((calibrationcounter != CALIBRATION_TIMEOUT) && (calibrationstatus != 0x00));
00016e  230f              MOVS     r3,#0xf
000170  031b              LSLS     r3,r3,#12
                  |L1.370|
000172  6882              LDR      r2,[r0,#8]            ;815
000174  1c49              ADDS     r1,r1,#1              ;816
000176  0fd2              LSRS     r2,r2,#31             ;815
000178  07d2              LSLS     r2,r2,#31             ;815
00017a  4299              CMP      r1,r3
00017c  d001              BEQ      |L1.386|
00017e  2a00              CMP      r2,#0
000180  d1f7              BNE      |L1.370|
                  |L1.386|
;;;818        
;;;819      if((uint32_t)(ADCx->CR & ADC_CR_ADCAL) == RESET)
000182  6881              LDR      r1,[r0,#8]
000184  2900              CMP      r1,#0
000186  db01              BLT      |L1.396|
;;;820      {
;;;821        /*Get the calibration factor from the ADC data register */
;;;822        tmpreg = ADCx->DR;
000188  6c00              LDR      r0,[r0,#0x40]
;;;823      }
;;;824      else
;;;825      {
;;;826        /* Error factor */
;;;827        tmpreg = 0x00000000;
;;;828      }
;;;829      return tmpreg;
;;;830    }
00018a  4770              BX       lr
                  |L1.396|
00018c  2000              MOVS     r0,#0                 ;827
00018e  4770              BX       lr
;;;831    
                          ENDP

                  ADC_StopOfConversion PROC
;;;838      */
;;;839    void ADC_StopOfConversion(ADC_TypeDef* ADCx)
000190  6881              LDR      r1,[r0,#8]
;;;840    {
;;;841      /* Check the parameters */
;;;842      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;843      
;;;844      ADCx->CR |= (uint32_t)ADC_CR_ADSTP;
000192  2210              MOVS     r2,#0x10
000194  4311              ORRS     r1,r1,r2
000196  6081              STR      r1,[r0,#8]
;;;845    }
000198  4770              BX       lr
;;;846    
                          ENDP

                  ADC_StartOfConversion PROC
;;;853      */
;;;854    void ADC_StartOfConversion(ADC_TypeDef* ADCx)
00019a  6881              LDR      r1,[r0,#8]
;;;855    {
;;;856      /* Check the parameters */
;;;857      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;858      
;;;859      ADCx->CR |= (uint32_t)ADC_CR_ADSTART;
00019c  2204              MOVS     r2,#4
00019e  4311              ORRS     r1,r1,r2
0001a0  6081              STR      r1,[r0,#8]
;;;860    }
0001a2  4770              BX       lr
;;;861    
                          ENDP

                  ADC_GetConversionValue PROC
;;;866      */
;;;867    uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
0001a4  6c00              LDR      r0,[r0,#0x40]
;;;868    {
;;;869      /* Check the parameters */
;;;870      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;871    
;;;872      /* Return the selected ADC conversion value */
;;;873      return (uint16_t) ADCx->DR;
0001a6  b280              UXTH     r0,r0
;;;874    }
0001a8  4770              BX       lr
;;;875    
                          ENDP

                  ADC_DMACmd PROC
;;;910      */
;;;911    void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0001aa  2900              CMP      r1,#0
;;;912    {
;;;913      /* Check the parameters */
;;;914      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;915      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;916    
;;;917      if (NewState != DISABLE)
;;;918      {
;;;919        /* Enable the selected ADC DMA request */
;;;920        ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_DMAEN;
;;;921      }
;;;922      else
;;;923      {
;;;924        /* Disable the selected ADC DMA request */
;;;925        ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_DMAEN);
0001ac  68c1              LDR      r1,[r0,#0xc]
0001ae  d002              BEQ      |L1.438|
0001b0  2201              MOVS     r2,#1                 ;920
0001b2  4311              ORRS     r1,r1,r2              ;920
0001b4  e001              B        |L1.442|
                  |L1.438|
0001b6  0849              LSRS     r1,r1,#1
0001b8  0049              LSLS     r1,r1,#1
                  |L1.442|
0001ba  60c1              STR      r1,[r0,#0xc]          ;920
;;;926      }
;;;927    }
0001bc  4770              BX       lr
;;;928    
                          ENDP

                  ADC_DMARequestModeConfig PROC
;;;937      */
;;;938    void ADC_DMARequestModeConfig(ADC_TypeDef* ADCx, uint32_t ADC_DMARequestMode)
0001be  68c2              LDR      r2,[r0,#0xc]
;;;939    {
;;;940      /* Check the parameters */
;;;941      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;942    
;;;943      ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_DMACFG;
0001c0  2302              MOVS     r3,#2
0001c2  439a              BICS     r2,r2,r3
0001c4  60c2              STR      r2,[r0,#0xc]
;;;944      ADCx->CFGR1 |= (uint32_t)ADC_DMARequestMode;
0001c6  68c2              LDR      r2,[r0,#0xc]
0001c8  430a              ORRS     r2,r2,r1
0001ca  60c2              STR      r2,[r0,#0xc]
;;;945    }
0001cc  4770              BX       lr
;;;946    
                          ENDP

                  ADC_ITConfig PROC
;;;1045     */
;;;1046   void ADC_ITConfig(ADC_TypeDef* ADCx, uint32_t ADC_IT, FunctionalState NewState)
0001ce  2a00              CMP      r2,#0
;;;1047   {
;;;1048     /* Check the parameters */
;;;1049     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1050     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1051     assert_param(IS_ADC_CONFIG_IT(ADC_IT)); 
;;;1052   
;;;1053     if (NewState != DISABLE)
;;;1054     {
;;;1055       /* Enable the selected ADC interrupts */
;;;1056       ADCx->IER |= ADC_IT;
;;;1057     }
;;;1058     else
;;;1059     {
;;;1060       /* Disable the selected ADC interrupts */
;;;1061       ADCx->IER &= (~(uint32_t)ADC_IT);
0001d0  6842              LDR      r2,[r0,#4]
0001d2  d001              BEQ      |L1.472|
0001d4  430a              ORRS     r2,r2,r1              ;1056
0001d6  e000              B        |L1.474|
                  |L1.472|
0001d8  438a              BICS     r2,r2,r1
                  |L1.474|
0001da  6042              STR      r2,[r0,#4]            ;1056
;;;1062     }
;;;1063   }
0001dc  4770              BX       lr
;;;1064   
                          ENDP

                  ADC_GetFlagStatus PROC
;;;1082     */
;;;1083   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint32_t ADC_FLAG)
0001de  4602              MOV      r2,r0
;;;1084   {
;;;1085     FlagStatus bitstatus = RESET;
0001e0  2000              MOVS     r0,#0
;;;1086     uint32_t tmpreg = 0;
;;;1087   
;;;1088     /* Check the parameters */
;;;1089     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1090     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1091   
;;;1092     if((uint32_t)(ADC_FLAG & 0x01000000))
0001e2  01cb              LSLS     r3,r1,#7
0001e4  d504              BPL      |L1.496|
;;;1093     {
;;;1094       tmpreg = ADCx->CR & 0xFEFFFFFF;
0001e6  6892              LDR      r2,[r2,#8]
0001e8  2301              MOVS     r3,#1
0001ea  061b              LSLS     r3,r3,#24
0001ec  439a              BICS     r2,r2,r3
0001ee  e000              B        |L1.498|
                  |L1.496|
;;;1095     }
;;;1096     else
;;;1097     {
;;;1098       tmpreg = ADCx->ISR;
0001f0  6812              LDR      r2,[r2,#0]
                  |L1.498|
;;;1099     }
;;;1100     
;;;1101     /* Check the status of the specified ADC flag */
;;;1102     if ((tmpreg & ADC_FLAG) != (uint32_t)RESET)
0001f2  420a              TST      r2,r1
0001f4  d000              BEQ      |L1.504|
;;;1103     {
;;;1104       /* ADC_FLAG is set */
;;;1105       bitstatus = SET;
0001f6  2001              MOVS     r0,#1
                  |L1.504|
;;;1106     }
;;;1107     else
;;;1108     {
;;;1109       /* ADC_FLAG is reset */
;;;1110       bitstatus = RESET;
;;;1111     }
;;;1112     /* Return the ADC_FLAG status */
;;;1113     return  bitstatus;
;;;1114   }
0001f8  4770              BX       lr
;;;1115   
                          ENDP

                  ADC_ClearFlag PROC
;;;1128     */
;;;1129   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint32_t ADC_FLAG)
0001fa  6001              STR      r1,[r0,#0]
;;;1130   {
;;;1131     /* Check the parameters */
;;;1132     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1133     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1134   
;;;1135     /* Clear the selected ADC flags */
;;;1136     ADCx->ISR = (uint32_t)ADC_FLAG;
;;;1137   }
0001fc  4770              BX       lr
;;;1138   
                          ENDP

                  ADC_GetITStatus PROC
;;;1151     */
;;;1152   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint32_t ADC_IT)
0001fe  4602              MOV      r2,r0
;;;1153   {
;;;1154     ITStatus bitstatus = RESET;
;;;1155     uint32_t enablestatus = 0;
;;;1156   
;;;1157     /* Check the parameters */
;;;1158     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1159     assert_param(IS_ADC_GET_IT(ADC_IT));
;;;1160   
;;;1161     /* Get the ADC_IT enable bit status */
;;;1162     enablestatus = (uint32_t)(ADCx->IER & ADC_IT); 
000200  6853              LDR      r3,[r2,#4]
000202  2000              MOVS     r0,#0                 ;1154
;;;1163   
;;;1164     /* Check the status of the specified ADC interrupt */
;;;1165     if (((uint32_t)(ADCx->ISR & ADC_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
000204  6812              LDR      r2,[r2,#0]
000206  400b              ANDS     r3,r3,r1              ;1162
000208  420a              TST      r2,r1
00020a  d002              BEQ      |L1.530|
00020c  2b00              CMP      r3,#0
00020e  d000              BEQ      |L1.530|
;;;1166     {
;;;1167       /* ADC_IT is set */
;;;1168       bitstatus = SET;
000210  2001              MOVS     r0,#1
                  |L1.530|
;;;1169     }
;;;1170     else
;;;1171     {
;;;1172       /* ADC_IT is reset */
;;;1173       bitstatus = RESET;
;;;1174     }
;;;1175     /* Return the ADC_IT status */
;;;1176     return  bitstatus;
;;;1177   }
000212  4770              BX       lr
;;;1178   
                          ENDP

                  ADC_ClearITPendingBit PROC
;;;1191     */
;;;1192   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint32_t ADC_IT)
000214  6001              STR      r1,[r0,#0]
;;;1193   {
;;;1194     /* Check the parameters */
;;;1195     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1196     assert_param(IS_ADC_CLEAR_IT(ADC_IT));
;;;1197   
;;;1198     /* Clear the selected ADC interrupt pending bits */
;;;1199     ADCx->ISR = (uint32_t)ADC_IT; 
;;;1200   }
000216  4770              BX       lr
;;;1201   
                          ENDP

                  |L1.536|
                          DCD      0x40012400
                  |L1.540|
                          DCD      0xffffd203
                  |L1.544|
                          DCD      0x40012700

;*** Start embedded assembler ***

#line 1 "..\\arch\\arm\\stm32f05x\\lib\\src\\stm32f0xx_adc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_adc_c_e11a2ea2____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f0xx_adc_c_e11a2ea2____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_adc_c_e11a2ea2____REVSH|
#line 144
|__asm___15_stm32f0xx_adc_c_e11a2ea2____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
