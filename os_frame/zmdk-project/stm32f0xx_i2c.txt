; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\stm32f0xx_i2c.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f0xx_i2c.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\stm32f0xx_i2c.crf ..\arch\arm\stm32f05x\lib\src\stm32f0xx_i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;142      */
;;;143    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  49c9              LDR      r1,|L1.808|
;;;144    {
000002  b510              PUSH     {r4,lr}
;;;145      /* Check the parameters */
;;;146      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;147    
;;;148      if (I2Cx == I2C1)
000004  4288              CMP      r0,r1
000006  d102              BNE      |L1.14|
;;;149      {
;;;150        /* Enable I2C1 reset state */
;;;151        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  054c              LSLS     r4,r1,#21
;;;152        /* Release I2C1 from reset state */
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
00000c  e001              B        |L1.18|
                  |L1.14|
;;;154      }
;;;155      else
;;;156      {
;;;157        /* Enable I2C2 reset state */
;;;158        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
00000e  2101              MOVS     r1,#1
000010  058c              LSLS     r4,r1,#22
                  |L1.18|
000012  4620              MOV      r0,r4                 ;151
000014  f7fffffe          BL       RCC_APB1PeriphResetCmd
000018  2100              MOVS     r1,#0                 ;153
00001a  4620              MOV      r0,r4                 ;153
00001c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;159        /* Release I2C2 from reset state */
;;;160        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
;;;161      }
;;;162    }
000020  bd10              POP      {r4,pc}
;;;163    
                          ENDP

                  I2C_Init PROC
;;;171      */
;;;172    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000022  b510              PUSH     {r4,lr}
;;;173    {
;;;174      uint32_t tmpreg = 0;
;;;175    
;;;176      /* Check the parameters */
;;;177      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;178      assert_param(IS_I2C_ANALOG_FILTER(I2C_InitStruct->I2C_AnalogFilter));
;;;179      assert_param(IS_I2C_DIGITAL_FILTER(I2C_InitStruct->I2C_DigitalFilter));
;;;180      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;181      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;182      assert_param(IS_I2C_ACK(I2C_InitStruct->I2C_Ack));
;;;183      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;184    
;;;185      /* Disable I2Cx Peripheral */
;;;186      I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
000024  6802              LDR      r2,[r0,#0]
000026  0852              LSRS     r2,r2,#1
000028  0052              LSLS     r2,r2,#1
00002a  6002              STR      r2,[r0,#0]
;;;187    
;;;188      /*---------------------------- I2Cx FILTERS Configuration ------------------*/
;;;189      /* Get the I2Cx CR1 value */
;;;190      tmpreg = I2Cx->CR1;
00002c  6802              LDR      r2,[r0,#0]
;;;191      /* Clear I2Cx CR1 register */
;;;192      tmpreg &= CR1_CLEAR_MASK;
00002e  4bbf              LDR      r3,|L1.812|
;;;193      /* Configure I2Cx: analog and digital filter */
;;;194      /* Set ANFOFF bit according to I2C_AnalogFilter value */
;;;195      /* Set DFN bits according to I2C_DigitalFilter value */
;;;196      tmpreg |= (uint32_t)I2C_InitStruct->I2C_AnalogFilter |(I2C_InitStruct->I2C_DigitalFilter << 8);
000030  688c              LDR      r4,[r1,#8]
000032  401a              ANDS     r2,r2,r3              ;192
000034  0224              LSLS     r4,r4,#8
000036  684b              LDR      r3,[r1,#4]
000038  4314              ORRS     r4,r4,r2
00003a  4323              ORRS     r3,r3,r4
;;;197    
;;;198      /* Write to I2Cx CR1 */
;;;199      I2Cx->CR1 = tmpreg;
00003c  6003              STR      r3,[r0,#0]
;;;200    
;;;201      /*---------------------------- I2Cx TIMING Configuration -------------------*/
;;;202      /* Configure I2Cx: Timing */
;;;203      /* Set TIMINGR bits according to I2C_Timing */
;;;204      /* Write to I2Cx TIMING */
;;;205      I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;
00003e  230f              MOVS     r3,#0xf
000040  680a              LDR      r2,[r1,#0]
000042  061b              LSLS     r3,r3,#24
000044  439a              BICS     r2,r2,r3
000046  6102              STR      r2,[r0,#0x10]
;;;206    
;;;207      /* Enable I2Cx Peripheral */
;;;208      I2Cx->CR1 |= I2C_CR1_PE;
000048  6802              LDR      r2,[r0,#0]
00004a  2301              MOVS     r3,#1
00004c  431a              ORRS     r2,r2,r3
00004e  6002              STR      r2,[r0,#0]
;;;209    
;;;210      /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
;;;211      /* Clear tmpreg local variable */
;;;212      tmpreg = 0;
000050  2200              MOVS     r2,#0
;;;213      /* Clear OAR1 register */
;;;214      I2Cx->OAR1 = (uint32_t)tmpreg;
000052  6082              STR      r2,[r0,#8]
;;;215      /* Clear OAR2 register */
;;;216      I2Cx->OAR2 = (uint32_t)tmpreg;
000054  60c2              STR      r2,[r0,#0xc]
;;;217      /* Configure I2Cx: Own Address1 and acknowledged address */
;;;218      /* Set OA1MODE bit according to I2C_AcknowledgedAddress value */
;;;219      /* Set OA1 bits according to I2C_OwnAddress1 value */
;;;220      tmpreg = (uint32_t)((uint32_t)I2C_InitStruct->I2C_AcknowledgedAddress | \
000056  690b              LDR      r3,[r1,#0x10]
000058  698a              LDR      r2,[r1,#0x18]
00005a  431a              ORRS     r2,r2,r3
;;;221                          (uint32_t)I2C_InitStruct->I2C_OwnAddress1);
;;;222      /* Write to I2Cx OAR1 */
;;;223      I2Cx->OAR1 = tmpreg;
00005c  6082              STR      r2,[r0,#8]
;;;224      /* Enable Own Address1 acknowledgement */
;;;225      I2Cx->OAR1 |= I2C_OAR1_OA1EN;
00005e  6882              LDR      r2,[r0,#8]
000060  2301              MOVS     r3,#1
000062  03db              LSLS     r3,r3,#15
000064  431a              ORRS     r2,r2,r3
000066  6082              STR      r2,[r0,#8]
;;;226    
;;;227      /*---------------------------- I2Cx MODE Configuration ---------------------*/
;;;228      /* Configure I2Cx: mode */
;;;229      /* Set SMBDEN and SMBHEN bits according to I2C_Mode value */
;;;230      tmpreg = I2C_InitStruct->I2C_Mode;
;;;231      /* Write to I2Cx CR1 */
;;;232      I2Cx->CR1 |= tmpreg;
000068  68ca              LDR      r2,[r1,#0xc]
00006a  6803              LDR      r3,[r0,#0]
00006c  4313              ORRS     r3,r3,r2
00006e  6003              STR      r3,[r0,#0]
;;;233    
;;;234      /*---------------------------- I2Cx ACK Configuration ----------------------*/
;;;235      /* Get the I2Cx CR2 value */
;;;236      tmpreg = I2Cx->CR2;
000070  6842              LDR      r2,[r0,#4]
;;;237      /* Clear I2Cx CR2 register */
;;;238      tmpreg &= CR2_CLEAR_MASK;
000072  4baf              LDR      r3,|L1.816|
;;;239      /* Configure I2Cx: acknowledgement */
;;;240      /* Set NACK bit according to I2C_Ack value */
;;;241      tmpreg |= I2C_InitStruct->I2C_Ack;
000074  6949              LDR      r1,[r1,#0x14]
000076  401a              ANDS     r2,r2,r3              ;238
000078  4311              ORRS     r1,r1,r2
;;;242      /* Write to I2Cx CR2 */
;;;243      I2Cx->CR2 = tmpreg;
00007a  6041              STR      r1,[r0,#4]
;;;244    }
00007c  bd10              POP      {r4,pc}
;;;245    
                          ENDP

                  I2C_StructInit PROC
;;;250      */
;;;251    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
00007e  2100              MOVS     r1,#0
;;;252    {
;;;253      /*---------------- Reset I2C init structure parameters values --------------*/
;;;254      /* Initialize the I2C_Timing member */
;;;255      I2C_InitStruct->I2C_Timing = 0;
;;;256      /* Initialize the I2C_AnalogFilter member */
;;;257      I2C_InitStruct->I2C_AnalogFilter = I2C_AnalogFilter_Enable;
000080  6001              STR      r1,[r0,#0]
;;;258      /* Initialize the I2C_DigitalFilter member */
;;;259      I2C_InitStruct->I2C_DigitalFilter = 0;
000082  6041              STR      r1,[r0,#4]
;;;260      /* Initialize the I2C_Mode member */
;;;261      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000084  6081              STR      r1,[r0,#8]
;;;262      /* Initialize the I2C_OwnAddress1 member */
;;;263      I2C_InitStruct->I2C_OwnAddress1 = 0;
000086  60c1              STR      r1,[r0,#0xc]
;;;264      /* Initialize the I2C_Ack member */
;;;265      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000088  2201              MOVS     r2,#1
00008a  03d2              LSLS     r2,r2,#15
;;;266      /* Initialize the I2C_AcknowledgedAddress member */
;;;267      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00008c  6101              STR      r1,[r0,#0x10]
00008e  6142              STR      r2,[r0,#0x14]
000090  6181              STR      r1,[r0,#0x18]
;;;268    }
000092  4770              BX       lr
;;;269    
                          ENDP

                  I2C_Cmd PROC
;;;276      */
;;;277    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000094  2900              CMP      r1,#0
;;;278    {
;;;279      /* Check the parameters */
;;;280      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;281      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;282      if (NewState != DISABLE)
;;;283      {
;;;284        /* Enable the selected I2C peripheral */
;;;285        I2Cx->CR1 |= I2C_CR1_PE;
;;;286      }
;;;287      else
;;;288      {
;;;289        /* Disable the selected I2C peripheral */
;;;290        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
000096  6801              LDR      r1,[r0,#0]
000098  d002              BEQ      |L1.160|
00009a  2201              MOVS     r2,#1                 ;285
00009c  4311              ORRS     r1,r1,r2              ;285
00009e  e001              B        |L1.164|
                  |L1.160|
0000a0  0849              LSRS     r1,r1,#1
0000a2  0049              LSLS     r1,r1,#1
                  |L1.164|
0000a4  6001              STR      r1,[r0,#0]            ;285
;;;291      }
;;;292    }
0000a6  4770              BX       lr
;;;293    
                          ENDP

                  I2C_SoftwareResetCmd PROC
;;;300      */
;;;301    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0000a8  2201              MOVS     r2,#1
;;;302    {
;;;303      /* Check the parameters */
;;;304      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;305      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;306      if (NewState != DISABLE)
;;;307      {
;;;308        /* Peripheral under reset */
;;;309        I2Cx->CR1 |= I2C_CR1_SWRST;
0000aa  0352              LSLS     r2,r2,#13
0000ac  2900              CMP      r1,#0                 ;306
;;;310      }
;;;311      else
;;;312      {
;;;313        /* Peripheral not under reset */
;;;314        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_SWRST);
0000ae  6801              LDR      r1,[r0,#0]
0000b0  d001              BEQ      |L1.182|
0000b2  4311              ORRS     r1,r1,r2              ;309
0000b4  e000              B        |L1.184|
                  |L1.182|
0000b6  4391              BICS     r1,r1,r2
                  |L1.184|
0000b8  6001              STR      r1,[r0,#0]            ;309
;;;315      }
;;;316    }
0000ba  4770              BX       lr
;;;317    
                          ENDP

                  I2C_ITConfig PROC
;;;333      */
;;;334    void I2C_ITConfig(I2C_TypeDef* I2Cx, uint32_t I2C_IT, FunctionalState NewState)
0000bc  2a00              CMP      r2,#0
;;;335    {
;;;336      /* Check the parameters */
;;;337      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;338      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;339      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;340      
;;;341      if (NewState != DISABLE)
;;;342      {
;;;343        /* Enable the selected I2C interrupts */
;;;344        I2Cx->CR1 |= I2C_IT;
;;;345      }
;;;346      else
;;;347      {
;;;348        /* Disable the selected I2C interrupts */
;;;349        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_IT);
0000be  6802              LDR      r2,[r0,#0]
0000c0  d001              BEQ      |L1.198|
0000c2  430a              ORRS     r2,r2,r1              ;344
0000c4  e000              B        |L1.200|
                  |L1.198|
0000c6  438a              BICS     r2,r2,r1
                  |L1.200|
0000c8  6002              STR      r2,[r0,#0]            ;344
;;;350      }
;;;351    }
0000ca  4770              BX       lr
;;;352    
                          ENDP

                  I2C_StretchClockCmd PROC
;;;359      */
;;;360    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0000cc  2201              MOVS     r2,#1
;;;361    {
;;;362      /* Check the parameters */
;;;363      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;364      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;365      
;;;366      if (NewState != DISABLE)
;;;367      {
;;;368        /* Enable clock stretching */
;;;369        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_NOSTRETCH);    
0000ce  0452              LSLS     r2,r2,#17
0000d0  2900              CMP      r1,#0                 ;366
;;;370      }
;;;371      else
;;;372      {
;;;373        /* Disable clock stretching  */
;;;374        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
0000d2  6801              LDR      r1,[r0,#0]
0000d4  d001              BEQ      |L1.218|
0000d6  4391              BICS     r1,r1,r2              ;369
0000d8  e000              B        |L1.220|
                  |L1.218|
0000da  4311              ORRS     r1,r1,r2
                  |L1.220|
0000dc  6001              STR      r1,[r0,#0]            ;369
;;;375      }
;;;376    }
0000de  4770              BX       lr
;;;377    
                          ENDP

                  I2C_StopModeCmd PROC
;;;384      */
;;;385    void I2C_StopModeCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0000e0  2201              MOVS     r2,#1
;;;386    {
;;;387      /* Check the parameters */
;;;388      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;389      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;390      
;;;391      if (NewState != DISABLE)
;;;392      {
;;;393        /* Enable wakeup from stop mode */
;;;394        I2Cx->CR1 |= I2C_CR1_WUPEN;   
0000e2  0492              LSLS     r2,r2,#18
0000e4  2900              CMP      r1,#0                 ;391
;;;395      }
;;;396      else
;;;397      {
;;;398        /* Disable wakeup from stop mode */    
;;;399        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_WUPEN); 
0000e6  6801              LDR      r1,[r0,#0]
0000e8  d001              BEQ      |L1.238|
0000ea  4311              ORRS     r1,r1,r2              ;394
0000ec  e000              B        |L1.240|
                  |L1.238|
0000ee  4391              BICS     r1,r1,r2
                  |L1.240|
0000f0  6001              STR      r1,[r0,#0]            ;394
;;;400      }
;;;401    }
0000f2  4770              BX       lr
;;;402    
                          ENDP

                  I2C_DualAddressCmd PROC
;;;409      */
;;;410    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0000f4  2201              MOVS     r2,#1
;;;411    {
;;;412      /* Check the parameters */
;;;413      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;414      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;415      
;;;416      if (NewState != DISABLE)
;;;417      {
;;;418        /* Enable own address 2 */
;;;419        I2Cx->OAR2 |= I2C_OAR2_OA2EN;
0000f6  03d2              LSLS     r2,r2,#15
0000f8  2900              CMP      r1,#0                 ;416
;;;420      }
;;;421      else
;;;422      {
;;;423        /* Disable own address 2 */
;;;424        I2Cx->OAR2 &= (uint32_t)~((uint32_t)I2C_OAR2_OA2EN);
0000fa  68c1              LDR      r1,[r0,#0xc]
0000fc  d001              BEQ      |L1.258|
0000fe  4311              ORRS     r1,r1,r2              ;419
000100  e000              B        |L1.260|
                  |L1.258|
000102  4391              BICS     r1,r1,r2
                  |L1.260|
000104  60c1              STR      r1,[r0,#0xc]          ;419
;;;425      }
;;;426    }    
000106  4770              BX       lr
;;;427    
                          ENDP

                  I2C_OwnAddress2Config PROC
;;;443      */
;;;444    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Mask)
000108  b510              PUSH     {r4,lr}
;;;445    {
;;;446      uint32_t tmpreg = 0;
;;;447    
;;;448      /* Check the parameters */
;;;449      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;450      assert_param(IS_I2C_OWN_ADDRESS2(Address));
;;;451      assert_param(IS_I2C_OWN_ADDRESS2_MASK(Mask));
;;;452      
;;;453      /* Get the old register value */
;;;454      tmpreg = I2Cx->OAR2;
00010a  68c3              LDR      r3,[r0,#0xc]
;;;455    
;;;456      /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
;;;457      tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));
00010c  4c89              LDR      r4,|L1.820|
;;;458    
;;;459      /* Set I2Cx SADD */
;;;460      tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
00010e  0752              LSLS     r2,r2,#29
000110  4023              ANDS     r3,r3,r4              ;457
000112  24fe              MOVS     r4,#0xfe
000114  4021              ANDS     r1,r1,r4
000116  0d52              LSRS     r2,r2,#21
000118  4311              ORRS     r1,r1,r2
00011a  4319              ORRS     r1,r1,r3
;;;461                (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;
;;;462    
;;;463      /* Store the new register value */
;;;464      I2Cx->OAR2 = tmpreg;
00011c  60c1              STR      r1,[r0,#0xc]
;;;465    }
00011e  bd10              POP      {r4,pc}
;;;466    
                          ENDP

                  I2C_GeneralCallCmd PROC
;;;473      */
;;;474    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000120  2201              MOVS     r2,#1
;;;475    {
;;;476      /* Check the parameters */
;;;477      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;478      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;479      
;;;480      if (NewState != DISABLE)
;;;481      {
;;;482        /* Enable general call mode */
;;;483        I2Cx->CR1 |= I2C_CR1_GCEN;
000122  04d2              LSLS     r2,r2,#19
000124  2900              CMP      r1,#0                 ;480
;;;484      }
;;;485      else
;;;486      {
;;;487        /* Disable general call mode */
;;;488        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_GCEN);
000126  6801              LDR      r1,[r0,#0]
000128  d001              BEQ      |L1.302|
00012a  4311              ORRS     r1,r1,r2              ;483
00012c  e000              B        |L1.304|
                  |L1.302|
00012e  4391              BICS     r1,r1,r2
                  |L1.304|
000130  6001              STR      r1,[r0,#0]            ;483
;;;489      }
;;;490    } 
000132  4770              BX       lr
;;;491    
                          ENDP

                  I2C_SlaveByteControlCmd PROC
;;;498      */
;;;499    void I2C_SlaveByteControlCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000134  2201              MOVS     r2,#1
;;;500    {
;;;501      /* Check the parameters */
;;;502      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;503      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;504      
;;;505      if (NewState != DISABLE)
;;;506      {
;;;507        /* Enable slave byte control */
;;;508        I2Cx->CR1 |= I2C_CR1_SBC;
000136  0412              LSLS     r2,r2,#16
000138  2900              CMP      r1,#0                 ;505
;;;509      }
;;;510      else
;;;511      {
;;;512        /* Disable slave byte control */
;;;513        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_SBC);
00013a  6801              LDR      r1,[r0,#0]
00013c  d001              BEQ      |L1.322|
00013e  4311              ORRS     r1,r1,r2              ;508
000140  e000              B        |L1.324|
                  |L1.322|
000142  4391              BICS     r1,r1,r2
                  |L1.324|
000144  6001              STR      r1,[r0,#0]            ;508
;;;514      }
;;;515    }
000146  4770              BX       lr
;;;516    
                          ENDP

                  I2C_SlaveAddressConfig PROC
;;;523      */
;;;524    void I2C_SlaveAddressConfig(I2C_TypeDef* I2Cx, uint16_t Address)
000148  6842              LDR      r2,[r0,#4]
;;;525    {
;;;526      uint32_t tmpreg = 0;
;;;527    
;;;528      /* Check the parameters */
;;;529      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;530      assert_param(IS_I2C_SLAVE_ADDRESS(Address));
;;;531                   
;;;532      /* Get the old register value */
;;;533      tmpreg = I2Cx->CR2;
;;;534    
;;;535      /* Reset I2Cx SADD bit [9:0] */
;;;536      tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_SADD);
;;;537    
;;;538      /* Set I2Cx SADD */
;;;539      tmpreg |= (uint32_t)((uint32_t)Address & I2C_CR2_SADD);
00014a  0589              LSLS     r1,r1,#22
00014c  0a92              LSRS     r2,r2,#10             ;536
00014e  0292              LSLS     r2,r2,#10             ;536
000150  0d89              LSRS     r1,r1,#22
000152  4311              ORRS     r1,r1,r2
;;;540    
;;;541      /* Store the new register value */
;;;542      I2Cx->CR2 = tmpreg;
000154  6041              STR      r1,[r0,#4]
;;;543    }
000156  4770              BX       lr
;;;544      
                          ENDP

                  I2C_10BitAddressingModeCmd PROC
;;;552      */
;;;553    void I2C_10BitAddressingModeCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000158  2201              MOVS     r2,#1
;;;554    {
;;;555      /* Check the parameters */
;;;556      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;557      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;558      
;;;559      if (NewState != DISABLE)
;;;560      {
;;;561        /* Enable 10-bit addressing mode */
;;;562        I2Cx->CR2 |= I2C_CR2_ADD10;
00015a  02d2              LSLS     r2,r2,#11
00015c  2900              CMP      r1,#0                 ;559
;;;563      }
;;;564      else
;;;565      {
;;;566        /* Disable 10-bit addressing mode */
;;;567        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_ADD10);
00015e  6841              LDR      r1,[r0,#4]
000160  d001              BEQ      |L1.358|
000162  4311              ORRS     r1,r1,r2              ;562
000164  e000              B        |L1.360|
                  |L1.358|
000166  4391              BICS     r1,r1,r2
                  |L1.360|
000168  6041              STR      r1,[r0,#4]            ;562
;;;568      }
;;;569    } 
00016a  4770              BX       lr
;;;570    
                          ENDP

                  I2C_AutoEndCmd PROC
;;;617      */
;;;618    void I2C_AutoEndCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00016c  2201              MOVS     r2,#1
;;;619    {
;;;620      /* Check the parameters */
;;;621      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;622      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;623      
;;;624      if (NewState != DISABLE)
;;;625      {
;;;626        /* Enable Auto end mode */
;;;627        I2Cx->CR2 |= I2C_CR2_AUTOEND;
00016e  0652              LSLS     r2,r2,#25
000170  2900              CMP      r1,#0                 ;624
;;;628      }
;;;629      else
;;;630      {
;;;631        /* Disable Auto end mode */
;;;632        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_AUTOEND);
000172  6841              LDR      r1,[r0,#4]
000174  d001              BEQ      |L1.378|
000176  4311              ORRS     r1,r1,r2              ;627
000178  e000              B        |L1.380|
                  |L1.378|
00017a  4391              BICS     r1,r1,r2
                  |L1.380|
00017c  6041              STR      r1,[r0,#4]            ;627
;;;633      }
;;;634    } 
00017e  4770              BX       lr
;;;635    
                          ENDP

                  I2C_ReloadCmd PROC
;;;642      */
;;;643    void I2C_ReloadCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000180  2201              MOVS     r2,#1
;;;644    {
;;;645      /* Check the parameters */
;;;646      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;647      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;648      
;;;649      if (NewState != DISABLE)
;;;650      {
;;;651        /* Enable Auto Reload mode */
;;;652        I2Cx->CR2 |= I2C_CR2_RELOAD;
000182  0612              LSLS     r2,r2,#24
000184  2900              CMP      r1,#0                 ;649
;;;653      }
;;;654      else
;;;655      {
;;;656        /* Disable Auto Reload mode */
;;;657        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RELOAD);
000186  6841              LDR      r1,[r0,#4]
000188  d001              BEQ      |L1.398|
00018a  4311              ORRS     r1,r1,r2              ;652
00018c  e000              B        |L1.400|
                  |L1.398|
00018e  4391              BICS     r1,r1,r2
                  |L1.400|
000190  6041              STR      r1,[r0,#4]            ;652
;;;658      }
;;;659    }
000192  4770              BX       lr
;;;660    
                          ENDP

                  I2C_NumberOfBytesConfig PROC
;;;666      */
;;;667    void I2C_NumberOfBytesConfig(I2C_TypeDef* I2Cx, uint8_t Number_Bytes)
000194  6842              LDR      r2,[r0,#4]
;;;668    {
;;;669      uint32_t tmpreg = 0;
;;;670    
;;;671      /* Check the parameters */
;;;672      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;673    
;;;674      /* Get the old register value */
;;;675      tmpreg = I2Cx->CR2;
;;;676    
;;;677      /* Reset I2Cx Nbytes bit [7:0] */
;;;678      tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_NBYTES);
000196  23ff              MOVS     r3,#0xff
000198  041b              LSLS     r3,r3,#16
00019a  439a              BICS     r2,r2,r3
;;;679    
;;;680      /* Set I2Cx Nbytes */
;;;681      tmpreg |= (uint32_t)(((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES);
00019c  0409              LSLS     r1,r1,#16
00019e  4311              ORRS     r1,r1,r2
;;;682    
;;;683      /* Store the new register value */
;;;684      I2Cx->CR2 = tmpreg;
0001a0  6041              STR      r1,[r0,#4]
;;;685    }  
0001a2  4770              BX       lr
;;;686      
                          ENDP

                  I2C_MasterRequestConfig PROC
;;;695      */
;;;696    void I2C_MasterRequestConfig(I2C_TypeDef* I2Cx, uint16_t I2C_Direction)
0001a4  2201              MOVS     r2,#1
;;;697    {
;;;698    /* Check the parameters */
;;;699      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;700      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;701      
;;;702      /* Test on the direction to set/reset the read/write bit */
;;;703      if (I2C_Direction == I2C_Direction_Transmitter)
;;;704      {
;;;705        /* Request a write Transfer */
;;;706        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RD_WRN);
0001a6  0292              LSLS     r2,r2,#10
0001a8  2900              CMP      r1,#0                 ;703
;;;707      }
;;;708      else
;;;709      {
;;;710        /* Request a read Transfer */
;;;711        I2Cx->CR2 |= I2C_CR2_RD_WRN;
0001aa  6841              LDR      r1,[r0,#4]
0001ac  d002              BEQ      |L1.436|
0001ae  4311              ORRS     r1,r1,r2
                  |L1.432|
0001b0  6041              STR      r1,[r0,#4]            ;706
;;;712      }
;;;713    }  
0001b2  4770              BX       lr
                  |L1.436|
0001b4  4391              BICS     r1,r1,r2              ;706
0001b6  e7fb              B        |L1.432|
;;;714      
                          ENDP

                  I2C_GenerateSTART PROC
;;;721      */
;;;722    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001b8  2201              MOVS     r2,#1
;;;723    {
;;;724      /* Check the parameters */
;;;725      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;726      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;727      
;;;728      if (NewState != DISABLE)
;;;729      {
;;;730        /* Generate a START condition */
;;;731        I2Cx->CR2 |= I2C_CR2_START;
0001ba  0352              LSLS     r2,r2,#13
0001bc  2900              CMP      r1,#0                 ;728
;;;732      }
;;;733      else
;;;734      {
;;;735        /* Disable the START condition generation */
;;;736        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_START);
0001be  6841              LDR      r1,[r0,#4]
0001c0  d001              BEQ      |L1.454|
0001c2  4311              ORRS     r1,r1,r2              ;731
0001c4  e000              B        |L1.456|
                  |L1.454|
0001c6  4391              BICS     r1,r1,r2
                  |L1.456|
0001c8  6041              STR      r1,[r0,#4]            ;731
;;;737      }
;;;738    }  
0001ca  4770              BX       lr
;;;739      
                          ENDP

                  I2C_GenerateSTOP PROC
;;;746      */
;;;747    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001cc  2201              MOVS     r2,#1
;;;748    {
;;;749      /* Check the parameters */
;;;750      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;751      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;752      
;;;753      if (NewState != DISABLE)
;;;754      {
;;;755        /* Generate a STOP condition */
;;;756        I2Cx->CR2 |= I2C_CR2_STOP;
0001ce  0392              LSLS     r2,r2,#14
0001d0  2900              CMP      r1,#0                 ;753
;;;757      }
;;;758      else
;;;759      {
;;;760        /* Disable the STOP condition generation */
;;;761        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_STOP);
0001d2  6841              LDR      r1,[r0,#4]
0001d4  d001              BEQ      |L1.474|
0001d6  4311              ORRS     r1,r1,r2              ;756
0001d8  e000              B        |L1.476|
                  |L1.474|
0001da  4391              BICS     r1,r1,r2
                  |L1.476|
0001dc  6041              STR      r1,[r0,#4]            ;756
;;;762      }
;;;763    }  
0001de  4770              BX       lr
;;;764    
                          ENDP

                  I2C_10BitAddressHeaderCmd PROC
;;;773      */
;;;774    void I2C_10BitAddressHeaderCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001e0  2201              MOVS     r2,#1
;;;775    {
;;;776      /* Check the parameters */
;;;777      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;778      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;779      
;;;780      if (NewState != DISABLE)
;;;781      {
;;;782        /* Enable 10-bit header only mode */
;;;783        I2Cx->CR2 |= I2C_CR2_HEAD10R;
0001e2  0312              LSLS     r2,r2,#12
0001e4  2900              CMP      r1,#0                 ;780
;;;784      }
;;;785      else
;;;786      {
;;;787        /* Disable 10-bit header only mode */
;;;788        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_HEAD10R);
0001e6  6841              LDR      r1,[r0,#4]
0001e8  d001              BEQ      |L1.494|
0001ea  4311              ORRS     r1,r1,r2              ;783
0001ec  e000              B        |L1.496|
                  |L1.494|
0001ee  4391              BICS     r1,r1,r2
                  |L1.496|
0001f0  6041              STR      r1,[r0,#4]            ;783
;;;789      }
;;;790    }    
0001f2  4770              BX       lr
;;;791    
                          ENDP

                  I2C_AcknowledgeConfig PROC
;;;798      */
;;;799    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001f4  2201              MOVS     r2,#1
;;;800    {
;;;801      /* Check the parameters */
;;;802      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;803      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;804      
;;;805      if (NewState != DISABLE)
;;;806      {
;;;807        /* Enable ACK generation */
;;;808        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_NACK);    
0001f6  03d2              LSLS     r2,r2,#15
0001f8  2900              CMP      r1,#0                 ;805
;;;809      }
;;;810      else
;;;811      {
;;;812        /* Enable NACK generation */
;;;813        I2Cx->CR2 |= I2C_CR2_NACK;
0001fa  6841              LDR      r1,[r0,#4]
0001fc  d001              BEQ      |L1.514|
0001fe  4391              BICS     r1,r1,r2              ;808
000200  e000              B        |L1.516|
                  |L1.514|
000202  4311              ORRS     r1,r1,r2
                  |L1.516|
000204  6041              STR      r1,[r0,#4]            ;808
;;;814      }
;;;815    }
000206  4770              BX       lr
;;;816    
                          ENDP

                  I2C_GetAddressMatched PROC
;;;821      */
;;;822    uint8_t I2C_GetAddressMatched(I2C_TypeDef* I2Cx)
000208  6980              LDR      r0,[r0,#0x18]
;;;823    {
;;;824      /* Check the parameters */
;;;825      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;826      
;;;827      /* Return the slave matched address in the SR1 register */
;;;828      return (uint8_t)(((uint32_t)I2Cx->ISR & I2C_ISR_ADDCODE) >> 16) ;
00020a  21fe              MOVS     r1,#0xfe
00020c  0c00              LSRS     r0,r0,#16
00020e  4008              ANDS     r0,r0,r1
;;;829    }
000210  4770              BX       lr
;;;830    
                          ENDP

                  I2C_GetTransferDirection PROC
;;;835      */
;;;836    uint16_t I2C_GetTransferDirection(I2C_TypeDef* I2Cx)
000212  4601              MOV      r1,r0
;;;837    {
;;;838      uint32_t tmpreg = 0;
;;;839      uint16_t direction = 0;
;;;840      
;;;841      /* Check the parameters */
;;;842      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;843      
;;;844      /* Return the slave matched address in the SR1 register */
;;;845      tmpreg = (uint32_t)(I2Cx->ISR & I2C_ISR_DIR);
000214  6989              LDR      r1,[r1,#0x18]
000216  2000              MOVS     r0,#0                 ;839
000218  2201              MOVS     r2,#1
00021a  0412              LSLS     r2,r2,#16
00021c  4211              TST      r1,r2
00021e  d000              BEQ      |L1.546|
;;;846      
;;;847      /* If write transfer is requested */
;;;848      if (tmpreg == 0)
;;;849      {
;;;850        /* write transfer is requested */
;;;851        direction = I2C_Direction_Transmitter;
;;;852      }
;;;853      else
;;;854      {
;;;855        /* Read transfer is requested */
;;;856        direction = I2C_Direction_Receiver;
000220  1190              ASRS     r0,r2,#6
                  |L1.546|
;;;857      }  
;;;858      return direction;
;;;859    }
000222  4770              BX       lr
;;;860    
                          ENDP

                  I2C_TransferHandling PROC
;;;879      */
;;;880    void I2C_TransferHandling(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Number_Bytes, uint32_t ReloadEndMode, uint32_t StartStopMode)
000224  b570              PUSH     {r4-r6,lr}
;;;881    {
;;;882      uint32_t tmpreg = 0;
;;;883      
;;;884      /* Check the parameters */
;;;885      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;886      assert_param(IS_I2C_SLAVE_ADDRESS(Address));  
;;;887      assert_param(IS_RELOAD_END_MODE(ReloadEndMode));
;;;888      assert_param(IS_START_STOP_MODE(StartStopMode));
;;;889        
;;;890      /* Get the CR2 register value */
;;;891      tmpreg = I2Cx->CR2;
000226  9d04              LDR      r5,[sp,#0x10]
000228  6844              LDR      r4,[r0,#4]
;;;892      
;;;893      /* clear tmpreg specific bits */
;;;894      tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
;;;895      
;;;896      /* update tmpreg */
;;;897      tmpreg |= (uint32_t)(((uint32_t)Address & I2C_CR2_SADD) | (((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES) | \
00022a  0589              LSLS     r1,r1,#22
00022c  0d89              LSRS     r1,r1,#22
00022e  0412              LSLS     r2,r2,#16
000230  4e41              LDR      r6,|L1.824|
000232  4311              ORRS     r1,r1,r2
000234  4319              ORRS     r1,r1,r3
000236  4034              ANDS     r4,r4,r6              ;894
000238  4329              ORRS     r1,r1,r5
00023a  4321              ORRS     r1,r1,r4
;;;898                (uint32_t)ReloadEndMode | (uint32_t)StartStopMode);
;;;899      
;;;900      /* update CR2 register */
;;;901      I2Cx->CR2 = tmpreg;  
00023c  6041              STR      r1,[r0,#4]
;;;902    }
00023e  bd70              POP      {r4-r6,pc}
;;;903    
                          ENDP

                  I2C_SMBusAlertCmd PROC
;;;950      */
;;;951    void I2C_SMBusAlertCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000240  2201              MOVS     r2,#1
;;;952    {
;;;953      /* Check the parameters */
;;;954      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;955      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;956      
;;;957      if (NewState != DISABLE)
;;;958      {
;;;959        /* Enable SMBus alert */
;;;960        I2Cx->CR1 |= I2C_CR1_ALERTEN;   
000242  0592              LSLS     r2,r2,#22
000244  2900              CMP      r1,#0                 ;957
;;;961      }
;;;962      else
;;;963      {
;;;964        /* Disable SMBus alert */    
;;;965        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_ALERTEN); 
000246  6801              LDR      r1,[r0,#0]
000248  d001              BEQ      |L1.590|
00024a  4311              ORRS     r1,r1,r2              ;960
00024c  e000              B        |L1.592|
                  |L1.590|
00024e  4391              BICS     r1,r1,r2
                  |L1.592|
000250  6001              STR      r1,[r0,#0]            ;960
;;;966      }
;;;967    }
000252  4770              BX       lr
;;;968    
                          ENDP

                  I2C_ClockTimeoutCmd PROC
;;;975      */
;;;976    void I2C_ClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000254  2201              MOVS     r2,#1
;;;977    {
;;;978      /* Check the parameters */
;;;979      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;980      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;981      
;;;982      if (NewState != DISABLE)
;;;983      {
;;;984        /* Enable Clock Timeout */
;;;985        I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIMOUTEN;   
000256  03d2              LSLS     r2,r2,#15
000258  2900              CMP      r1,#0                 ;982
;;;986      }
;;;987      else
;;;988      {
;;;989        /* Disable Clock Timeout */    
;;;990        I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMOUTEN); 
00025a  6941              LDR      r1,[r0,#0x14]
00025c  d001              BEQ      |L1.610|
00025e  4311              ORRS     r1,r1,r2              ;985
000260  e000              B        |L1.612|
                  |L1.610|
000262  4391              BICS     r1,r1,r2
                  |L1.612|
000264  6141              STR      r1,[r0,#0x14]         ;985
;;;991      }
;;;992    }
000266  4770              BX       lr
;;;993    
                          ENDP

                  I2C_ExtendedClockTimeoutCmd PROC
;;;1000     */
;;;1001   void I2C_ExtendedClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000268  2900              CMP      r1,#0
;;;1002   {
;;;1003     /* Check the parameters */
;;;1004     assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;1005     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1006     
;;;1007     if (NewState != DISABLE)
;;;1008     {
;;;1009       /* Enable Clock Timeout */
;;;1010       I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TEXTEN;   
;;;1011     }
;;;1012     else
;;;1013     {
;;;1014       /* Disable Clock Timeout */    
;;;1015       I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TEXTEN); 
00026a  6941              LDR      r1,[r0,#0x14]
00026c  d003              BEQ      |L1.630|
00026e  2201              MOVS     r2,#1                 ;1010
000270  07d2              LSLS     r2,r2,#31             ;1010
000272  4311              ORRS     r1,r1,r2              ;1010
000274  e001              B        |L1.634|
                  |L1.630|
000276  0049              LSLS     r1,r1,#1
000278  0849              LSRS     r1,r1,#1
                  |L1.634|
00027a  6141              STR      r1,[r0,#0x14]         ;1010
;;;1016     }
;;;1017   }
00027c  4770              BX       lr
;;;1018   
                          ENDP

                  I2C_IdleClockTimeoutCmd PROC
;;;1026     */
;;;1027   void I2C_IdleClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00027e  2201              MOVS     r2,#1
;;;1028   {
;;;1029     /* Check the parameters */
;;;1030     assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;1031     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1032     
;;;1033     if (NewState != DISABLE)
;;;1034     {
;;;1035       /* Enable Clock Timeout */
;;;1036       I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIDLE;   
000280  0312              LSLS     r2,r2,#12
000282  2900              CMP      r1,#0                 ;1033
;;;1037     }
;;;1038     else
;;;1039     {
;;;1040       /* Disable Clock Timeout */    
;;;1041       I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIDLE); 
000284  6941              LDR      r1,[r0,#0x14]
000286  d001              BEQ      |L1.652|
000288  4311              ORRS     r1,r1,r2              ;1036
00028a  e000              B        |L1.654|
                  |L1.652|
00028c  4391              BICS     r1,r1,r2
                  |L1.654|
00028e  6141              STR      r1,[r0,#0x14]         ;1036
;;;1042     }
;;;1043   }
000290  4770              BX       lr
;;;1044   
                          ENDP

                  I2C_TimeoutAConfig PROC
;;;1051     */
;;;1052   void I2C_TimeoutAConfig(I2C_TypeDef* I2Cx, uint16_t Timeout)
000292  6942              LDR      r2,[r0,#0x14]
;;;1053   {
;;;1054     uint32_t tmpreg = 0;
;;;1055   
;;;1056     /* Check the parameters */
;;;1057     assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;1058     assert_param(IS_I2C_TIMEOUT(Timeout));
;;;1059       
;;;1060     /* Get the old register value */
;;;1061     tmpreg = I2Cx->TIMEOUTR;
;;;1062   
;;;1063     /* Reset I2Cx TIMEOUTA bit [11:0] */
;;;1064     tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTA);
;;;1065   
;;;1066     /* Set I2Cx TIMEOUTA */
;;;1067     tmpreg |= (uint32_t)((uint32_t)Timeout & I2C_TIMEOUTR_TIMEOUTA) ;
000294  0509              LSLS     r1,r1,#20
000296  0b12              LSRS     r2,r2,#12             ;1064
000298  0312              LSLS     r2,r2,#12             ;1064
00029a  0d09              LSRS     r1,r1,#20
00029c  4311              ORRS     r1,r1,r2
;;;1068   
;;;1069     /* Store the new register value */
;;;1070     I2Cx->TIMEOUTR = tmpreg;
00029e  6141              STR      r1,[r0,#0x14]
;;;1071   }
0002a0  4770              BX       lr
;;;1072   
                          ENDP

                  I2C_TimeoutBConfig PROC
;;;1078     */
;;;1079   void I2C_TimeoutBConfig(I2C_TypeDef* I2Cx, uint16_t Timeout)
0002a2  6942              LDR      r2,[r0,#0x14]
;;;1080   {
;;;1081     uint32_t tmpreg = 0;
;;;1082   
;;;1083     /* Check the parameters */
;;;1084     assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;1085     assert_param(IS_I2C_TIMEOUT(Timeout));
;;;1086   
;;;1087     /* Get the old register value */
;;;1088     tmpreg = I2Cx->TIMEOUTR;
;;;1089   
;;;1090     /* Reset I2Cx TIMEOUTB bit [11:0] */
;;;1091     tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTB);
0002a4  4b25              LDR      r3,|L1.828|
;;;1092   
;;;1093     /* Set I2Cx TIMEOUTB */
;;;1094     tmpreg |= (uint32_t)(((uint32_t)Timeout << 16) & I2C_TIMEOUTR_TIMEOUTB) ;
0002a6  0509              LSLS     r1,r1,#20
0002a8  401a              ANDS     r2,r2,r3              ;1091
0002aa  0909              LSRS     r1,r1,#4
0002ac  4311              ORRS     r1,r1,r2
;;;1095   
;;;1096     /* Store the new register value */
;;;1097     I2Cx->TIMEOUTR = tmpreg;
0002ae  6141              STR      r1,[r0,#0x14]
;;;1098   }
0002b0  4770              BX       lr
;;;1099   
                          ENDP

                  I2C_CalculatePEC PROC
;;;1106     */
;;;1107   void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
0002b2  2201              MOVS     r2,#1
;;;1108   {
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;1111     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1112     
;;;1113     if (NewState != DISABLE)
;;;1114     {
;;;1115       /* Enable PEC calculation */
;;;1116       I2Cx->CR1 |= I2C_CR1_PECEN;   
0002b4  05d2              LSLS     r2,r2,#23
0002b6  2900              CMP      r1,#0                 ;1113
;;;1117     }
;;;1118     else
;;;1119     {
;;;1120       /* Disable PEC calculation */    
;;;1121       I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PECEN); 
0002b8  6801              LDR      r1,[r0,#0]
0002ba  d001              BEQ      |L1.704|
0002bc  4311              ORRS     r1,r1,r2              ;1116
0002be  e000              B        |L1.706|
                  |L1.704|
0002c0  4391              BICS     r1,r1,r2
                  |L1.706|
0002c2  6001              STR      r1,[r0,#0]            ;1116
;;;1122     }
;;;1123   }
0002c4  4770              BX       lr
;;;1124   
                          ENDP

                  I2C_PECRequestCmd PROC
;;;1131     */
;;;1132   void I2C_PECRequestCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0002c6  2201              MOVS     r2,#1
;;;1133   {
;;;1134     /* Check the parameters */
;;;1135     assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;1136     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1137     
;;;1138     if (NewState != DISABLE)
;;;1139     {
;;;1140       /* Enable PEC transmission/reception request */
;;;1141       I2Cx->CR1 |= I2C_CR2_PECBYTE;   
0002c8  0692              LSLS     r2,r2,#26
0002ca  2900              CMP      r1,#0                 ;1138
;;;1142     }
;;;1143     else
;;;1144     {
;;;1145       /* Disable PEC transmission/reception request */    
;;;1146       I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR2_PECBYTE); 
0002cc  6801              LDR      r1,[r0,#0]
0002ce  d001              BEQ      |L1.724|
0002d0  4311              ORRS     r1,r1,r2              ;1141
0002d2  e000              B        |L1.726|
                  |L1.724|
0002d4  4391              BICS     r1,r1,r2
                  |L1.726|
0002d6  6001              STR      r1,[r0,#0]            ;1141
;;;1147     }
;;;1148   }
0002d8  4770              BX       lr
;;;1149   
                          ENDP

                  I2C_GetPEC PROC
;;;1154     */
;;;1155   uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
0002da  6a00              LDR      r0,[r0,#0x20]
;;;1156   {
;;;1157     /* Check the parameters */
;;;1158     assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;1159     
;;;1160     /* Return the slave matched address in the SR1 register */
;;;1161     return (uint8_t)((uint32_t)I2Cx->PECR & I2C_PECR_PEC);
0002dc  b2c0              UXTB     r0,r0
;;;1162   }
0002de  4770              BX       lr
;;;1163   
                          ENDP

                  I2C_ReadRegister PROC
;;;1200     */
;;;1201   uint32_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
0002e0  b508              PUSH     {r3,lr}
;;;1202   {
;;;1203     __IO uint32_t tmp = 0;
;;;1204   
;;;1205     /* Check the parameters */
;;;1206     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1207     assert_param(IS_I2C_REGISTER(I2C_Register));
;;;1208   
;;;1209     tmp = (uint32_t)I2Cx;
;;;1210     tmp += I2C_Register;
0002e2  1840              ADDS     r0,r0,r1
;;;1211   
;;;1212     /* Return the selected register value */
;;;1213     return (*(__IO uint32_t *) tmp);
0002e4  9000              STR      r0,[sp,#0]
0002e6  6800              LDR      r0,[r0,#0]
;;;1214   }
0002e8  bd08              POP      {r3,pc}
;;;1215   
                          ENDP

                  I2C_SendData PROC
;;;1243     */
;;;1244   void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
0002ea  6281              STR      r1,[r0,#0x28]
;;;1245   {
;;;1246     /* Check the parameters */
;;;1247     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1248     
;;;1249     /* Write in the DR register the data to be sent */
;;;1250     I2Cx->TXDR = (uint8_t)Data;
;;;1251   }
0002ec  4770              BX       lr
;;;1252   
                          ENDP

                  I2C_ReceiveData PROC
;;;1257     */
;;;1258   uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
0002ee  6a40              LDR      r0,[r0,#0x24]
;;;1259   {
;;;1260     /* Check the parameters */
;;;1261     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1262     
;;;1263     /* Return the data in the DR register */
;;;1264     return (uint8_t)I2Cx->RXDR;
0002f0  b2c0              UXTB     r0,r0
;;;1265   }  
0002f2  4770              BX       lr
;;;1266   
                          ENDP

                  I2C_DMACmd PROC
;;;1300     */
;;;1301   void I2C_DMACmd(I2C_TypeDef* I2Cx, uint32_t I2C_DMAReq, FunctionalState NewState)
0002f4  2a00              CMP      r2,#0
;;;1302   {
;;;1303     /* Check the parameters */
;;;1304     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1305     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1306     assert_param(IS_I2C_DMA_REQ(I2C_DMAReq));
;;;1307   
;;;1308     if (NewState != DISABLE)
;;;1309     {
;;;1310       /* Enable the selected I2C DMA requests */
;;;1311       I2Cx->CR1 |= I2C_DMAReq;
;;;1312     }
;;;1313     else
;;;1314     {
;;;1315       /* Disable the selected I2C DMA requests */
;;;1316       I2Cx->CR1 &= (uint32_t)~I2C_DMAReq;
0002f6  6802              LDR      r2,[r0,#0]
0002f8  d001              BEQ      |L1.766|
0002fa  430a              ORRS     r2,r2,r1              ;1311
0002fc  e000              B        |L1.768|
                  |L1.766|
0002fe  438a              BICS     r2,r2,r1
                  |L1.768|
000300  6002              STR      r2,[r0,#0]            ;1311
;;;1317     }
;;;1318   }
000302  4770              BX       lr
;;;1319   /**
                          ENDP

                  I2C_GetFlagStatus PROC
;;;1420     */
;;;1421   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000304  4602              MOV      r2,r0
;;;1422   {
;;;1423     uint32_t tmpreg = 0;
;;;1424     FlagStatus bitstatus = RESET;
;;;1425     
;;;1426     /* Check the parameters */
;;;1427     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1428     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1429     
;;;1430     /* Get the ISR register value */
;;;1431     tmpreg = I2Cx->ISR;
000306  6992              LDR      r2,[r2,#0x18]
000308  2000              MOVS     r0,#0                 ;1424
;;;1432     
;;;1433     /* Get flag status */
;;;1434     tmpreg &= I2C_FLAG;
00030a  420a              TST      r2,r1
00030c  d000              BEQ      |L1.784|
;;;1435     
;;;1436     if(tmpreg != 0)
;;;1437     {
;;;1438       /* I2C_FLAG is set */
;;;1439       bitstatus = SET;
00030e  2001              MOVS     r0,#1
                  |L1.784|
;;;1440     }
;;;1441     else
;;;1442     {
;;;1443       /* I2C_FLAG is reset */
;;;1444       bitstatus = RESET;
;;;1445     }
;;;1446     return bitstatus;
;;;1447   } 
000310  4770              BX       lr
;;;1448   
                          ENDP

                  I2C_ClearFlag PROC
;;;1464     */
;;;1465   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000312  61c1              STR      r1,[r0,#0x1c]
;;;1466   { 
;;;1467     /* Check the parameters */
;;;1468     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1469     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1470   
;;;1471     /* Clear the selected flag */
;;;1472     I2Cx->ICR = I2C_FLAG;
;;;1473     }
000314  4770              BX       lr
;;;1474   
                          ENDP

                  I2C_GetITStatus PROC
;;;1494     */
;;;1495   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000316  4602              MOV      r2,r0
;;;1496   {
;;;1497     uint32_t tmpreg = 0;
;;;1498     ITStatus bitstatus = RESET;
;;;1499     
;;;1500     /* Check the parameters */
;;;1501     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1502     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1503     
;;;1504     /* Get the ISR register value */
;;;1505     tmpreg = I2Cx->ISR;
000318  6992              LDR      r2,[r2,#0x18]
00031a  2000              MOVS     r0,#0                 ;1498
;;;1506     
;;;1507     /* Get flag status */
;;;1508     tmpreg &= I2C_IT;
00031c  420a              TST      r2,r1
00031e  d000              BEQ      |L1.802|
;;;1509     
;;;1510     if(tmpreg != 0)
;;;1511     {
;;;1512       /* I2C_IT is set */
;;;1513       bitstatus = SET;
000320  2001              MOVS     r0,#1
                  |L1.802|
;;;1514     }
;;;1515     else
;;;1516     {
;;;1517       /* I2C_IT is reset */
;;;1518       bitstatus = RESET;
;;;1519     }
;;;1520     return bitstatus;
;;;1521   } 
000322  4770              BX       lr
;;;1522   
                          ENDP

                  I2C_ClearITPendingBit PROC
;;;1538     */
;;;1539   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000324  61c1              STR      r1,[r0,#0x1c]
;;;1540   {
;;;1541     /* Check the parameters */
;;;1542     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1543     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1544   
;;;1545     /* Clear the selected flag */
;;;1546     I2Cx->ICR = I2C_IT;
;;;1547   }
000326  4770              BX       lr
;;;1548   
                          ENDP

                  |L1.808|
                          DCD      0x40005400
                  |L1.812|
                          DCD      0x00cfe0ff
                  |L1.816|
                          DCD      0x07ff7fff
                  |L1.820|
                          DCD      0xfffff801
                  |L1.824|
                          DCD      0xfc009800
                  |L1.828|
                          DCD      0xf000ffff

;*** Start embedded assembler ***

#line 1 "..\\arch\\arm\\stm32f05x\\lib\\src\\stm32f0xx_i2c.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_i2c_c_7174d409____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f0xx_i2c_c_7174d409____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_i2c_c_7174d409____REVSH|
#line 144
|__asm___15_stm32f0xx_i2c_c_7174d409____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
