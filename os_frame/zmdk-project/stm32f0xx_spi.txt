; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\stm32f0xx_spi.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f0xx_spi.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\stm32f0xx_spi.crf ..\arch\arm\stm32f05x\lib\src\stm32f0xx_spi.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SPI_I2S_DeInit PROC
;;;163      */
;;;164    void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
000000  49b2              LDR      r1,|L1.716|
;;;165    {
000002  b510              PUSH     {r4,lr}
;;;166      /* Check the parameters */
;;;167      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;168    
;;;169      if (SPIx == SPI1)
000004  4288              CMP      r0,r1
000006  d109              BNE      |L1.28|
;;;170      {
;;;171        /* Enable SPI1 reset state */
;;;172        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
000008  1484              ASRS     r4,r0,#18
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;173        /* Release SPI1 from reset state */
;;;174        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
000012  2100              MOVS     r1,#0
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L1.26|
;;;175      }
;;;176      else
;;;177      {
;;;178        if (SPIx == SPI2)
;;;179        {
;;;180          /* Enable SPI2 reset state */
;;;181          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
;;;182          /* Release SPI2 from reset state */
;;;183          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
;;;184        }
;;;185      }
;;;186    }
00001a  bd10              POP      {r4,pc}
                  |L1.28|
00001c  49ac              LDR      r1,|L1.720|
00001e  4288              CMP      r0,r1                 ;178
000020  d1fb              BNE      |L1.26|
000022  1404              ASRS     r4,r0,#16             ;181
000024  2101              MOVS     r1,#1                 ;181
000026  4620              MOV      r0,r4                 ;181
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
00002c  2100              MOVS     r1,#0                 ;183
00002e  4620              MOV      r0,r4                 ;183
000030  f7fffffe          BL       RCC_APB1PeriphResetCmd
000034  bd10              POP      {r4,pc}
;;;187    
                          ENDP

                  SPI_StructInit PROC
;;;192      */
;;;193    void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
000036  2100              MOVS     r1,#0
;;;194    {
;;;195    /*--------------- Reset SPI init structure parameters values -----------------*/
;;;196      /* Initialize the SPI_Direction member */
;;;197      SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
000038  8001              STRH     r1,[r0,#0]
;;;198      /* Initialize the SPI_Mode member */
;;;199      SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
;;;200      /* Initialize the SPI_DataSize member */
;;;201      SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
00003a  2207              MOVS     r2,#7
00003c  8041              STRH     r1,[r0,#2]            ;199
00003e  0212              LSLS     r2,r2,#8
000040  8082              STRH     r2,[r0,#4]
;;;202      /* Initialize the SPI_CPOL member */
;;;203      SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
000042  80c1              STRH     r1,[r0,#6]
;;;204      /* Initialize the SPI_CPHA member */
;;;205      SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
000044  8101              STRH     r1,[r0,#8]
;;;206      /* Initialize the SPI_NSS member */
;;;207      SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
000046  8141              STRH     r1,[r0,#0xa]
;;;208      /* Initialize the SPI_BaudRatePrescaler member */
;;;209      SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
000048  8181              STRH     r1,[r0,#0xc]
;;;210      /* Initialize the SPI_FirstBit member */
;;;211      SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
00004a  81c1              STRH     r1,[r0,#0xe]
;;;212      /* Initialize the SPI_CRCPolynomial member */
;;;213      SPI_InitStruct->SPI_CRCPolynomial = 7;
00004c  2107              MOVS     r1,#7
00004e  8201              STRH     r1,[r0,#0x10]
;;;214    }
000050  4770              BX       lr
;;;215    
                          ENDP

                  SPI_Init PROC
;;;223      */
;;;224    void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
000052  b530              PUSH     {r4,r5,lr}
;;;225    {
;;;226      uint16_t tmpreg = 0;
;;;227    
;;;228      /* check the parameters */
;;;229      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;230    
;;;231      /* Check the SPI parameters */
;;;232      assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
;;;233      assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
;;;234      assert_param(IS_SPI_DATA_SIZE(SPI_InitStruct->SPI_DataSize));
;;;235      assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
;;;236      assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
;;;237      assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
;;;238      assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
;;;239      assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
;;;240      assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
;;;241    
;;;242      /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;243      /* Get the SPIx CR1 value */
;;;244      tmpreg = SPIx->CR1;
000054  8803              LDRH     r3,[r0,#0]
;;;245      /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, CPOL and CPHA bits */
;;;246      tmpreg &= CR1_CLEAR_MASK;
000056  22c1              MOVS     r2,#0xc1
000058  0192              LSLS     r2,r2,#6
00005a  4013              ANDS     r3,r3,r2
;;;247      /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
;;;248      master/slave mode, CPOL and CPHA */
;;;249      /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
;;;250      /* Set SSM, SSI bit according to SPI_NSS values */
;;;251      /* Set LSBFirst bit according to SPI_FirstBit value */
;;;252      /* Set BR bits according to SPI_BaudRatePrescaler value */
;;;253      /* Set CPOL bit according to SPI_CPOL value */
;;;254      /* Set CPHA bit according to SPI_CPHA value */
;;;255      tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_FirstBit |
00005c  880a              LDRH     r2,[r1,#0]
00005e  89cc              LDRH     r4,[r1,#0xe]
000060  890d              LDRH     r5,[r1,#8]
000062  4322              ORRS     r2,r2,r4
000064  88cc              LDRH     r4,[r1,#6]
000066  432c              ORRS     r4,r4,r5
000068  4322              ORRS     r2,r2,r4
00006a  894c              LDRH     r4,[r1,#0xa]
00006c  4322              ORRS     r2,r2,r4
00006e  898c              LDRH     r4,[r1,#0xc]
000070  4322              ORRS     r2,r2,r4
000072  431a              ORRS     r2,r2,r3
;;;256                          SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA |
;;;257                          SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler);  
;;;258      /* Write to SPIx CR1 */
;;;259      SPIx->CR1 = tmpreg;
000074  8002              STRH     r2,[r0,#0]
;;;260      /*-------------------------Data Size Configuration -----------------------*/
;;;261      /* Get the SPIx CR2 value */
;;;262      tmpreg = SPIx->CR2;
000076  8882              LDRH     r2,[r0,#4]
;;;263      /* Clear DS[3:0] bits */
;;;264      tmpreg &=(uint16_t)~SPI_CR2_DS;
000078  4b96              LDR      r3,|L1.724|
00007a  401a              ANDS     r2,r2,r3
;;;265      /* Configure SPIx: Data Size */
;;;266      tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
00007c  888b              LDRH     r3,[r1,#4]
00007e  4313              ORRS     r3,r3,r2
;;;267      /* Write to SPIx CR2 */
;;;268      SPIx->CR2 = tmpreg;
000080  8083              STRH     r3,[r0,#4]
;;;269      
;;;270      /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;271      /* Write to SPIx CRCPOLY */
;;;272      SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
000082  8a0a              LDRH     r2,[r1,#0x10]
000084  8202              STRH     r2,[r0,#0x10]
;;;273      
;;;274      /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;275      /* Get the SPIx CR1 value */
;;;276      tmpreg = SPIx->CR1;
000086  8802              LDRH     r2,[r0,#0]
;;;277      /* Clear MSTR bit */
;;;278      tmpreg &= CR1_CLEAR_MASK2;
000088  2304              MOVS     r3,#4
;;;279      /* Configure SPIx: master/slave mode */  
;;;280      /* Set MSTR bit according to SPI_Mode */
;;;281      tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Mode);  
00008a  8849              LDRH     r1,[r1,#2]
00008c  439a              BICS     r2,r2,r3              ;278
00008e  4311              ORRS     r1,r1,r2
;;;282      /* Write to SPIx CR1 */
;;;283      SPIx->CR1 = tmpreg;  
000090  8001              STRH     r1,[r0,#0]
;;;284      
;;;285      /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;286      SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
000092  8b81              LDRH     r1,[r0,#0x1c]
000094  4a90              LDR      r2,|L1.728|
000096  4011              ANDS     r1,r1,r2
000098  8381              STRH     r1,[r0,#0x1c]
;;;287    }
00009a  bd30              POP      {r4,r5,pc}
;;;288    
                          ENDP

                  I2S_StructInit PROC
;;;293      */
;;;294    void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
00009c  2100              MOVS     r1,#0
;;;295    {
;;;296    /*--------------- Reset I2S init structure parameters values -----------------*/
;;;297      /* Initialize the I2S_Mode member */
;;;298      I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
00009e  8001              STRH     r1,[r0,#0]
;;;299    
;;;300      /* Initialize the I2S_Standard member */
;;;301      I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
0000a0  8041              STRH     r1,[r0,#2]
;;;302    
;;;303      /* Initialize the I2S_DataFormat member */
;;;304      I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
0000a2  8081              STRH     r1,[r0,#4]
;;;305    
;;;306      /* Initialize the I2S_MCLKOutput member */
;;;307      I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
0000a4  80c1              STRH     r1,[r0,#6]
;;;308    
;;;309      /* Initialize the I2S_AudioFreq member */
;;;310      I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
0000a6  2202              MOVS     r2,#2
;;;311    
;;;312      /* Initialize the I2S_CPOL member */
;;;313      I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
0000a8  6082              STR      r2,[r0,#8]
0000aa  8181              STRH     r1,[r0,#0xc]
;;;314    }
0000ac  4770              BX       lr
;;;315    
                          ENDP

                  I2S_Init PROC
;;;329      */
;;;330    void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
0000ae  b5f0              PUSH     {r4-r7,lr}
;;;331    {
0000b0  4605              MOV      r5,r0
0000b2  460c              MOV      r4,r1
;;;332      uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
0000b4  2002              MOVS     r0,#2
0000b6  2100              MOVS     r1,#0
;;;333      uint32_t tmp = 0;
;;;334      RCC_ClocksTypeDef RCC_Clocks;
;;;335      uint32_t sourceclock = 0;
;;;336    
;;;337      /* Check the I2S parameters */
;;;338      assert_param(IS_SPI_1_PERIPH(SPIx));
;;;339      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
;;;340      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
;;;341      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
;;;342      assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
;;;343      assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
;;;344      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
;;;345    
;;;346    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;347      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;348      SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
0000b8  8baa              LDRH     r2,[r5,#0x1c]
0000ba  b087              SUB      sp,sp,#0x1c           ;331
0000bc  2601              MOVS     r6,#1                 ;332
0000be  4b85              LDR      r3,|L1.724|
0000c0  3bbf              SUBS     r3,r3,#0xbf
0000c2  401a              ANDS     r2,r2,r3
0000c4  83aa              STRH     r2,[r5,#0x1c]
;;;349      SPIx->I2SPR = 0x0002;
0000c6  8428              STRH     r0,[r5,#0x20]
;;;350    
;;;351      /* Get the I2SCFGR register value */
;;;352      tmpreg = SPIx->I2SCFGR;
0000c8  8baf              LDRH     r7,[r5,#0x1c]
;;;353    
;;;354      /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
;;;355      if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
0000ca  68a2              LDR      r2,[r4,#8]
0000cc  2a02              CMP      r2,#2
0000ce  d024              BEQ      |L1.282|
;;;356      {
;;;357        i2sodd = (uint16_t)0;
;;;358        i2sdiv = (uint16_t)2;   
;;;359      }
;;;360      /* If the requested audio frequency is not the default, compute the prescaler */
;;;361      else
;;;362      {
;;;363        /* Check the frame length (For the Prescaler computing) */
;;;364        if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
0000d0  88a0              LDRH     r0,[r4,#4]
0000d2  2800              CMP      r0,#0
0000d4  d000              BEQ      |L1.216|
;;;365        {
;;;366          /* Packet length is 16 bits */
;;;367          packetlength = 1;
;;;368        }
;;;369        else
;;;370        {
;;;371          /* Packet length is 32 bits */
;;;372          packetlength = 2;
0000d6  2602              MOVS     r6,#2
                  |L1.216|
;;;373        }
;;;374    
;;;375        /* I2S Clock source is System clock: Get System Clock frequency */
;;;376        RCC_GetClocksFreq(&RCC_Clocks);      
0000d8  4668              MOV      r0,sp
0000da  f7fffffe          BL       RCC_GetClocksFreq
;;;377    
;;;378        /* Get the source clock value: based on System Clock value */
;;;379        sourceclock = RCC_Clocks.SYSCLK_Frequency;    
;;;380    
;;;381        /* Compute the Real divider depending on the MCLK output state with a floating point */
;;;382        if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
0000de  88e1              LDRH     r1,[r4,#6]
0000e0  9800              LDR      r0,[sp,#0]
0000e2  1fca              SUBS     r2,r1,#7
0000e4  3aff              SUBS     r2,r2,#0xff
0000e6  3afa              SUBS     r2,r2,#0xfa
0000e8  d104              BNE      |L1.244|
;;;383        {
;;;384          /* MCLK output is enabled */
;;;385          tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
0000ea  0a00              LSRS     r0,r0,#8
0000ec  220a              MOVS     r2,#0xa
0000ee  4350              MULS     r0,r2,r0
0000f0  68a1              LDR      r1,[r4,#8]
0000f2  e005              B        |L1.256|
                  |L1.244|
;;;386        }
;;;387        else
;;;388        {
;;;389          /* MCLK output is disabled */
;;;390          tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
0000f4  0171              LSLS     r1,r6,#5
0000f6  f7fffffe          BL       __aeabi_uidivmod
0000fa  210a              MOVS     r1,#0xa
0000fc  4348              MULS     r0,r1,r0
0000fe  68a1              LDR      r1,[r4,#8]
                  |L1.256|
000100  f7fffffe          BL       __aeabi_uidivmod
000104  1d40              ADDS     r0,r0,#5
000106  b280              UXTH     r0,r0
;;;391        }
;;;392        
;;;393        /* Remove the floating point */
;;;394        tmp = tmp / 10;
000108  210a              MOVS     r1,#0xa
00010a  f7fffffe          BL       __aeabi_uidivmod
;;;395    
;;;396        /* Check the parity of the divider */
;;;397        i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
00010e  07c1              LSLS     r1,r0,#31
000110  0fc9              LSRS     r1,r1,#31
;;;398    
;;;399        /* Compute the i2sdiv prescaler */
;;;400        i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
000112  1a40              SUBS     r0,r0,r1
000114  03c0              LSLS     r0,r0,#15
000116  0c00              LSRS     r0,r0,#16
;;;401    
;;;402        /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
;;;403        i2sodd = (uint16_t) (i2sodd << 8);
000118  0209              LSLS     r1,r1,#8
                  |L1.282|
;;;404      }
;;;405    
;;;406      /* Test if the divider is 1 or 0 or greater than 0xFF */
;;;407      if ((i2sdiv < 2) || (i2sdiv > 0xFF))
00011a  1e82              SUBS     r2,r0,#2
00011c  2afe              CMP      r2,#0xfe
00011e  d301              BCC      |L1.292|
;;;408      {
;;;409        /* Set the default values */
;;;410        i2sdiv = 2;
000120  2002              MOVS     r0,#2
;;;411        i2sodd = 0;
000122  2100              MOVS     r1,#0
                  |L1.292|
;;;412      }
;;;413    
;;;414      /* Write to SPIx I2SPR register the computed value */
;;;415      SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
000124  88e2              LDRH     r2,[r4,#6]
000126  4308              ORRS     r0,r0,r1
000128  4302              ORRS     r2,r2,r0
00012a  842a              STRH     r2,[r5,#0x20]
;;;416    
;;;417      /* Configure the I2S with the SPI_InitStruct values */
;;;418      tmpreg |= (uint16_t)(SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
00012c  8820              LDRH     r0,[r4,#0]
00012e  8861              LDRH     r1,[r4,#2]
000130  89a2              LDRH     r2,[r4,#0xc]
000132  4308              ORRS     r0,r0,r1
000134  88a1              LDRH     r1,[r4,#4]
000136  4311              ORRS     r1,r1,r2
000138  4308              ORRS     r0,r0,r1
00013a  2101              MOVS     r1,#1
00013c  4338              ORRS     r0,r0,r7
00013e  02c9              LSLS     r1,r1,#11
000140  4308              ORRS     r0,r0,r1
;;;419                      (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
;;;420                      (uint16_t)I2S_InitStruct->I2S_CPOL))));
;;;421    
;;;422      /* Write to SPIx I2SCFGR */
;;;423      SPIx->I2SCFGR = tmpreg;
000142  83a8              STRH     r0,[r5,#0x1c]
;;;424    }
000144  b007              ADD      sp,sp,#0x1c
000146  bdf0              POP      {r4-r7,pc}
;;;425    
                          ENDP

                  SPI_Cmd PROC
;;;432      */
;;;433    void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000148  2240              MOVS     r2,#0x40
;;;434    {
;;;435      /* Check the parameters */
;;;436      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;437      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;438    
;;;439      if (NewState != DISABLE)
00014a  2900              CMP      r1,#0
;;;440      {
;;;441        /* Enable the selected SPI peripheral */
;;;442        SPIx->CR1 |= SPI_CR1_SPE;
;;;443      }
;;;444      else
;;;445      {
;;;446        /* Disable the selected SPI peripheral */
;;;447        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
00014c  8801              LDRH     r1,[r0,#0]
00014e  d001              BEQ      |L1.340|
000150  4311              ORRS     r1,r1,r2              ;442
000152  e000              B        |L1.342|
                  |L1.340|
000154  4391              BICS     r1,r1,r2
                  |L1.342|
000156  8001              STRH     r1,[r0,#0]            ;442
;;;448      }
;;;449    }
000158  4770              BX       lr
;;;450    
                          ENDP

                  SPI_TIModeCmd PROC
;;;462      */
;;;463    void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
00015a  2210              MOVS     r2,#0x10
;;;464    {
;;;465      /* Check the parameters */
;;;466      assert_param(IS_SPI_1_PERIPH(SPIx));
;;;467      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;468    
;;;469      if (NewState != DISABLE)
00015c  2900              CMP      r1,#0
;;;470      {
;;;471        /* Enable the TI mode for the selected SPI peripheral */
;;;472        SPIx->CR2 |= SPI_CR2_FRF;
;;;473      }
;;;474      else
;;;475      {
;;;476        /* Disable the TI mode for the selected SPI peripheral */
;;;477        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRF);
00015e  8881              LDRH     r1,[r0,#4]
000160  d001              BEQ      |L1.358|
000162  4311              ORRS     r1,r1,r2              ;472
000164  e000              B        |L1.360|
                  |L1.358|
000166  4391              BICS     r1,r1,r2
                  |L1.360|
000168  8081              STRH     r1,[r0,#4]            ;472
;;;478      }
;;;479    }
00016a  4770              BX       lr
;;;480    
                          ENDP

                  I2S_Cmd PROC
;;;487      */
;;;488    void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
00016c  2900              CMP      r1,#0
;;;489    {
;;;490      /* Check the parameters */
;;;491      assert_param(IS_SPI_1_PERIPH(SPIx));
;;;492      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;493      if (NewState != DISABLE)
;;;494      {
;;;495        /* Enable the selected SPI peripheral in I2S mode */
;;;496        SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
;;;497      }
;;;498      else
;;;499      {
;;;500        /* Disable the selected SPI peripheral in I2S mode */
;;;501        SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
00016e  8b81              LDRH     r1,[r0,#0x1c]
000170  d003              BEQ      |L1.378|
000172  2201              MOVS     r2,#1                 ;496
000174  0292              LSLS     r2,r2,#10             ;496
000176  4311              ORRS     r1,r1,r2              ;496
000178  e001              B        |L1.382|
                  |L1.378|
00017a  4a58              LDR      r2,|L1.732|
00017c  4011              ANDS     r1,r1,r2
                  |L1.382|
00017e  8381              STRH     r1,[r0,#0x1c]         ;496
;;;502      }
;;;503    }
000180  4770              BX       lr
;;;504    
                          ENDP

                  SPI_DataSizeConfig PROC
;;;524      */
;;;525    void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
000182  8882              LDRH     r2,[r0,#4]
;;;526    {
;;;527      uint16_t tmpreg = 0;
;;;528      
;;;529      /* Check the parameters */
;;;530      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;531      assert_param(IS_SPI_DATA_SIZE(SPI_DataSize));
;;;532      /* Read the CR2 register */
;;;533      tmpreg = SPIx->CR2;
;;;534      /* Clear DS[3:0] bits */
;;;535      tmpreg &= (uint16_t)~SPI_CR2_DS;
000184  4b53              LDR      r3,|L1.724|
000186  401a              ANDS     r2,r2,r3
;;;536      /* Set new DS[3:0] bits value */
;;;537      tmpreg |= SPI_DataSize;
000188  430a              ORRS     r2,r2,r1
;;;538      SPIx->CR2 = tmpreg;
00018a  8082              STRH     r2,[r0,#4]
;;;539    }
00018c  4770              BX       lr
;;;540    
                          ENDP

                  SPI_RxFIFOThresholdConfig PROC
;;;551      */
;;;552    void SPI_RxFIFOThresholdConfig(SPI_TypeDef* SPIx, uint16_t SPI_RxFIFOThreshold)
00018e  8882              LDRH     r2,[r0,#4]
;;;553    {
;;;554      /* Check the parameters */
;;;555      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;556      assert_param(IS_SPI_RX_FIFO_THRESHOLD(SPI_RxFIFOThreshold));
;;;557    
;;;558      /* Clear FRXTH bit */
;;;559      SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRXTH);
000190  4b53              LDR      r3,|L1.736|
000192  401a              ANDS     r2,r2,r3
000194  8082              STRH     r2,[r0,#4]
;;;560    
;;;561      /* Set new FRXTH bit value */
;;;562      SPIx->CR2 |= SPI_RxFIFOThreshold;
000196  8882              LDRH     r2,[r0,#4]
000198  430a              ORRS     r2,r2,r1
00019a  8082              STRH     r2,[r0,#4]
;;;563    }
00019c  4770              BX       lr
;;;564    
                          ENDP

                  SPI_BiDirectionalLineConfig PROC
;;;573      */
;;;574    void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
00019e  2201              MOVS     r2,#1
;;;575    {
;;;576      /* Check the parameters */
;;;577      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;578      assert_param(IS_SPI_DIRECTION(SPI_Direction));
;;;579      if (SPI_Direction == SPI_Direction_Tx)
0001a0  0392              LSLS     r2,r2,#14
0001a2  4291              CMP      r1,r2
;;;580      {
;;;581        /* Set the Tx only mode */
;;;582        SPIx->CR1 |= SPI_Direction_Tx;
;;;583      }
;;;584      else
;;;585      {
;;;586        /* Set the Rx only mode */
;;;587        SPIx->CR1 &= SPI_Direction_Rx;
0001a4  8801              LDRH     r1,[r0,#0]
0001a6  d101              BNE      |L1.428|
0001a8  4311              ORRS     r1,r1,r2              ;582
0001aa  e001              B        |L1.432|
                  |L1.428|
0001ac  4a4d              LDR      r2,|L1.740|
0001ae  4011              ANDS     r1,r1,r2
                  |L1.432|
0001b0  8001              STRH     r1,[r0,#0]            ;582
;;;588      }
;;;589    }
0001b2  4770              BX       lr
;;;590    
                          ENDP

                  SPI_NSSInternalSoftwareConfig PROC
;;;601      */
;;;602    void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
0001b4  4a4c              LDR      r2,|L1.744|
;;;603    {
;;;604      /* Check the parameters */
;;;605      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;606      assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
;;;607    
;;;608      if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
0001b6  4291              CMP      r1,r2
;;;609      {
;;;610        /* Set NSS pin internally by software */
;;;611        SPIx->CR1 |= SPI_NSSInternalSoft_Set;
;;;612      }
;;;613      else
;;;614      {
;;;615        /* Reset NSS pin internally by software */
;;;616        SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
0001b8  8801              LDRH     r1,[r0,#0]
0001ba  d003              BEQ      |L1.452|
0001bc  22ff              MOVS     r2,#0xff              ;611
0001be  3201              ADDS     r2,#1                 ;611
0001c0  4311              ORRS     r1,r1,r2              ;611
0001c2  e000              B        |L1.454|
                  |L1.452|
0001c4  4011              ANDS     r1,r1,r2
                  |L1.454|
0001c6  8001              STRH     r1,[r0,#0]            ;611
;;;617      }
;;;618    }
0001c8  4770              BX       lr
;;;619    
                          ENDP

                  SPI_SSOutputCmd PROC
;;;628      */
;;;629    void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
0001ca  2204              MOVS     r2,#4
;;;630    {
;;;631      /* Check the parameters */
;;;632      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;633      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;634      if (NewState != DISABLE)
0001cc  2900              CMP      r1,#0
;;;635      {
;;;636        /* Enable the selected SPI SS output */
;;;637        SPIx->CR2 |= SPI_CR2_SSOE;
;;;638      }
;;;639      else
;;;640      {
;;;641        /* Disable the selected SPI SS output */
;;;642        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
0001ce  8881              LDRH     r1,[r0,#4]
0001d0  d001              BEQ      |L1.470|
0001d2  4311              ORRS     r1,r1,r2              ;637
0001d4  e000              B        |L1.472|
                  |L1.470|
0001d6  4391              BICS     r1,r1,r2
                  |L1.472|
0001d8  8081              STRH     r1,[r0,#4]            ;637
;;;643      }
;;;644    }
0001da  4770              BX       lr
;;;645    
                          ENDP

                  SPI_NSSPulseModeCmd PROC
;;;657      */
;;;658    void SPI_NSSPulseModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
0001dc  2208              MOVS     r2,#8
;;;659    {
;;;660      /* Check the parameters */
;;;661      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;662      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;663    
;;;664      if (NewState != DISABLE)
0001de  2900              CMP      r1,#0
;;;665      {
;;;666        /* Enable the NSS pulse management mode */
;;;667        SPIx->CR2 |= SPI_CR2_NSSP;
;;;668      }
;;;669      else
;;;670      {
;;;671        /* Disable the NSS pulse management mode */
;;;672        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_NSSP);    
0001e0  8881              LDRH     r1,[r0,#4]
0001e2  d001              BEQ      |L1.488|
0001e4  4311              ORRS     r1,r1,r2              ;667
0001e6  e000              B        |L1.490|
                  |L1.488|
0001e8  4391              BICS     r1,r1,r2
                  |L1.490|
0001ea  8081              STRH     r1,[r0,#4]            ;667
;;;673      }
;;;674    }
0001ec  4770              BX       lr
;;;675    
                          ENDP

                  SPI_SendData8 PROC
;;;711      */
;;;712    void SPI_SendData8(SPI_TypeDef* SPIx, uint8_t Data)
0001ee  7301              STRB     r1,[r0,#0xc]
;;;713    {
;;;714      uint32_t spixbase = 0x00;
;;;715    
;;;716      /* Check the parameters */
;;;717      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;718    
;;;719      spixbase = (uint32_t)SPIx; 
;;;720      spixbase += 0x0C;
;;;721      
;;;722      *(__IO uint8_t *) spixbase = Data;
;;;723    }
0001f0  4770              BX       lr
;;;724    
                          ENDP

                  SPI_I2S_SendData16 PROC
;;;731      */
;;;732    void SPI_I2S_SendData16(SPI_TypeDef* SPIx, uint16_t Data)
0001f2  8181              STRH     r1,[r0,#0xc]
;;;733    {
;;;734      /* Check the parameters */
;;;735      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;736      
;;;737      SPIx->DR = (uint16_t)Data;
;;;738    }
0001f4  4770              BX       lr
;;;739    
                          ENDP

                  SPI_ReceiveData8 PROC
;;;744      */
;;;745    uint8_t SPI_ReceiveData8(SPI_TypeDef* SPIx)
0001f6  7b00              LDRB     r0,[r0,#0xc]
;;;746    {
;;;747      uint32_t spixbase = 0x00;
;;;748      
;;;749      spixbase = (uint32_t)SPIx; 
;;;750      spixbase += 0x0C;
;;;751      
;;;752      return *(__IO uint8_t *) spixbase;
;;;753    }
0001f8  4770              BX       lr
;;;754    
                          ENDP

                  SPI_I2S_ReceiveData16 PROC
;;;760      */
;;;761    uint16_t SPI_I2S_ReceiveData16(SPI_TypeDef* SPIx)
0001fa  8980              LDRH     r0,[r0,#0xc]
;;;762    {
;;;763      return SPIx->DR;
;;;764    }
0001fc  4770              BX       lr
;;;765    /**
                          ENDP

                  SPI_CRCLengthConfig PROC
;;;841      */
;;;842    void SPI_CRCLengthConfig(SPI_TypeDef* SPIx, uint16_t SPI_CRCLength)
0001fe  8802              LDRH     r2,[r0,#0]
;;;843    {
;;;844      /* Check the parameters */
;;;845      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;846      assert_param(IS_SPI_CRC_LENGTH(SPI_CRCLength));
;;;847    
;;;848      /* Clear CRCL bit */
;;;849      SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCL);
000200  4b35              LDR      r3,|L1.728|
000202  401a              ANDS     r2,r2,r3
000204  8002              STRH     r2,[r0,#0]
;;;850    
;;;851      /* Set new CRCL bit value */
;;;852      SPIx->CR1 |= SPI_CRCLength;
000206  8802              LDRH     r2,[r0,#0]
000208  430a              ORRS     r2,r2,r1
00020a  8002              STRH     r2,[r0,#0]
;;;853    }
00020c  4770              BX       lr
;;;854    
                          ENDP

                  SPI_CalculateCRC PROC
;;;863      */
;;;864    void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
00020e  2900              CMP      r1,#0
;;;865    {
;;;866      /* Check the parameters */
;;;867      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;868      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;869    
;;;870      if (NewState != DISABLE)
;;;871      {
;;;872        /* Enable the selected SPI CRC calculation */
;;;873        SPIx->CR1 |= SPI_CR1_CRCEN;
;;;874      }
;;;875      else
;;;876      {
;;;877        /* Disable the selected SPI CRC calculation */
;;;878        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
000210  8801              LDRH     r1,[r0,#0]
000212  d003              BEQ      |L1.540|
000214  2201              MOVS     r2,#1                 ;873
000216  0352              LSLS     r2,r2,#13             ;873
000218  4311              ORRS     r1,r1,r2              ;873
00021a  e001              B        |L1.544|
                  |L1.540|
00021c  4a33              LDR      r2,|L1.748|
00021e  4011              ANDS     r1,r1,r2
                  |L1.544|
000220  8001              STRH     r1,[r0,#0]            ;873
;;;879      }
;;;880    }
000222  4770              BX       lr
;;;881    
                          ENDP

                  SPI_TransmitCRC PROC
;;;886      */
;;;887    void SPI_TransmitCRC(SPI_TypeDef* SPIx)
000224  8801              LDRH     r1,[r0,#0]
;;;888    {
;;;889      /* Check the parameters */
;;;890      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;891    
;;;892      /* Enable the selected SPI CRC transmission */
;;;893      SPIx->CR1 |= SPI_CR1_CRCNEXT;
000226  2201              MOVS     r2,#1
000228  0312              LSLS     r2,r2,#12
00022a  4311              ORRS     r1,r1,r2
00022c  8001              STRH     r1,[r0,#0]
;;;894    }
00022e  4770              BX       lr
;;;895    
                          ENDP

                  SPI_GetCRC PROC
;;;904      */
;;;905    uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
000230  2901              CMP      r1,#1
;;;906    {
000232  d001              BEQ      |L1.568|
;;;907      uint16_t crcreg = 0;
;;;908      /* Check the parameters */
;;;909      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;910      assert_param(IS_SPI_CRC(SPI_CRC));
;;;911    
;;;912      if (SPI_CRC != SPI_CRC_Rx)
;;;913      {
;;;914        /* Get the Tx CRC register */
;;;915        crcreg = SPIx->TXCRCR;
000234  8b00              LDRH     r0,[r0,#0x18]
;;;916      }
;;;917      else
;;;918      {
;;;919        /* Get the Rx CRC register */
;;;920        crcreg = SPIx->RXCRCR;
;;;921      }
;;;922      /* Return the selected CRC register */
;;;923      return crcreg;
;;;924    }
000236  4770              BX       lr
                  |L1.568|
000238  8a80              LDRH     r0,[r0,#0x14]         ;920
00023a  4770              BX       lr
;;;925    
                          ENDP

                  SPI_GetCRCPolynomial PROC
;;;930      */
;;;931    uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
00023c  8a00              LDRH     r0,[r0,#0x10]
;;;932    {
;;;933      /* Check the parameters */
;;;934      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;935    
;;;936      /* Return the CRC polynomial register */
;;;937      return SPIx->CRCPR;
;;;938    }
00023e  4770              BX       lr
;;;939    
                          ENDP

                  SPI_I2S_DMACmd PROC
;;;968      */
;;;969    void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
000240  2a00              CMP      r2,#0
;;;970    {
;;;971      /* Check the parameters */
;;;972      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;973      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;974      assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));
;;;975    
;;;976      if (NewState != DISABLE)
;;;977      {
;;;978        /* Enable the selected SPI DMA requests */
;;;979        SPIx->CR2 |= SPI_I2S_DMAReq;
;;;980      }
;;;981      else
;;;982      {
;;;983        /* Disable the selected SPI DMA requests */
;;;984        SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
000242  8882              LDRH     r2,[r0,#4]
000244  d001              BEQ      |L1.586|
000246  430a              ORRS     r2,r2,r1              ;979
000248  e000              B        |L1.588|
                  |L1.586|
00024a  438a              BICS     r2,r2,r1
                  |L1.588|
00024c  8082              STRH     r2,[r0,#4]            ;979
;;;985      }
;;;986    }
00024e  4770              BX       lr
;;;987    
                          ENDP

                  SPI_LastDMATransferCmd PROC
;;;1005     */
;;;1006   void SPI_LastDMATransferCmd(SPI_TypeDef* SPIx, uint16_t SPI_LastDMATransfer)
000250  8882              LDRH     r2,[r0,#4]
;;;1007   {
;;;1008     /* Check the parameters */
;;;1009     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1010     assert_param(IS_SPI_LAST_DMA_TRANSFER(SPI_LastDMATransfer));
;;;1011   
;;;1012     /* Clear LDMA_TX and LDMA_RX bits */
;;;1013     SPIx->CR2 &= CR2_LDMA_MASK;
000252  4b27              LDR      r3,|L1.752|
000254  401a              ANDS     r2,r2,r3
000256  8082              STRH     r2,[r0,#4]
;;;1014   
;;;1015     /* Set new LDMA_TX and LDMA_RX bits value */
;;;1016     SPIx->CR2 |= SPI_LastDMATransfer; 
000258  8882              LDRH     r2,[r0,#4]
00025a  430a              ORRS     r2,r2,r1
00025c  8082              STRH     r2,[r0,#4]
;;;1017   }
00025e  4770              BX       lr
;;;1018   
                          ENDP

                  SPI_I2S_ITConfig PROC
;;;1110     */
;;;1111   void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
000260  0909              LSRS     r1,r1,#4
;;;1112   {
;;;1113     uint16_t itpos = 0, itmask = 0 ;
;;;1114   
;;;1115     /* Check the parameters */
;;;1116     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1117     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1118     assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
;;;1119   
;;;1120     /* Get the SPI IT index */
;;;1121     itpos = SPI_I2S_IT >> 4;
;;;1122   
;;;1123     /* Set the IT mask */
;;;1124     itmask = (uint16_t)1 << (uint16_t)itpos;
000262  2301              MOVS     r3,#1
000264  408b              LSLS     r3,r3,r1
;;;1125   
;;;1126     if (NewState != DISABLE)
000266  2a00              CMP      r2,#0
;;;1127     {
;;;1128       /* Enable the selected SPI interrupt */
;;;1129       SPIx->CR2 |= itmask;
;;;1130     }
;;;1131     else
;;;1132     {
;;;1133       /* Disable the selected SPI interrupt */
;;;1134       SPIx->CR2 &= (uint16_t)~itmask;
000268  8882              LDRH     r2,[r0,#4]
00026a  b299              UXTH     r1,r3                 ;1124
00026c  d001              BEQ      |L1.626|
00026e  430a              ORRS     r2,r2,r1              ;1129
000270  e000              B        |L1.628|
                  |L1.626|
000272  438a              BICS     r2,r2,r1
                  |L1.628|
000274  8082              STRH     r2,[r0,#4]            ;1129
;;;1135     }
;;;1136   }
000276  4770              BX       lr
;;;1137   
                          ENDP

                  SPI_GetTransmissionFIFOStatus PROC
;;;1146     */
;;;1147   uint16_t SPI_GetTransmissionFIFOStatus(SPI_TypeDef* SPIx)
000278  8900              LDRH     r0,[r0,#8]
;;;1148   {
;;;1149     /* Get the SPIx Transmission FIFO level bits */
;;;1150     return (uint16_t)((SPIx->SR & SPI_SR_FTLVL));
00027a  2103              MOVS     r1,#3
00027c  02c9              LSLS     r1,r1,#11
00027e  4008              ANDS     r0,r0,r1
;;;1151   }
000280  4770              BX       lr
;;;1152   
                          ENDP

                  SPI_GetReceptionFIFOStatus PROC
;;;1161     */
;;;1162   uint16_t SPI_GetReceptionFIFOStatus(SPI_TypeDef* SPIx)
000282  8900              LDRH     r0,[r0,#8]
;;;1163   {
;;;1164     /* Get the SPIx Reception FIFO level bits */
;;;1165     return (uint16_t)((SPIx->SR & SPI_SR_FRLVL));
000284  2103              MOVS     r1,#3
000286  0249              LSLS     r1,r1,#9
000288  4008              ANDS     r0,r0,r1
;;;1166   }
00028a  4770              BX       lr
;;;1167   
                          ENDP

                  SPI_I2S_GetFlagStatus PROC
;;;1184     */
;;;1185   FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
00028c  4602              MOV      r2,r0
;;;1186   {
;;;1187     FlagStatus bitstatus = RESET;
;;;1188     /* Check the parameters */
;;;1189     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1190     assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
;;;1191   
;;;1192     /* Check the status of the specified SPI flag */
;;;1193     if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
00028e  8912              LDRH     r2,[r2,#8]
000290  2000              MOVS     r0,#0                 ;1187
000292  420a              TST      r2,r1
000294  d000              BEQ      |L1.664|
;;;1194     {
;;;1195       /* SPI_I2S_FLAG is set */
;;;1196       bitstatus = SET;
000296  2001              MOVS     r0,#1
                  |L1.664|
;;;1197     }
;;;1198     else
;;;1199     {
;;;1200       /* SPI_I2S_FLAG is reset */
;;;1201       bitstatus = RESET;
;;;1202     }
;;;1203     /* Return the SPI_I2S_FLAG status */
;;;1204     return  bitstatus;
;;;1205   }
000298  4770              BX       lr
;;;1206   
                          ENDP

                  SPI_I2S_ClearFlag PROC
;;;1219     */
;;;1220   void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
00029a  43c9              MVNS     r1,r1
;;;1221   {
;;;1222     /* Check the parameters */
;;;1223     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1224     assert_param(IS_SPI_CLEAR_FLAG(SPI_I2S_FLAG));
;;;1225   
;;;1226     /* Clear the selected SPI CRC Error (CRCERR) flag */
;;;1227     SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
00029c  8101              STRH     r1,[r0,#8]
;;;1228   }
00029e  4770              BX       lr
;;;1229   
                          ENDP

                  SPI_I2S_GetITStatus PROC
;;;1243     */
;;;1244   ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
0002a0  b530              PUSH     {r4,r5,lr}
;;;1245   {
;;;1246     ITStatus bitstatus = RESET;
;;;1247     uint16_t itpos = 0, itmask = 0, enablestatus = 0;
;;;1248   
;;;1249     /* Check the parameters */
;;;1250     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1251     assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
;;;1252   
;;;1253     /* Get the SPI_I2S_IT index */
;;;1254     itpos = 0x01 << (SPI_I2S_IT & 0x0F);
0002a2  070d              LSLS     r5,r1,#28
0002a4  2401              MOVS     r4,#1
0002a6  0f2d              LSRS     r5,r5,#28
0002a8  4623              MOV      r3,r4
0002aa  40ab              LSLS     r3,r3,r5
0002ac  4602              MOV      r2,r0                 ;1245
0002ae  2000              MOVS     r0,#0                 ;1246
;;;1255   
;;;1256     /* Get the SPI_I2S_IT IT mask */
;;;1257     itmask = SPI_I2S_IT >> 4;
0002b0  0909              LSRS     r1,r1,#4
;;;1258   
;;;1259     /* Set the IT mask */
;;;1260     itmask = 0x01 << itmask;
0002b2  408c              LSLS     r4,r4,r1
;;;1261   
;;;1262     /* Get the SPI_I2S_IT enable bit status */
;;;1263     enablestatus = (SPIx->CR2 & itmask) ;
0002b4  8891              LDRH     r1,[r2,#4]
0002b6  b29b              UXTH     r3,r3                 ;1254
0002b8  b2a4              UXTH     r4,r4                 ;1260
;;;1264   
;;;1265     /* Check the status of the specified SPI interrupt */
;;;1266     if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
0002ba  8912              LDRH     r2,[r2,#8]
0002bc  4021              ANDS     r1,r1,r4              ;1263
0002be  421a              TST      r2,r3
0002c0  d002              BEQ      |L1.712|
0002c2  2900              CMP      r1,#0
0002c4  d000              BEQ      |L1.712|
;;;1267     {
;;;1268       /* SPI_I2S_IT is set */
;;;1269       bitstatus = SET;
0002c6  2001              MOVS     r0,#1
                  |L1.712|
;;;1270     }
;;;1271     else
;;;1272     {
;;;1273       /* SPI_I2S_IT is reset */
;;;1274       bitstatus = RESET;
;;;1275     }
;;;1276     /* Return the SPI_I2S_IT status */
;;;1277     return bitstatus;
;;;1278   }
0002c8  bd30              POP      {r4,r5,pc}
;;;1279   
                          ENDP

0002ca  0000              DCW      0x0000
                  |L1.716|
                          DCD      0x40013000
                  |L1.720|
                          DCD      0x40003800
                  |L1.724|
                          DCD      0x0000f0ff
                  |L1.728|
                          DCD      0x0000f7ff
                  |L1.732|
                          DCD      0x0000fbff
                  |L1.736|
                          DCD      0x0000efff
                  |L1.740|
                          DCD      0x0000bfff
                  |L1.744|
                          DCD      0x0000feff
                  |L1.748|
                          DCD      0x0000dfff
                  |L1.752|
                          DCD      0x00009fff

;*** Start embedded assembler ***

#line 1 "..\\arch\\arm\\stm32f05x\\lib\\src\\stm32f0xx_spi.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_spi_c_2b928927____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f0xx_spi_c_2b928927____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_spi_c_2b928927____REVSH|
#line 144
|__asm___15_stm32f0xx_spi_c_2b928927____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
