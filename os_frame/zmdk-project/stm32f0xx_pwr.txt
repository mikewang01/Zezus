; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\stm32f0xx_pwr.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f0xx_pwr.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\stm32f0xx_pwr.crf ..\arch\arm\stm32f05x\lib\src\stm32f0xx_pwr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  PWR_DeInit PROC
;;;86       */
;;;87     void PWR_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;88     {
;;;89       RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  070c              LSLS     r4,r1,#28
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;90       RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;91     }
000014  bd10              POP      {r4,pc}
;;;92     
                          ENDP

                  PWR_BackupAccessCmd PROC
;;;100      */
;;;101    void PWR_BackupAccessCmd(FunctionalState NewState)
000016  4930              LDR      r1,|L1.216|
;;;102    {
;;;103      /* Check the parameters */
;;;104      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;105      
;;;106      if (NewState != DISABLE)
;;;107      {
;;;108        /* Enable the Backup Domain Access */
;;;109        PWR->CR |= PWR_CR_DBP;
000018  158a              ASRS     r2,r1,#22
00001a  2800              CMP      r0,#0                 ;106
;;;110      }
;;;111      else
;;;112      {
;;;113        /* Disable the Backup Domain Access */
;;;114        PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_DBP);
00001c  6808              LDR      r0,[r1,#0]
00001e  d001              BEQ      |L1.36|
000020  4310              ORRS     r0,r0,r2              ;109
000022  e000              B        |L1.38|
                  |L1.36|
000024  4390              BICS     r0,r0,r2
                  |L1.38|
000026  6008              STR      r0,[r1,#0]            ;109
;;;115      } 
;;;116    }
000028  4770              BX       lr
;;;117    
                          ENDP

                  PWR_PVDLevelConfig PROC
;;;154      */
;;;155    void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
00002a  4a2b              LDR      r2,|L1.216|
;;;156    {
;;;157      uint32_t tmpreg = 0;
;;;158      
;;;159      /* Check the parameters */
;;;160      assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
;;;161      
;;;162      tmpreg = PWR->CR;
00002c  6811              LDR      r1,[r2,#0]
;;;163      
;;;164      /* Clear PLS[7:5] bits */
;;;165      tmpreg &= CR_PLS_MASK;
00002e  23e0              MOVS     r3,#0xe0
000030  4399              BICS     r1,r1,r3
;;;166      
;;;167      /* Set PLS[7:5] bits according to PWR_PVDLevel value */
;;;168      tmpreg |= PWR_PVDLevel;
000032  4301              ORRS     r1,r1,r0
;;;169      
;;;170      /* Store the new value */
;;;171      PWR->CR = tmpreg;
000034  6011              STR      r1,[r2,#0]
;;;172    }
000036  4770              BX       lr
;;;173    
                          ENDP

                  PWR_PVDCmd PROC
;;;179      */
;;;180    void PWR_PVDCmd(FunctionalState NewState)
000038  4927              LDR      r1,|L1.216|
;;;181    {
;;;182      /* Check the parameters */
;;;183      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;184      
;;;185      if (NewState != DISABLE)
;;;186      {
;;;187        /* Enable the PVD */
;;;188        PWR->CR |= PWR_CR_PVDE;
00003a  2210              MOVS     r2,#0x10
00003c  2800              CMP      r0,#0                 ;185
;;;189      }
;;;190      else
;;;191      {
;;;192        /* Disable the PVD */
;;;193        PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_PVDE);
00003e  6808              LDR      r0,[r1,#0]
000040  d001              BEQ      |L1.70|
000042  4310              ORRS     r0,r0,r2              ;188
000044  e000              B        |L1.72|
                  |L1.70|
000046  4390              BICS     r0,r0,r2
                  |L1.72|
000048  6008              STR      r0,[r1,#0]            ;188
;;;194      } 
;;;195    }
00004a  4770              BX       lr
;;;196    
                          ENDP

                  PWR_WakeUpPinCmd PROC
;;;224      */
;;;225    void PWR_WakeUpPinCmd(uint32_t PWR_WakeUpPin, FunctionalState NewState)
00004c  4a22              LDR      r2,|L1.216|
;;;226    {
;;;227      /* Check the parameters */
;;;228      assert_param(IS_PWR_WAKEUP_PIN(PWR_WakeUpPin));
;;;229      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;230    
;;;231      if (NewState != DISABLE)
00004e  2900              CMP      r1,#0
;;;232      {
;;;233        /* Enable the EWUPx pin */
;;;234        PWR->CSR |= PWR_WakeUpPin;
;;;235      }
;;;236      else
;;;237      {
;;;238        /* Disable the EWUPx pin */
;;;239        PWR->CSR &= ~PWR_WakeUpPin;
000050  6851              LDR      r1,[r2,#4]
000052  d001              BEQ      |L1.88|
000054  4301              ORRS     r1,r1,r0              ;234
000056  e000              B        |L1.90|
                  |L1.88|
000058  4381              BICS     r1,r1,r0
                  |L1.90|
00005a  6051              STR      r1,[r2,#4]            ;234
;;;240      }
;;;241    }
00005c  4770              BX       lr
;;;242    
                          ENDP

                  PWR_EnterSleepMode PROC
;;;357      */
;;;358    void PWR_EnterSleepMode(uint8_t PWR_SLEEPEntry)
00005e  491f              LDR      r1,|L1.220|
;;;359    {
;;;360      /* Check the parameters */
;;;361      assert_param(IS_PWR_SLEEP_ENTRY(PWR_SLEEPEntry));
;;;362    
;;;363      /* Clear SLEEPDEEP bit of Cortex-M0 System Control Register */
;;;364      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
000060  690a              LDR      r2,[r1,#0x10]
000062  2304              MOVS     r3,#4
000064  439a              BICS     r2,r2,r3
000066  610a              STR      r2,[r1,#0x10]
;;;365      
;;;366      /* Select SLEEP mode entry -------------------------------------------------*/
;;;367      if(PWR_SLEEPEntry == PWR_SLEEPEntry_WFI)
000068  2801              CMP      r0,#1
00006a  d001              BEQ      |L1.112|
;;;368      {
;;;369        /* Request Wait For Interrupt */
;;;370        __WFI();
;;;371      }
;;;372      else
;;;373      {
;;;374        /* Request Wait For Event */
;;;375        __WFE();
00006c  bf20              WFE      
;;;376      }
;;;377    }
00006e  4770              BX       lr
                  |L1.112|
000070  bf30              WFI                            ;370
000072  4770              BX       lr
;;;378    
                          ENDP

                  PWR_EnterSTOPMode PROC
;;;397      */
;;;398    void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
000074  4b18              LDR      r3,|L1.216|
;;;399    {
;;;400      uint32_t tmpreg = 0;
;;;401    
;;;402      /* Check the parameters */
;;;403      assert_param(IS_PWR_REGULATOR(PWR_Regulator));
;;;404      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
;;;405    
;;;406      /* Select the regulator state in STOP mode ---------------------------------*/
;;;407      tmpreg = PWR->CR;
000076  681a              LDR      r2,[r3,#0]
;;;408      /* Clear PDDS and LPDSR bits */
;;;409      tmpreg &= CR_DS_MASK;
000078  0892              LSRS     r2,r2,#2
00007a  0092              LSLS     r2,r2,#2
;;;410    
;;;411      /* Set LPDSR bit according to PWR_Regulator value */
;;;412      tmpreg |= PWR_Regulator;
00007c  4302              ORRS     r2,r2,r0
;;;413    
;;;414      /* Store the new value */
;;;415      PWR->CR = tmpreg;
00007e  601a              STR      r2,[r3,#0]
;;;416    
;;;417      /* Set SLEEPDEEP bit of Cortex-M0 System Control Register */
;;;418      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000080  4816              LDR      r0,|L1.220|
000082  6902              LDR      r2,[r0,#0x10]
000084  2304              MOVS     r3,#4
000086  431a              ORRS     r2,r2,r3
000088  6102              STR      r2,[r0,#0x10]
;;;419    
;;;420      /* Select STOP mode entry --------------------------------------------------*/
;;;421      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
00008a  2901              CMP      r1,#1
00008c  d004              BEQ      |L1.152|
;;;422      {
;;;423        /* Request Wait For Interrupt */
;;;424        __WFI();
;;;425      }
;;;426      else
;;;427      {
;;;428        /* Request Wait For Event */
;;;429        __WFE();
00008e  bf20              WFE      
                  |L1.144|
;;;430      }
;;;431      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;432      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
000090  6901              LDR      r1,[r0,#0x10]
000092  4399              BICS     r1,r1,r3
000094  6101              STR      r1,[r0,#0x10]
;;;433    }
000096  4770              BX       lr
                  |L1.152|
000098  bf30              WFI                            ;424
00009a  e7f9              B        |L1.144|
;;;434    
                          ENDP

                  PWR_EnterSTANDBYMode PROC
;;;444      */
;;;445    void PWR_EnterSTANDBYMode(void)
00009c  480e              LDR      r0,|L1.216|
;;;446    {
;;;447      /* Clear Wakeup flag */
;;;448      PWR->CR |= PWR_CR_CWUF;
00009e  6802              LDR      r2,[r0,#0]
0000a0  2104              MOVS     r1,#4
0000a2  430a              ORRS     r2,r2,r1
0000a4  6002              STR      r2,[r0,#0]
;;;449    
;;;450      /* Select STANDBY mode */
;;;451      PWR->CR |= PWR_CR_PDDS;
0000a6  6802              LDR      r2,[r0,#0]
0000a8  2302              MOVS     r3,#2
0000aa  431a              ORRS     r2,r2,r3
0000ac  6002              STR      r2,[r0,#0]
;;;452    
;;;453      /* Set SLEEPDEEP bit of Cortex-M0 System Control Register */
;;;454      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
0000ae  480b              LDR      r0,|L1.220|
0000b0  6902              LDR      r2,[r0,#0x10]
0000b2  430a              ORRS     r2,r2,r1
0000b4  6102              STR      r2,[r0,#0x10]
;;;455    
;;;456      /* Request Wait For Interrupt */
;;;457      __WFI();
0000b6  bf30              WFI      
;;;458    }
0000b8  4770              BX       lr
;;;459    
                          ENDP

                  PWR_GetFlagStatus PROC
;;;491      */
;;;492    FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
0000ba  4a07              LDR      r2,|L1.216|
;;;493    {
0000bc  4601              MOV      r1,r0
;;;494      FlagStatus bitstatus = RESET;
;;;495      /* Check the parameters */
;;;496      assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
;;;497    
;;;498      if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
0000be  6852              LDR      r2,[r2,#4]
0000c0  2000              MOVS     r0,#0                 ;494
0000c2  420a              TST      r2,r1
0000c4  d000              BEQ      |L1.200|
;;;499      {
;;;500        bitstatus = SET;
0000c6  2001              MOVS     r0,#1
                  |L1.200|
;;;501      }
;;;502      else
;;;503      {
;;;504        bitstatus = RESET;
;;;505      }
;;;506      /* Return the flag status */
;;;507      return bitstatus;
;;;508    }
0000c8  4770              BX       lr
;;;509    
                          ENDP

                  PWR_ClearFlag PROC
;;;517      */
;;;518    void PWR_ClearFlag(uint32_t PWR_FLAG)
0000ca  4903              LDR      r1,|L1.216|
;;;519    {
;;;520      /* Check the parameters */
;;;521      assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
;;;522    
;;;523      PWR->CR |=  PWR_FLAG << 2;
0000cc  680a              LDR      r2,[r1,#0]
0000ce  0080              LSLS     r0,r0,#2
0000d0  4302              ORRS     r2,r2,r0
0000d2  600a              STR      r2,[r1,#0]
;;;524    }
0000d4  4770              BX       lr
;;;525    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L1.216|
                          DCD      0x40007000
                  |L1.220|
                          DCD      0xe000ed00

;*** Start embedded assembler ***

#line 1 "..\\arch\\arm\\stm32f05x\\lib\\src\\stm32f0xx_pwr.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_pwr_c_0c2a8b75____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f0xx_pwr_c_0c2a8b75____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_pwr_c_0c2a8b75____REVSH|
#line 144
|__asm___15_stm32f0xx_pwr_c_0c2a8b75____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
