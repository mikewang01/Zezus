; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\stm32f0xx_crc.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f0xx_crc.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\stm32f0xx_crc.crf ..\arch\arm\stm32f05x\lib\src\stm32f0xx_crc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CRC_DeInit PROC
;;;93       */
;;;94     void CRC_DeInit(void)
000000  2100              MOVS     r1,#0
;;;95     {
;;;96       /* Set DR register to reset value */
;;;97       CRC->DR = 0xFFFFFFFF;
000002  481d              LDR      r0,|L1.120|
000004  43c9              MVNS     r1,r1
000006  6001              STR      r1,[r0,#0]
;;;98       /* Reset IDR register */
;;;99       CRC->IDR = 0x00;
000008  2200              MOVS     r2,#0
00000a  7102              STRB     r2,[r0,#4]
;;;100      /* Set INIT register to reset value */
;;;101      CRC->INIT = 0xFFFFFFFF;
00000c  6101              STR      r1,[r0,#0x10]
;;;102      /* Reset the CRC calculation unit */
;;;103      CRC->CR = CRC_CR_RESET;
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;104    }
000012  4770              BX       lr
;;;105    
                          ENDP

                  CRC_ResetDR PROC
;;;110      */
;;;111    void CRC_ResetDR(void)
000014  4918              LDR      r1,|L1.120|
;;;112    {
;;;113      /* Reset CRC generator */
;;;114      CRC->CR = CRC_CR_RESET;
000016  2001              MOVS     r0,#1
000018  6088              STR      r0,[r1,#8]
;;;115    }
00001a  4770              BX       lr
;;;116    
                          ENDP

                  CRC_ReverseInputDataSelect PROC
;;;126      */
;;;127    void CRC_ReverseInputDataSelect(uint32_t CRC_ReverseInputData)
00001c  4a16              LDR      r2,|L1.120|
;;;128    {
;;;129      uint32_t tmpcr = 0;
;;;130    
;;;131      /* Check the parameter */
;;;132      assert_param(IS_CRC_REVERSE_INPUT_DATA(CRC_ReverseInputData));
;;;133    
;;;134      /* Get CR register value */
;;;135      tmpcr = CRC->CR;
00001e  6891              LDR      r1,[r2,#8]
;;;136    
;;;137      /* Reset REV_IN bits */
;;;138      tmpcr &= (uint32_t)~((uint32_t)CRC_CR_REV_IN);
000020  2360              MOVS     r3,#0x60
000022  4399              BICS     r1,r1,r3
;;;139      /* Set the reverse operation */
;;;140      tmpcr |= (uint32_t)CRC_ReverseInputData;
000024  4301              ORRS     r1,r1,r0
;;;141    
;;;142      /* Write to CR register */
;;;143      CRC->CR = (uint32_t)tmpcr;
000026  6091              STR      r1,[r2,#8]
;;;144    }
000028  4770              BX       lr
;;;145    
                          ENDP

                  CRC_ReverseOutputDataCmd PROC
;;;152      */
;;;153    void CRC_ReverseOutputDataCmd(FunctionalState NewState)
00002a  4913              LDR      r1,|L1.120|
;;;154    {
;;;155      /* Check the parameters */
;;;156      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;157    
;;;158      if (NewState != DISABLE)
;;;159      {
;;;160        /* Enable reverse operation on output data */
;;;161        CRC->CR |= CRC_CR_REV_OUT;
00002c  2280              MOVS     r2,#0x80
00002e  2800              CMP      r0,#0                 ;158
;;;162      }
;;;163      else
;;;164      {
;;;165        /* Disable reverse operation on output data */
;;;166        CRC->CR &= (uint32_t)~((uint32_t)CRC_CR_REV_OUT);
000030  6888              LDR      r0,[r1,#8]
000032  d001              BEQ      |L1.56|
000034  4310              ORRS     r0,r0,r2              ;161
000036  e000              B        |L1.58|
                  |L1.56|
000038  4390              BICS     r0,r0,r2
                  |L1.58|
00003a  6088              STR      r0,[r1,#8]            ;161
;;;167      }
;;;168    }
00003c  4770              BX       lr
;;;169    
                          ENDP

                  CRC_SetInitRegister PROC
;;;175      */
;;;176    void CRC_SetInitRegister(uint32_t CRC_InitValue)
00003e  490e              LDR      r1,|L1.120|
;;;177    {
;;;178      CRC->INIT = CRC_InitValue;
000040  6108              STR      r0,[r1,#0x10]
;;;179    }
000042  4770              BX       lr
;;;180    
                          ENDP

                  CRC_CalcCRC PROC
;;;201      */
;;;202    uint32_t CRC_CalcCRC(uint32_t CRC_Data)
000044  490c              LDR      r1,|L1.120|
;;;203    {
;;;204      CRC->DR = CRC_Data;
000046  6008              STR      r0,[r1,#0]
;;;205      
;;;206      return (CRC->DR);
000048  6808              LDR      r0,[r1,#0]
;;;207    }
00004a  4770              BX       lr
;;;208    
                          ENDP

                  CRC_CalcBlockCRC PROC
;;;214      */
;;;215    uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
00004c  b510              PUSH     {r4,lr}
;;;216    {
;;;217      uint32_t index = 0;
00004e  2200              MOVS     r2,#0
;;;218      
;;;219      for(index = 0; index < BufferLength; index++)
;;;220      {
;;;221        CRC->DR = pBuffer[index];
000050  4b09              LDR      r3,|L1.120|
000052  e003              B        |L1.92|
                  |L1.84|
000054  0094              LSLS     r4,r2,#2
000056  5904              LDR      r4,[r0,r4]
000058  601c              STR      r4,[r3,#0]
00005a  1c52              ADDS     r2,r2,#1              ;219
                  |L1.92|
00005c  428a              CMP      r2,r1                 ;219
00005e  d3f9              BCC      |L1.84|
;;;222      }
;;;223      return (CRC->DR);
000060  6818              LDR      r0,[r3,#0]
;;;224    }
000062  bd10              POP      {r4,pc}
;;;225    
                          ENDP

                  CRC_GetCRC PROC
;;;230      */
;;;231    uint32_t CRC_GetCRC(void)
000064  4804              LDR      r0,|L1.120|
;;;232    {
;;;233      return (CRC->DR);
000066  6800              LDR      r0,[r0,#0]
;;;234    }
000068  4770              BX       lr
;;;235    
                          ENDP

                  CRC_SetIDRegister PROC
;;;256      */
;;;257    void CRC_SetIDRegister(uint8_t CRC_IDValue)
00006a  4903              LDR      r1,|L1.120|
;;;258    {
;;;259      CRC->IDR = CRC_IDValue;
00006c  7108              STRB     r0,[r1,#4]
;;;260    }
00006e  4770              BX       lr
;;;261    
                          ENDP

                  CRC_GetIDRegister PROC
;;;266      */
;;;267    uint8_t CRC_GetIDRegister(void)
000070  4801              LDR      r0,|L1.120|
;;;268    {
;;;269      return (CRC->IDR);
000072  7900              LDRB     r0,[r0,#4]
;;;270    }
000074  4770              BX       lr
;;;271    
                          ENDP

000076  0000              DCW      0x0000
                  |L1.120|
                          DCD      0x40023000

;*** Start embedded assembler ***

#line 1 "..\\arch\\arm\\stm32f05x\\lib\\src\\stm32f0xx_crc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_crc_c_3a35c564____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f0xx_crc_c_3a35c564____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_crc_c_3a35c564____REVSH|
#line 144
|__asm___15_stm32f0xx_crc_c_3a35c564____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
