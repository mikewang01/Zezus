; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\htu20d.o --asm_dir=.\ --list_dir=.\ --depend=.\htu20d.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\htu20d.crf ..\drivers\stm32f051x\misc\htu20d\htu20d.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  htu20_rx_indicator PROC
;;;348    
;;;349    static os_err_t  htu20_rx_indicator(os_device_t* dev,os_size_t size)
000000  2001              MOVS     r0,#1
;;;350    {
;;;351        
;;;352        return SUCCESS;
;;;353    }
000002  4770              BX       lr
;;;354    
                          ENDP

                  htu20_send_data PROC
;;;481    
;;;482    static os_err_t htu20_send_data(u16 deviceAddr , u8 command , u8 *buffer )
000004  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;483    {
;;;484        u16  count_down;
;;;485        
;;;486        /*route of sending conv*/	
;;;487        if(command == WRITE_USER_REGISTER)
;;;488        {
;;;489            I2C_NumberOfBytesConfig(HTU20_BUS, 2);
000006  4ef7              LDR      r6,|L1.996|
000008  460c              MOV      r4,r1                 ;483
00000a  4605              MOV      r5,r0                 ;483
00000c  29e6              CMP      r1,#0xe6              ;487
00000e  d002              BEQ      |L1.22|
;;;490        }
;;;491        else if(command == SOFT_RESET)
000010  2cfe              CMP      r4,#0xfe
000012  d002              BEQ      |L1.26|
000014  e07a              B        |L1.268|
                  |L1.22|
000016  2102              MOVS     r1,#2                 ;489
000018  e000              B        |L1.28|
                  |L1.26|
;;;492        {
;;;493            I2C_NumberOfBytesConfig(HTU20_BUS, 1);
00001a  2101              MOVS     r1,#1
                  |L1.28|
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       I2C_NumberOfBytesConfig
;;;494        }else
;;;495        {
;;;496            return ERROR;
;;;497        }
;;;498        
;;;499        
;;;500        I2C_SlaveAddressConfig(HTU20_BUS, (deviceAddr<<1));
000022  0468              LSLS     r0,r5,#17
000024  0c01              LSRS     r1,r0,#16
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       I2C_SlaveAddressConfig
;;;501        
;;;502        I2C_MasterRequestConfig(HTU20_BUS, I2C_Direction_Transmitter);
00002c  2100              MOVS     r1,#0
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       I2C_MasterRequestConfig
;;;503        
;;;504        I2C_GenerateSTART(HTU20_BUS, ENABLE);           //START
000034  2101              MOVS     r1,#1
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       I2C_GenerateSTART
;;;505        
;;;506        /* tigger temper convertion */	
;;;507        I2C_SendData(HTU20_BUS , command);  //
00003c  4621              MOV      r1,r4
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       I2C_SendData
;;;508        
;;;509        count_down = HTU20_LONG_TIMEOUT;
000044  2705              MOVS     r7,#5
000046  037f              LSLS     r7,r7,#13
000048  463d              MOV      r5,r7
;;;510        
;;;511        while(!I2C_GetFlagStatus(HTU20_BUS, I2C_FLAG_TXE)) //???????,???NACK,????
00004a  e011              B        |L1.112|
                  |L1.76|
;;;512        {
;;;513            if(I2C_GetFlagStatus(HTU20_BUS,I2C_FLAG_NACKF))
00004c  2110              MOVS     r1,#0x10
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       I2C_GetFlagStatus
000054  2800              CMP      r0,#0
000056  d006              BEQ      |L1.102|
;;;514            {
;;;515                I2C_ClearFlag(HTU20_BUS,I2C_FLAG_NACKF);
000058  2110              MOVS     r1,#0x10
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       I2C_ClearFlag
;;;516                I2C_ClearFlag(HTU20_BUS,I2C_FLAG_STOPF);
000060  2120              MOVS     r1,#0x20
000062  4630              MOV      r0,r6
;;;517                return ERROR;
000064  e020              B        |L1.168|
                  |L1.102|
;;;518            }
;;;519            if(count_down-- == 0)
000066  4628              MOV      r0,r5
000068  1e6d              SUBS     r5,r5,#1
00006a  b2ad              UXTH     r5,r5
00006c  2800              CMP      r0,#0
00006e  d04c              BEQ      |L1.266|
                  |L1.112|
000070  2101              MOVS     r1,#1                 ;511
000072  4630              MOV      r0,r6                 ;511
000074  f7fffffe          BL       I2C_GetFlagStatus
000078  2800              CMP      r0,#0                 ;511
00007a  d0e7              BEQ      |L1.76|
;;;520            {
;;;521                return ERROR;
;;;522            }
;;;523            
;;;524        }
;;;525        
;;;526        
;;;527        /*send user register content*/
;;;528        if(command == WRITE_USER_REGISTER)
00007c  2ce6              CMP      r4,#0xe6
00007e  d121              BNE      |L1.196|
;;;529        {	
;;;530            /* tigger temper convertion */	
;;;531            I2C_SendData(HTU20_BUS , buffer[0]);  //
000080  9802              LDR      r0,[sp,#8]
000082  4635              MOV      r5,r6
000084  7801              LDRB     r1,[r0,#0]
000086  4630              MOV      r0,r6
000088  f7fffffe          BL       I2C_SendData
;;;532            
;;;533            count_down = HTU20_LONG_TIMEOUT;
00008c  463c              MOV      r4,r7
;;;534            
;;;535            while(!I2C_GetFlagStatus(HTU20_BUS, I2C_FLAG_TXE)) //???????,???NACK,????
00008e  e013              B        |L1.184|
                  |L1.144|
;;;536            {
;;;537                if(I2C_GetFlagStatus(HTU20_BUS,I2C_FLAG_NACKF))
000090  2110              MOVS     r1,#0x10
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       I2C_GetFlagStatus
000098  2800              CMP      r0,#0
00009a  d008              BEQ      |L1.174|
;;;538                {
;;;539                    I2C_ClearFlag(HTU20_BUS,I2C_FLAG_NACKF);
00009c  2110              MOVS     r1,#0x10
00009e  4628              MOV      r0,r5
0000a0  f7fffffe          BL       I2C_ClearFlag
;;;540                    I2C_ClearFlag(HTU20_BUS,I2C_FLAG_STOPF);
0000a4  2120              MOVS     r1,#0x20
0000a6  4628              MOV      r0,r5
                  |L1.168|
0000a8  f7fffffe          BL       I2C_ClearFlag
0000ac  e02e              B        |L1.268|
                  |L1.174|
;;;541                    return ERROR;
;;;542                }
;;;543                if(count_down-- == 0)
0000ae  4620              MOV      r0,r4
0000b0  1e64              SUBS     r4,r4,#1
0000b2  b2a4              UXTH     r4,r4
0000b4  2800              CMP      r0,#0
0000b6  d028              BEQ      |L1.266|
                  |L1.184|
0000b8  2101              MOVS     r1,#1                 ;535
0000ba  4628              MOV      r0,r5                 ;535
0000bc  f7fffffe          BL       I2C_GetFlagStatus
0000c0  2800              CMP      r0,#0                 ;535
0000c2  d0e5              BEQ      |L1.144|
                  |L1.196|
;;;544                {
;;;545                    return ERROR;
;;;546                }
;;;547                
;;;548            }
;;;549        }else if(command == SOFT_RESET)
;;;550        {
;;;551            /*no data need to be sent by this operation*/
;;;552        }
;;;553        
;;;554        count_down = HTU20_LONG_TIMEOUT;
0000c4  463c              MOV      r4,r7
;;;555        while(I2C_GetFlagStatus(HTU20_BUS ,  I2C_FLAG_TC) == RESET)
0000c6  e004              B        |L1.210|
                  |L1.200|
;;;556        {
;;;557            if(count_down-- == 0)
0000c8  4620              MOV      r0,r4
0000ca  1e64              SUBS     r4,r4,#1
0000cc  b2a4              UXTH     r4,r4
0000ce  2800              CMP      r0,#0
0000d0  d01b              BEQ      |L1.266|
                  |L1.210|
0000d2  2140              MOVS     r1,#0x40              ;555
0000d4  4630              MOV      r0,r6                 ;555
0000d6  f7fffffe          BL       I2C_GetFlagStatus
0000da  2800              CMP      r0,#0                 ;555
0000dc  d0f4              BEQ      |L1.200|
;;;558                return  ERROR;
;;;559        }
;;;560        
;;;561        
;;;562        I2C_GenerateSTOP(HTU20_BUS, ENABLE); 
0000de  2101              MOVS     r1,#1
0000e0  4630              MOV      r0,r6
0000e2  f7fffffe          BL       I2C_GenerateSTOP
;;;563        
;;;564        count_down = HTU20_LONG_TIMEOUT;		
0000e6  463d              MOV      r5,r7
;;;565        while(I2C_GetFlagStatus(HTU20_BUS, I2C_ISR_STOPF) == RESET)
0000e8  e004              B        |L1.244|
                  |L1.234|
;;;566        {
;;;567            if(count_down-- == 0)
0000ea  4629              MOV      r1,r5
0000ec  1e6d              SUBS     r5,r5,#1
0000ee  b2ad              UXTH     r5,r5
0000f0  2900              CMP      r1,#0
0000f2  d00b              BEQ      |L1.268|
                  |L1.244|
0000f4  2120              MOVS     r1,#0x20              ;565
0000f6  4630              MOV      r0,r6                 ;565
0000f8  f7fffffe          BL       I2C_GetFlagStatus
0000fc  2800              CMP      r0,#0                 ;565
0000fe  d0f4              BEQ      |L1.234|
;;;568                return  ERROR;
;;;569        }   
;;;570        
;;;571        /* Clear STOPF flag */
;;;572        I2C_ClearFlag(HTU20_BUS, I2C_ICR_STOPCF);
000100  2120              MOVS     r1,#0x20
000102  4630              MOV      r0,r6
000104  f7fffffe          BL       I2C_ClearFlag
;;;573        
;;;574        return  SUCCESS;
000108  2001              MOVS     r0,#1
                  |L1.266|
;;;575        
;;;576    }
00010a  bdfe              POP      {r1-r7,pc}
                  |L1.268|
00010c  2000              MOVS     r0,#0                 ;568
00010e  bdfe              POP      {r1-r7,pc}
;;;577    
                          ENDP

                  htu20_read_data PROC
;;;367    
;;;368    static os_err_t htu20_read_data(u16 deviceAddr , u8 command , u8 *buffer , size_t size)
000110  b5ff              PUSH     {r0-r7,lr}
;;;369    {
;;;370        u16 count=0;
;;;371        u16  count_down;
;;;372        /*route of sending conv*/	
;;;373        I2C_NumberOfBytesConfig(HTU20_BUS, 1);
000112  4cb4              LDR      r4,|L1.996|
000114  4607              MOV      r7,r0                 ;369
000116  b081              SUB      sp,sp,#4              ;369
000118  461d              MOV      r5,r3                 ;369
00011a  2600              MOVS     r6,#0                 ;370
00011c  2101              MOVS     r1,#1
00011e  4620              MOV      r0,r4
000120  f7fffffe          BL       I2C_NumberOfBytesConfig
;;;374        
;;;375        I2C_SlaveAddressConfig(HTU20_BUS, (deviceAddr<<1));
000124  0478              LSLS     r0,r7,#17
000126  0c01              LSRS     r1,r0,#16
000128  4620              MOV      r0,r4
00012a  f7fffffe          BL       I2C_SlaveAddressConfig
;;;376        
;;;377        I2C_MasterRequestConfig(HTU20_BUS, I2C_Direction_Transmitter);
00012e  2100              MOVS     r1,#0
000130  4620              MOV      r0,r4
000132  f7fffffe          BL       I2C_MasterRequestConfig
;;;378        
;;;379        I2C_GenerateSTART(HTU20_BUS, ENABLE);           //START
000136  2101              MOVS     r1,#1
000138  4620              MOV      r0,r4
00013a  f7fffffe          BL       I2C_GenerateSTART
;;;380        
;;;381        /* tigger temper convertion */	
;;;382        I2C_SendData(HTU20_BUS , command);  //
00013e  4620              MOV      r0,r4
000140  9902              LDR      r1,[sp,#8]
000142  f7fffffe          BL       I2C_SendData
;;;383        
;;;384        count_down = HTU20_LONG_TIMEOUT;
000146  2705              MOVS     r7,#5
000148  037f              LSLS     r7,r7,#13
;;;385        
;;;386        while(!I2C_GetFlagStatus(HTU20_BUS, I2C_FLAG_TXE)) //???????,???NACK,????
00014a  e013              B        |L1.372|
                  |L1.332|
;;;387        {
;;;388            if(I2C_GetFlagStatus(HTU20_BUS,I2C_FLAG_NACKF))
00014c  2110              MOVS     r1,#0x10
00014e  4620              MOV      r0,r4
000150  f7fffffe          BL       I2C_GetFlagStatus
000154  2800              CMP      r0,#0
000156  d008              BEQ      |L1.362|
;;;389            {
;;;390                I2C_ClearFlag(HTU20_BUS,I2C_FLAG_NACKF);
000158  2110              MOVS     r1,#0x10
00015a  4620              MOV      r0,r4
00015c  f7fffffe          BL       I2C_ClearFlag
;;;391                I2C_ClearFlag(HTU20_BUS,I2C_FLAG_STOPF);
000160  2120              MOVS     r1,#0x20
000162  4620              MOV      r0,r4
000164  f7fffffe          BL       I2C_ClearFlag
;;;392                return ERROR;
000168  e06d              B        |L1.582|
                  |L1.362|
;;;393            }
;;;394            if(count_down-- == 0)
00016a  4638              MOV      r0,r7
00016c  1e7f              SUBS     r7,r7,#1
00016e  b2bf              UXTH     r7,r7
000170  2800              CMP      r0,#0
000172  d066              BEQ      |L1.578|
                  |L1.372|
000174  2101              MOVS     r1,#1                 ;386
000176  4620              MOV      r0,r4                 ;386
000178  f7fffffe          BL       I2C_GetFlagStatus
00017c  2800              CMP      r0,#0                 ;386
00017e  d0e5              BEQ      |L1.332|
;;;395            {
;;;396                return ERROR;
;;;397            }
;;;398            
;;;399        }
;;;400        
;;;401        
;;;402        count_down = HTU20_LONG_TIMEOUT;	
000180  2705              MOVS     r7,#5
000182  037f              LSLS     r7,r7,#13
                  |L1.388|
;;;403        do{
;;;404            /*wait for the return data from sensor*/	 
;;;405            I2C_ClearFlag(HTU20_BUS , I2C_FLAG_NACKF);
000184  2110              MOVS     r1,#0x10
000186  4620              MOV      r0,r4
000188  f7fffffe          BL       I2C_ClearFlag
;;;406            
;;;407            I2C_ClearFlag(HTU20_BUS , I2C_FLAG_STOPF);
00018c  2120              MOVS     r1,#0x20
00018e  4620              MOV      r0,r4
000190  f7fffffe          BL       I2C_ClearFlag
;;;408            
;;;409            I2C_NumberOfBytesConfig(HTU20_BUS , size);
000194  b2e9              UXTB     r1,r5
000196  4620              MOV      r0,r4
000198  f7fffffe          BL       I2C_NumberOfBytesConfig
;;;410            
;;;411            
;;;412            I2C_MasterRequestConfig(HTU20_BUS , I2C_Direction_Receiver);
00019c  2101              MOVS     r1,#1
00019e  0289              LSLS     r1,r1,#10
0001a0  4620              MOV      r0,r4
0001a2  f7fffffe          BL       I2C_MasterRequestConfig
;;;413            
;;;414            I2C_GenerateSTART(HTU20_BUS , ENABLE);           //START
0001a6  2101              MOVS     r1,#1
0001a8  4620              MOV      r0,r4
0001aa  f7fffffe          BL       I2C_GenerateSTART
;;;415            
;;;416            if(count_down-- == 0)
0001ae  4638              MOV      r0,r7
0001b0  1e7f              SUBS     r7,r7,#1
0001b2  b2bf              UXTH     r7,r7
0001b4  2800              CMP      r0,#0
0001b6  d044              BEQ      |L1.578|
;;;417            {
;;;418                return ERROR;
;;;419            }			 
;;;420            
;;;421            
;;;422        }while(I2C_GetFlagStatus(HTU20_BUS ,I2C_FLAG_NACKF)==SET);
0001b8  2110              MOVS     r1,#0x10
0001ba  4620              MOV      r0,r4
0001bc  f7fffffe          BL       I2C_GetFlagStatus
0001c0  2801              CMP      r0,#1
0001c2  d0df              BEQ      |L1.388|
0001c4  2705              MOVS     r7,#5                 ;384
0001c6  037f              LSLS     r7,r7,#13             ;384
                  |L1.456|
;;;423        
;;;424        
;;;425        /*get specific size of  data*/
;;;426        while(size>0)
0001c8  2d00              CMP      r5,#0
0001ca  d015              BEQ      |L1.504|
;;;427        {	
;;;428            
;;;429            count_down = HTU20_LONG_TIMEOUT;
0001cc  463c              MOV      r4,r7
;;;430            
;;;431            while(!I2C_GetFlagStatus(HTU20_BUS, I2C_FLAG_RXNE))
0001ce  e004              B        |L1.474|
                  |L1.464|
;;;432            {
;;;433                if(count_down-- == 0)
0001d0  4620              MOV      r0,r4
0001d2  1e64              SUBS     r4,r4,#1
0001d4  b2a4              UXTH     r4,r4
0001d6  2800              CMP      r0,#0
0001d8  d033              BEQ      |L1.578|
                  |L1.474|
0001da  2104              MOVS     r1,#4                 ;431
0001dc  4881              LDR      r0,|L1.996|
0001de  f7fffffe          BL       I2C_GetFlagStatus
0001e2  2800              CMP      r0,#0                 ;431
0001e4  d0f4              BEQ      |L1.464|
;;;434                    return  ERROR;
;;;435            }
;;;436            
;;;437            buffer[count]=I2C_ReceiveData(HTU20_BUS);
0001e6  487f              LDR      r0,|L1.996|
0001e8  f7fffffe          BL       I2C_ReceiveData
0001ec  9903              LDR      r1,[sp,#0xc]
;;;438            size --;
0001ee  1e6d              SUBS     r5,r5,#1
0001f0  5588              STRB     r0,[r1,r6]            ;437
;;;439            count ++;
0001f2  1c76              ADDS     r6,r6,#1
0001f4  b2b6              UXTH     r6,r6
0001f6  e7e7              B        |L1.456|
                  |L1.504|
;;;440        }	
;;;441        
;;;442        count_down = HTU20_LONG_TIMEOUT;
0001f8  463e              MOV      r6,r7
0001fa  4c7a              LDR      r4,|L1.996|
;;;443        while(I2C_GetFlagStatus(HTU20_BUS ,  I2C_FLAG_TC) == RESET)
0001fc  e004              B        |L1.520|
                  |L1.510|
;;;444        {
;;;445            if(count_down-- == 0)
0001fe  4630              MOV      r0,r6
000200  1e76              SUBS     r6,r6,#1
000202  b2b6              UXTH     r6,r6
000204  2800              CMP      r0,#0
000206  d01c              BEQ      |L1.578|
                  |L1.520|
000208  2140              MOVS     r1,#0x40              ;443
00020a  4620              MOV      r0,r4                 ;443
00020c  f7fffffe          BL       I2C_GetFlagStatus
000210  2800              CMP      r0,#0                 ;443
000212  d0f4              BEQ      |L1.510|
;;;446                return  ERROR;
;;;447        }
;;;448        
;;;449        
;;;450        I2C_GenerateSTOP(HTU20_BUS, ENABLE); 
000214  2101              MOVS     r1,#1
000216  4625              MOV      r5,r4
000218  4620              MOV      r0,r4
00021a  f7fffffe          BL       I2C_GenerateSTOP
;;;451        
;;;452        count_down = HTU20_LONG_TIMEOUT;		
00021e  463c              MOV      r4,r7
;;;453        while(I2C_GetFlagStatus(HTU20_BUS, I2C_ISR_STOPF) == RESET)
000220  e004              B        |L1.556|
                  |L1.546|
;;;454        {
;;;455            if(count_down-- == 0)
000222  4621              MOV      r1,r4
000224  1e64              SUBS     r4,r4,#1
000226  b2a4              UXTH     r4,r4
000228  2900              CMP      r1,#0
00022a  d00c              BEQ      |L1.582|
                  |L1.556|
00022c  2120              MOVS     r1,#0x20              ;453
00022e  4628              MOV      r0,r5                 ;453
000230  f7fffffe          BL       I2C_GetFlagStatus
000234  2800              CMP      r0,#0                 ;453
000236  d0f4              BEQ      |L1.546|
;;;456                return  ERROR;
;;;457        }   
;;;458        
;;;459        /* Clear STOPF flag */
;;;460        I2C_ClearFlag(HTU20_BUS, I2C_ICR_STOPCF);
000238  2120              MOVS     r1,#0x20
00023a  4628              MOV      r0,r5
00023c  f7fffffe          BL       I2C_ClearFlag
;;;461        
;;;462        //if(buffer[3] == calcrc_8(buffer , 2))		
;;;463        return  SUCCESS;
000240  2001              MOVS     r0,#1
                  |L1.578|
;;;464        
;;;465        
;;;466    }
000242  b005              ADD      sp,sp,#0x14
000244  bdf0              POP      {r4-r7,pc}
                  |L1.582|
000246  2000              MOVS     r0,#0                 ;456
000248  e7fb              B        |L1.578|
;;;467    
                          ENDP

                  htu20_control PROC
;;;295    
;;;296    static os_err_t  htu20_control(os_device_t* dev, u8 cmd, void *args)
00024a  b53e              PUSH     {r1-r5,lr}
;;;297    {
00024c  4614              MOV      r4,r2
;;;298        //    u8 adc_num=((u8*)args)[1];
;;;299        u8 buffer[10]={0};
00024e  2200              MOVS     r2,#0
000250  9200              STR      r2,[sp,#0]
000252  9201              STR      r2,[sp,#4]
;;;300        u32 temp;
;;;301        if(dev==NULL)
000254  9202              STR      r2,[sp,#8]
000256  2800              CMP      r0,#0
000258  d054              BEQ      |L1.772|
;;;302        {
;;;303            return ERROR;
;;;304        }
;;;305        switch(cmd)
;;;306        {
;;;307        /*trigger and read humidity data from sensor*/			
;;;308        case TRIGGER_HUMI_MEASUREMENT: if(SUCCESS == htu20_read_data(htu20_dev->dev_adress , TRIGGER_HUMI_MEASUREMENT , buffer , 3))
00025a  4863              LDR      r0,|L1.1000|
00025c  6800              LDR      r0,[r0,#0]
00025e  3040              ADDS     r0,r0,#0x40
000260  29e6              CMP      r1,#0xe6              ;305
000262  d045              BEQ      |L1.752|
000264  dc05              BGT      |L1.626|
;;;309            {
;;;310                temp = (buffer)[0]<<8|(buffer[1]&(~0x03));
;;;311                ((htu20_data *)args)->humidity = ((temp*12500)>>16)-600; 
;;;312                ((htu20_data *)args)->ampfifier_times = 100;
000266  2564              MOVS     r5,#0x64
000268  29e3              CMP      r1,#0xe3              ;305
00026a  d01e              BEQ      |L1.682|
00026c  29e5              CMP      r1,#0xe5              ;305
00026e  d148              BNE      |L1.770|
000270  e004              B        |L1.636|
                  |L1.626|
000272  29e7              CMP      r1,#0xe7              ;305
000274  d030              BEQ      |L1.728|
000276  29fe              CMP      r1,#0xfe              ;305
000278  d143              BNE      |L1.770|
00027a  e03d              B        |L1.760|
                  |L1.636|
00027c  7900              LDRB     r0,[r0,#4]            ;308
00027e  2303              MOVS     r3,#3                 ;308
000280  466a              MOV      r2,sp                 ;308
000282  21e5              MOVS     r1,#0xe5              ;308
000284  f7fffffe          BL       htu20_read_data
000288  2801              CMP      r0,#1                 ;308
00028a  d13a              BNE      |L1.770|
00028c  4669              MOV      r1,sp                 ;310
00028e  7808              LDRB     r0,[r1,#0]            ;310
000290  7849              LDRB     r1,[r1,#1]            ;310
000292  0200              LSLS     r0,r0,#8              ;310
000294  0889              LSRS     r1,r1,#2              ;310
000296  0089              LSLS     r1,r1,#2              ;310
000298  4308              ORRS     r0,r0,r1              ;310
00029a  4954              LDR      r1,|L1.1004|
00029c  4348              MULS     r0,r1,r0              ;311
00029e  214b              MOVS     r1,#0x4b              ;311
0002a0  0c00              LSRS     r0,r0,#16             ;311
0002a2  00c9              LSLS     r1,r1,#3              ;311
0002a4  1a40              SUBS     r0,r0,r1              ;311
0002a6  8060              STRH     r0,[r4,#2]            ;311
0002a8  e014              B        |L1.724|
                  |L1.682|
;;;313            }break;
;;;314            /*trigger and read temperature data from sensor*/			
;;;315        case TRIGGER_TEMP_MEASUREMENT: if(SUCCESS == htu20_read_data(htu20_dev->dev_adress , TRIGGER_TEMP_MEASUREMENT , buffer , 3))
0002aa  7900              LDRB     r0,[r0,#4]
0002ac  2303              MOVS     r3,#3
0002ae  466a              MOV      r2,sp
0002b0  21e3              MOVS     r1,#0xe3
0002b2  f7fffffe          BL       htu20_read_data
0002b6  2801              CMP      r0,#1
0002b8  d123              BNE      |L1.770|
;;;316            {
;;;317                temp = (buffer)[0]<<8|(buffer[1]&(~0x03));
0002ba  4669              MOV      r1,sp
0002bc  7808              LDRB     r0,[r1,#0]
0002be  7849              LDRB     r1,[r1,#1]
0002c0  0200              LSLS     r0,r0,#8
0002c2  0889              LSRS     r1,r1,#2
0002c4  0089              LSLS     r1,r1,#2
0002c6  4308              ORRS     r0,r0,r1
;;;318                ((htu20_data *)args)->temper =  ((temp*17572)>>16)-4685;
0002c8  4949              LDR      r1,|L1.1008|
0002ca  4348              MULS     r0,r1,r0
0002cc  4949              LDR      r1,|L1.1012|
0002ce  0c00              LSRS     r0,r0,#16
0002d0  1840              ADDS     r0,r0,r1
0002d2  8020              STRH     r0,[r4,#0]
                  |L1.724|
;;;319                ((htu20_data *)args)->ampfifier_times = 100;
0002d4  80a5              STRH     r5,[r4,#4]
0002d6  e014              B        |L1.770|
                  |L1.728|
;;;320            }break;
;;;321            /*read user register data*/			
;;;322        case READ_USER_REGISTER:       if(SUCCESS == htu20_read_data(htu20_dev->dev_adress , READ_USER_REGISTER       , buffer , 1))
0002d8  7900              LDRB     r0,[r0,#4]
0002da  2301              MOVS     r3,#1
0002dc  466a              MOV      r2,sp
0002de  21e7              MOVS     r1,#0xe7
0002e0  f7fffffe          BL       htu20_read_data
0002e4  2801              CMP      r0,#1
0002e6  d10c              BNE      |L1.770|
;;;323            {
;;;324                ((htu20_data *)args)->user_res_content = buffer[0];
0002e8  4668              MOV      r0,sp
0002ea  7800              LDRB     r0,[r0,#0]
0002ec  71a0              STRB     r0,[r4,#6]
0002ee  e008              B        |L1.770|
                  |L1.752|
;;;325                
;;;326            }break;
;;;327            
;;;328        case WRITE_USER_REGISTER:      htu20_send_data(htu20_dev->dev_adress , WRITE_USER_REGISTER      , &(((htu20_data *)args)->user_res_content) );  break;
0002f0  1da2              ADDS     r2,r4,#6
0002f2  7900              LDRB     r0,[r0,#4]
0002f4  21e6              MOVS     r1,#0xe6
0002f6  e002              B        |L1.766|
                  |L1.760|
;;;329            /*reset sensor via software*/			
;;;330        case SOFT_RESET:  						 htu20_send_data(htu20_dev->dev_adress , SOFT_RESET , buffer );          break;    
0002f8  7900              LDRB     r0,[r0,#4]
0002fa  466a              MOV      r2,sp
0002fc  21fe              MOVS     r1,#0xfe
                  |L1.766|
0002fe  f7fffffe          BL       htu20_send_data
                  |L1.770|
;;;331        default:break;
;;;332            
;;;333        }
;;;334        return SUCCESS;
000302  2001              MOVS     r0,#1
                  |L1.772|
;;;335    }
000304  bd3e              POP      {r1-r5,pc}
;;;336    
                          ENDP

                  htu20_write PROC
;;;229    
;;;230    static os_size_t  htu20_write(os_device_t* dev, os_off_t pos, const void *buffer, os_size_t size)
000306  4299              CMP      r1,r3
;;;231    {
000308  d203              BCS      |L1.786|
;;;232        
;;;233        
;;;234        if(pos>=size||buffer==NULL||size>USART_TX_BUFFER_SIZE)
00030a  2a00              CMP      r2,#0
00030c  d001              BEQ      |L1.786|
00030e  2b40              CMP      r3,#0x40
000310  d901              BLS      |L1.790|
                  |L1.786|
;;;235        {
;;;236            return  NULL;
000312  2000              MOVS     r0,#0
;;;237        }else
;;;238        {
;;;239            char* temp=(char*)buffer; 
;;;240            if(pos>0)
;;;241            {
;;;242                temp=temp+pos;
;;;243            }				 
;;;244            
;;;245            while(size>0)
;;;246            {
;;;247                
;;;248                
;;;249            }
;;;250        }
;;;251        
;;;252        return SUCCESS;
;;;253    }	
000314  4770              BX       lr
                  |L1.790|
000316  2b00              CMP      r3,#0                 ;245
000318  d1fd              BNE      |L1.790|
00031a  2001              MOVS     r0,#1                 ;252
00031c  4770              BX       lr
;;;254    /*********************************************************************
                          ENDP

                  htu20_open PROC
;;;190     */
;;;191    static os_err_t  htu20_open(os_device_t* dev, u16 oflag)
00031e  b510              PUSH     {r4,lr}
;;;192    {
;;;193        os_clock_open("I2C");
000320  a035              ADR      r0,|L1.1016|
000322  f7fffffe          BL       os_clock_open
;;;194        os_clock_open("GPIOF");	
000326  a035              ADR      r0,|L1.1020|
000328  f7fffffe          BL       os_clock_open
;;;195        
;;;196        return SUCCESS;	
00032c  2001              MOVS     r0,#1
;;;197    }
00032e  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  htu20_init PROC
;;;129    
;;;130    os_err_t  htu20_init   (os_device_t* dev)
000330  b510              PUSH     {r4,lr}
;;;131    {  	 
000332  b08a              SUB      sp,sp,#0x28
;;;132        
;;;133        
;;;134        
;;;135        GPIO_InitTypeDef  GPIO_InitStruct; 
;;;136        I2C_InitTypeDef  I2C_InitStruct; 
;;;137        
;;;138        
;;;139        os_clock_open("I2C2");
000334  a033              ADR      r0,|L1.1028|
000336  f7fffffe          BL       os_clock_open
;;;140        os_clock_open("GPIOF");
00033a  a030              ADR      r0,|L1.1020|
00033c  f7fffffe          BL       os_clock_open
;;;141        
;;;142        /*!< GPIO configuration */  
;;;143        /*!< Configure sEE_I2C pins: SCL */
;;;144        GPIO_InitStruct.GPIO_Pin = BIT_SHIFT(HTU20_PIN_SCL) | BIT_SHIFT(HTU20_PIN_SDA);
000340  20c0              MOVS     r0,#0xc0
;;;145        GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
000342  9000              STR      r0,[sp,#0]
000344  2002              MOVS     r0,#2
000346  4669              MOV      r1,sp
000348  7108              STRB     r0,[r1,#4]
;;;146        GPIO_InitStruct.GPIO_Speed = GPIO_Speed_Level_3;
00034a  2003              MOVS     r0,#3
00034c  7148              STRB     r0,[r1,#5]
;;;147        GPIO_InitStruct.GPIO_OType = GPIO_OType_OD;
00034e  2001              MOVS     r0,#1
;;;148        GPIO_Init(HTU20_PORT , &GPIO_InitStruct);
000350  4c2e              LDR      r4,|L1.1036|
000352  7188              STRB     r0,[r1,#6]            ;147
000354  4620              MOV      r0,r4
000356  f7fffffe          BL       GPIO_Init
;;;149        
;;;150        /*!< Configure sEE_I2C pins: SDA & SCL*/
;;;151        GPIO_Init(HTU20_PORT , &GPIO_InitStruct);
00035a  4669              MOV      r1,sp
00035c  4620              MOV      r0,r4
00035e  f7fffffe          BL       GPIO_Init
;;;152        
;;;153        /* Connect PXx to I2C2_SCL*/
;;;154        GPIO_PinAFConfig( HTU20_PORT , HTU20_PIN_SCL , GPIO_AF_1); 
000362  2201              MOVS     r2,#1
000364  2106              MOVS     r1,#6
000366  4620              MOV      r0,r4
000368  f7fffffe          BL       GPIO_PinAFConfig
;;;155        /* Connect PXx to I2C2_SDA*/
;;;156        GPIO_PinAFConfig( HTU20_PORT , HTU20_PIN_SDA , GPIO_AF_1);	 
00036c  2201              MOVS     r2,#1
00036e  2107              MOVS     r1,#7
000370  4620              MOV      r0,r4
000372  f7fffffe          BL       GPIO_PinAFConfig
;;;157        
;;;158        /*************************************************************************************/
;;;159        I2C_DeInit(HTU20_BUS);
000376  4c1b              LDR      r4,|L1.996|
000378  4620              MOV      r0,r4
00037a  f7fffffe          BL       I2C_DeInit
;;;160        /* I2C configuration */
;;;161        I2C_InitStruct.I2C_Mode = I2C_Mode_I2C;
00037e  2100              MOVS     r1,#0
;;;162        I2C_InitStruct.I2C_AnalogFilter = I2C_AnalogFilter_Enable;
;;;163        I2C_InitStruct.I2C_DigitalFilter = 0x00;
;;;164        I2C_InitStruct.I2C_OwnAddress1 =0x00;
;;;165        I2C_InitStruct.I2C_Ack = I2C_Ack_Enable;
;;;166        I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;	
000380  9107              STR      r1,[sp,#0x1c]
000382  9103              STR      r1,[sp,#0xc]          ;163
;;;167        I2C_InitStruct.I2C_Timing = 0x10805E89;
000384  4822              LDR      r0,|L1.1040|
000386  9105              STR      r1,[sp,#0x14]         ;162
000388  9104              STR      r1,[sp,#0x10]         ;164
00038a  9106              STR      r1,[sp,#0x18]         ;165
;;;168        
;;;169        /* I2C Peripheral Enable */
;;;170        I2C_Cmd(HTU20_BUS , ENABLE);
00038c  9108              STR      r1,[sp,#0x20]
00038e  9002              STR      r0,[sp,#8]
000390  2101              MOVS     r1,#1
000392  4620              MOV      r0,r4
000394  f7fffffe          BL       I2C_Cmd
;;;171        /* Apply I2C configuration after enabling it */
;;;172        I2C_Init(HTU20_BUS , &I2C_InitStruct);
000398  a902              ADD      r1,sp,#8
00039a  4620              MOV      r0,r4
00039c  f7fffffe          BL       I2C_Init
;;;173        
;;;174        
;;;175        
;;;176        return SUCCESS;
0003a0  2001              MOVS     r0,#1
;;;177        
;;;178    }
0003a2  b00a              ADD      sp,sp,#0x28
0003a4  bd10              POP      {r4,pc}
;;;179    
                          ENDP

                  htu20_register PROC
;;;82     
;;;83     os_err_t htu20_register(u16 task_id)
0003a6  b510              PUSH     {r4,lr}
;;;84     {
0003a8  4604              MOV      r4,r0
;;;85         
;;;86         htu20_dev=osmalloc(sizeof(htu20_device));
0003aa  204c              MOVS     r0,#0x4c
0003ac  f7fffffe          BL       osmalloc
0003b0  490d              LDR      r1,|L1.1000|
;;;87         
;;;88         htu20_dev->clk =HTU20_CLK_DEFAULT;
;;;89         
;;;90         //	htu20_dev->prescale=SPICLK_DIV_4;
;;;91         
;;;92         htu20_dev->os_device.type   = OS_Device_Class_I2CBUS;
0003b2  2208              MOVS     r2,#8
0003b4  6008              STR      r0,[r1,#0]            ;88  ; htu20_dev
0003b6  2101              MOVS     r1,#1                 ;88
0003b8  6401              STR      r1,[r0,#0x40]
0003ba  7402              STRB     r2,[r0,#0x10]
;;;93         
;;;94         htu20_dev->os_device.device_id = OS_DEVICE_USART_ID;
0003bc  7581              STRB     r1,[r0,#0x16]
;;;95         
;;;96         htu20_dev->register_taskid   =  task_id;
0003be  8784              STRH     r4,[r0,#0x3c]
;;;97         
;;;98         
;;;99         htu20_dev->os_device.init    =  htu20_init;
0003c0  4914              LDR      r1,|L1.1044|
;;;100        
;;;101        htu20_dev->os_device.open    =  htu20_open;
0003c2  6201              STR      r1,[r0,#0x20]
0003c4  4914              LDR      r1,|L1.1048|
;;;102        
;;;103        htu20_dev->os_device.write   =  htu20_write;
0003c6  6241              STR      r1,[r0,#0x24]
0003c8  4914              LDR      r1,|L1.1052|
;;;104        
;;;105        htu20_dev->os_device.control =  htu20_control;
0003ca  6301              STR      r1,[r0,#0x30]
0003cc  4914              LDR      r1,|L1.1056|
;;;106        
;;;107        htu20_dev->dev_adress        =  HTU20_ADRESS;
0003ce  6341              STR      r1,[r0,#0x34]
0003d0  2240              MOVS     r2,#0x40
0003d2  2144              MOVS     r1,#0x44
0003d4  540a              STRB     r2,[r1,r0]
;;;108        
;;;109        htu20_dev->os_device.rx_indicate = htu20_rx_indicator;
0003d6  4913              LDR      r1,|L1.1060|
;;;110        
;;;111        return os_device_register(&(htu20_dev->os_device), HTU20_NAME, OS_DEVICE_FLAG_INACTIVATED);
0003d8  6181              STR      r1,[r0,#0x18]
0003da  2202              MOVS     r2,#2
0003dc  a112              ADR      r1,|L1.1064|
0003de  f7fffffe          BL       os_device_register
;;;112        
;;;113    }
0003e2  bd10              POP      {r4,pc}
                  |L1.996|
                          DCD      0x40005800
                  |L1.1000|
                          DCD      ||.data||
                  |L1.1004|
                          DCD      0x000030d4
                  |L1.1008|
                          DCD      0x000044a4
                  |L1.1012|
                          DCD      0xffffedb3
                  |L1.1016|
0003f8  49324300          DCB      "I2C",0
                  |L1.1020|
0003fc  4750494f          DCB      "GPIOF",0
000400  4600    
000402  00                DCB      0
000403  00                DCB      0
                  |L1.1028|
000404  49324332          DCB      "I2C2",0
000408  00      
000409  00                DCB      0
00040a  00                DCB      0
00040b  00                DCB      0
                  |L1.1036|
                          DCD      0x48001400
                  |L1.1040|
                          DCD      0x10805e89
                  |L1.1044|
                          DCD      htu20_init
                  |L1.1048|
                          DCD      htu20_open
                  |L1.1052|
                          DCD      htu20_write
                  |L1.1056|
                          DCD      htu20_control
                  |L1.1060|
                          DCD      htu20_rx_indicator
                  |L1.1064|
000428  48545532          DCB      "HTU20",0
00042c  3000    
00042e  00                DCB      0
00042f  00                DCB      0
                          ENDP

                  htu20_close PROC
;;;208     */
;;;209    os_err_t  htu20_close(os_device_t* dev, u16 oflag)
000430  b510              PUSH     {r4,lr}
;;;210    {
;;;211        
;;;212        os_clock_close("htu20");
000432  a013              ADR      r0,|L1.1152|
000434  f7fffffe          BL       os_clock_close
;;;213        os_clock_close("GPIOB");
000438  a013              ADR      r0,|L1.1160|
00043a  f7fffffe          BL       os_clock_close
;;;214        
;;;215        return SUCCESS;		
00043e  2001              MOVS     r0,#1
;;;216        
;;;217    }
000440  bd10              POP      {r4,pc}
;;;218    /*********************************************************************
                          ENDP

                  htu20_read PROC
;;;265    
;;;266    os_size_t htu20_read   (os_device_t* dev, os_off_t pos, void *buffer, os_size_t size)
000442  4601              MOV      r1,r0
;;;267    {
;;;268        u16 i=0;
000444  2000              MOVS     r0,#0
;;;269        if(dev==NULL)
000446  2900              CMP      r1,#0
000448  d002              BEQ      |L1.1104|
                  |L1.1098|
;;;270        {
;;;271            return ERROR;
;;;272        }
;;;273        
;;;274        while(size >0)
00044a  2b00              CMP      r3,#0
00044c  d1fd              BNE      |L1.1098|
;;;275        {
;;;276            
;;;277            
;;;278        }
;;;279        
;;;280        return  i;	
;;;281        
;;;282    }
00044e  4770              BX       lr
                  |L1.1104|
000450  2000              MOVS     r0,#0                 ;271
000452  4770              BX       lr
;;;283    
                          ENDP

                  calcrc_1byte PROC
;;;590    
;;;591    u8 calcrc_1byte(u8 abyte)  
000454  b530              PUSH     {r4,r5,lr}
;;;592    {  
000456  4602              MOV      r2,r0
;;;593        u8 i,crc_1byte;   
;;;594        crc_1byte=0;                //??crc_1byte???0
000458  2000              MOVS     r0,#0
;;;595        for(i = 0; i < 8; i++)  
;;;596        {  
;;;597            if(((crc_1byte^abyte)&0x01))  
;;;598            {  
;;;599                crc_1byte^=0x18;   
00045a  2318              MOVS     r3,#0x18
00045c  4601              MOV      r1,r0                 ;595
;;;600                crc_1byte>>=1;  
;;;601                crc_1byte|=0x80;  
00045e  2480              MOVS     r4,#0x80
                  |L1.1120|
000460  4605              MOV      r5,r0
000462  4055              EORS     r5,r5,r2              ;597
000464  07ed              LSLS     r5,r5,#31             ;597
000466  d003              BEQ      |L1.1136|
000468  4058              EORS     r0,r0,r3              ;599
00046a  0840              LSRS     r0,r0,#1              ;600
00046c  4320              ORRS     r0,r0,r4
00046e  e000              B        |L1.1138|
                  |L1.1136|
;;;602            }        
;;;603            else   
;;;604                crc_1byte>>=1; 
000470  0840              LSRS     r0,r0,#1
                  |L1.1138|
000472  1c49              ADDS     r1,r1,#1              ;595
;;;605            abyte>>=1;        
000474  0852              LSRS     r2,r2,#1
000476  b2c9              UXTB     r1,r1                 ;595
000478  2908              CMP      r1,#8                 ;595
00047a  d3f1              BCC      |L1.1120|
;;;606        } 
;;;607        return crc_1byte; 
;;;608    } 
00047c  bd30              POP      {r4,r5,pc}
;;;609    
                          ENDP

00047e  0000              DCW      0x0000
                  |L1.1152|
000480  68747532          DCB      "htu20",0
000484  3000    
000486  00                DCB      0
000487  00                DCB      0
                  |L1.1160|
000488  4750494f          DCB      "GPIOB",0
00048c  4200    
00048e  00                DCB      0
00048f  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  htu20_dev
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\drivers\\stm32f051x\\misc\\htu20d\\htu20d.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_htu20d_c_275e6911____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_htu20d_c_275e6911____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_htu20d_c_275e6911____REVSH|
#line 144
|__asm___8_htu20d_c_275e6911____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
