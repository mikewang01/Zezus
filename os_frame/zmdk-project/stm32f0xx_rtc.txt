; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\stm32f0xx_rtc.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f0xx_rtc.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\stm32f0xx_rtc.crf ..\arch\arm\stm32f05x\lib\src\stm32f0xx_rtc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;531      */
;;;532    ErrorStatus RTC_WaitForSynchro(void)
000000  b518              PUSH     {r3,r4,lr}
;;;533    {
;;;534      __IO uint32_t synchrocounter = 0;
000002  2000              MOVS     r0,#0
;;;535      ErrorStatus status = ERROR;
;;;536      uint32_t synchrostatus = 0x00;
;;;537    
;;;538      if ((RTC->CR & RTC_CR_BYPSHAD) != RESET)
000004  4bf9              LDR      r3,|L1.1004|
000006  9000              STR      r0,[sp,#0]
000008  6898              LDR      r0,[r3,#8]
00000a  0680              LSLS     r0,r0,#26
00000c  d501              BPL      |L1.18|
;;;539      {
;;;540        /* Bypass shadow mode */
;;;541        status = SUCCESS;
00000e  2001              MOVS     r0,#1
;;;542      }
;;;543      else
;;;544      {
;;;545        /* Disable the write protection for RTC registers */
;;;546        RTC->WPR = 0xCA;
;;;547        RTC->WPR = 0x53;
;;;548    
;;;549        /* Clear RSF flag */
;;;550        RTC->ISR &= (uint32_t)RTC_RSF_MASK;
;;;551    
;;;552        /* Wait the registers to be synchronised */
;;;553        do
;;;554        {
;;;555          synchrostatus = RTC->ISR & RTC_ISR_RSF;
;;;556          synchrocounter++;  
;;;557        } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
;;;558    
;;;559        if ((RTC->ISR & RTC_ISR_RSF) != RESET)
;;;560        {
;;;561          status = SUCCESS;
;;;562        }
;;;563        else
;;;564        {
;;;565          status = ERROR;
;;;566        }
;;;567    
;;;568        /* Enable the write protection for RTC registers */
;;;569        RTC->WPR = 0xFF;
;;;570      }
;;;571    
;;;572      return (status);
;;;573    }
000010  bd18              POP      {r3,r4,pc}
                  |L1.18|
000012  20ca              MOVS     r0,#0xca              ;546
000014  6258              STR      r0,[r3,#0x24]         ;546
000016  2053              MOVS     r0,#0x53              ;547
000018  6258              STR      r0,[r3,#0x24]         ;547
00001a  68d8              LDR      r0,[r3,#0xc]          ;550
00001c  21a0              MOVS     r1,#0xa0              ;550
00001e  4388              BICS     r0,r0,r1              ;550
000020  60d8              STR      r0,[r3,#0xc]          ;550
000022  2120              MOVS     r1,#0x20              ;555
000024  028c              LSLS     r4,r1,#10             ;557
                  |L1.38|
000026  68d8              LDR      r0,[r3,#0xc]          ;555
000028  9a00              LDR      r2,[sp,#0]            ;556
00002a  4008              ANDS     r0,r0,r1              ;555
00002c  1c52              ADDS     r2,r2,#1              ;556
00002e  9200              STR      r2,[sp,#0]            ;557
000030  42a2              CMP      r2,r4                 ;557
000032  d001              BEQ      |L1.56|
000034  2800              CMP      r0,#0                 ;557
000036  d0f6              BEQ      |L1.38|
                  |L1.56|
000038  68d8              LDR      r0,[r3,#0xc]          ;559
00003a  0680              LSLS     r0,r0,#26             ;559
00003c  d501              BPL      |L1.66|
00003e  2001              MOVS     r0,#1                 ;561
000040  e000              B        |L1.68|
                  |L1.66|
000042  2000              MOVS     r0,#0                 ;565
                  |L1.68|
000044  21ff              MOVS     r1,#0xff              ;569
000046  6259              STR      r1,[r3,#0x24]         ;569
000048  bd18              POP      {r3,r4,pc}
;;;574    
                          ENDP

                  RTC_EnterInitMode PROC
;;;464      */
;;;465    ErrorStatus RTC_EnterInitMode(void)
00004a  b518              PUSH     {r3,r4,lr}
;;;466    {
;;;467      __IO uint32_t initcounter = 0x00;
00004c  2000              MOVS     r0,#0
;;;468      ErrorStatus status = ERROR;
;;;469      uint32_t initstatus = 0x00;
;;;470    
;;;471      /* Check if the Initialization mode is set */
;;;472      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
00004e  4be7              LDR      r3,|L1.1004|
000050  9000              STR      r0,[sp,#0]
000052  68d8              LDR      r0,[r3,#0xc]
000054  0640              LSLS     r0,r0,#25
000056  d412              BMI      |L1.126|
;;;473      {
;;;474        /* Set the Initialization mode */
;;;475        RTC->ISR = (uint32_t)RTC_INIT_MASK;
000058  2000              MOVS     r0,#0
00005a  43c0              MVNS     r0,r0
00005c  60d8              STR      r0,[r3,#0xc]
;;;476        
;;;477        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;478        do
;;;479        {
;;;480          initstatus = RTC->ISR & RTC_ISR_INITF;
00005e  2140              MOVS     r1,#0x40
;;;481          initcounter++;  
;;;482        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
000060  020c              LSLS     r4,r1,#8
                  |L1.98|
000062  68d8              LDR      r0,[r3,#0xc]          ;480
000064  9a00              LDR      r2,[sp,#0]            ;481
000066  4008              ANDS     r0,r0,r1              ;480
000068  1c52              ADDS     r2,r2,#1              ;481
00006a  9200              STR      r2,[sp,#0]
00006c  42a2              CMP      r2,r4
00006e  d001              BEQ      |L1.116|
000070  2800              CMP      r0,#0
000072  d0f6              BEQ      |L1.98|
                  |L1.116|
;;;483        
;;;484        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
000074  68d8              LDR      r0,[r3,#0xc]
000076  0640              LSLS     r0,r0,#25
000078  d401              BMI      |L1.126|
;;;485        {
;;;486          status = SUCCESS;
;;;487        }
;;;488        else
;;;489        {
;;;490          status = ERROR;
00007a  2000              MOVS     r0,#0
;;;491        }
;;;492      }
;;;493      else
;;;494      {
;;;495        status = SUCCESS;
;;;496      }
;;;497    
;;;498      return (status);
;;;499    }
00007c  bd18              POP      {r3,r4,pc}
                  |L1.126|
00007e  2001              MOVS     r0,#1                 ;495
000080  bd18              POP      {r3,r4,pc}
;;;500    
                          ENDP

                  RTC_DeInit PROC
;;;308      */
;;;309    ErrorStatus RTC_DeInit(void)
000082  b578              PUSH     {r3-r6,lr}
;;;310    {
;;;311      __IO uint32_t wutcounter = 0x00;
000084  2500              MOVS     r5,#0
;;;312      ErrorStatus status = ERROR;
;;;313      
;;;314      /* Disable the write protection for RTC registers */
;;;315      RTC->WPR = 0xCA;
000086  4cd9              LDR      r4,|L1.1004|
000088  20ca              MOVS     r0,#0xca
00008a  9500              STR      r5,[sp,#0]
00008c  462e              MOV      r6,r5                 ;312
00008e  6260              STR      r0,[r4,#0x24]
;;;316      RTC->WPR = 0x53;
000090  2053              MOVS     r0,#0x53
000092  6260              STR      r0,[r4,#0x24]
;;;317    
;;;318      /* Set Initialization mode */
;;;319      if (RTC_EnterInitMode() == ERROR)
000094  f7fffffe          BL       RTC_EnterInitMode
000098  2800              CMP      r0,#0
00009a  d013              BEQ      |L1.196|
;;;320      {
;;;321        status = ERROR;
;;;322      }  
;;;323      else
;;;324      {
;;;325        /* Reset TR, DR and CR registers */
;;;326        RTC->TR        = (uint32_t)0x00000000;
00009c  6025              STR      r5,[r4,#0]
;;;327        RTC->DR        = (uint32_t)0x00002101;
00009e  48d4              LDR      r0,|L1.1008|
0000a0  6060              STR      r0,[r4,#4]
;;;328        RTC->CR        &= (uint32_t)0x00000000;
0000a2  68a0              LDR      r0,[r4,#8]
0000a4  60a5              STR      r5,[r4,#8]
;;;329        RTC->PRER      = (uint32_t)0x007F00FF;
0000a6  48d3              LDR      r0,|L1.1012|
0000a8  6120              STR      r0,[r4,#0x10]
;;;330        RTC->ALRMAR    = (uint32_t)0x00000000;
0000aa  61e5              STR      r5,[r4,#0x1c]
;;;331        RTC->SHIFTR    = (uint32_t)0x00000000;
0000ac  62e5              STR      r5,[r4,#0x2c]
;;;332        RTC->CAL       = (uint32_t)0x00000000;
0000ae  63e5              STR      r5,[r4,#0x3c]
;;;333        RTC->ALRMASSR  = (uint32_t)0x00000000;
0000b0  48ce              LDR      r0,|L1.1004|
0000b2  3040              ADDS     r0,r0,#0x40
0000b4  6045              STR      r5,[r0,#4]
;;;334    
;;;335        /* Reset ISR register and exit initialization mode */
;;;336        RTC->ISR = (uint32_t)0x00000000;
0000b6  60e5              STR      r5,[r4,#0xc]
;;;337        
;;;338        /* Reset Tamper and alternate functions configuration register */
;;;339        RTC->TAFCR = 0x00000000;
0000b8  6005              STR      r5,[r0,#0]
;;;340          
;;;341        /* Wait till the RTC RSF flag is set */
;;;342        if (RTC_WaitForSynchro() == ERROR)
0000ba  f7fffffe          BL       RTC_WaitForSynchro
0000be  2800              CMP      r0,#0
0000c0  d000              BEQ      |L1.196|
;;;343        {
;;;344          status = ERROR;
;;;345        }
;;;346        else
;;;347        {
;;;348          status = SUCCESS;
0000c2  2601              MOVS     r6,#1
                  |L1.196|
;;;349        }
;;;350    
;;;351      }
;;;352    
;;;353      /* Enable the write protection for RTC registers */
;;;354      RTC->WPR = 0xFF;  
0000c4  20ff              MOVS     r0,#0xff
0000c6  6260              STR      r0,[r4,#0x24]
;;;355    
;;;356      return status;
0000c8  4630              MOV      r0,r6
;;;357    }
0000ca  bd78              POP      {r3-r6,pc}
;;;358    
                          ENDP

                  RTC_ExitInitMode PROC
;;;509      */
;;;510    void RTC_ExitInitMode(void)
0000cc  48c7              LDR      r0,|L1.1004|
;;;511    {
;;;512      /* Exit Initialization mode */
;;;513      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
0000ce  68c1              LDR      r1,[r0,#0xc]
0000d0  2280              MOVS     r2,#0x80
0000d2  4391              BICS     r1,r1,r2
0000d4  60c1              STR      r1,[r0,#0xc]
;;;514    }
0000d6  4770              BX       lr
;;;515    
                          ENDP

                  RTC_Init PROC
;;;369      */
;;;370    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
0000d8  b570              PUSH     {r4-r6,lr}
;;;371    {
0000da  4605              MOV      r5,r0
;;;372      ErrorStatus status = ERROR;
0000dc  2600              MOVS     r6,#0
;;;373    
;;;374      /* Check the parameters */
;;;375      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
;;;376      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
;;;377      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
;;;378    
;;;379      /* Disable the write protection for RTC registers */
;;;380      RTC->WPR = 0xCA;
0000de  4cc3              LDR      r4,|L1.1004|
0000e0  20ca              MOVS     r0,#0xca
0000e2  6260              STR      r0,[r4,#0x24]
;;;381      RTC->WPR = 0x53;
0000e4  2053              MOVS     r0,#0x53
0000e6  6260              STR      r0,[r4,#0x24]
;;;382    
;;;383      /* Set Initialization mode */
;;;384      if (RTC_EnterInitMode() == ERROR)
0000e8  f7fffffe          BL       RTC_EnterInitMode
0000ec  2800              CMP      r0,#0
0000ee  d011              BEQ      |L1.276|
;;;385      {
;;;386        status = ERROR;
;;;387      }
;;;388      else
;;;389      {
;;;390        /* Clear RTC CR FMT Bit */
;;;391        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
0000f0  68a0              LDR      r0,[r4,#8]
0000f2  2140              MOVS     r1,#0x40
0000f4  4388              BICS     r0,r0,r1
0000f6  60a0              STR      r0,[r4,#8]
;;;392        /* Set RTC_CR register */
;;;393        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
0000f8  68a0              LDR      r0,[r4,#8]
0000fa  6829              LDR      r1,[r5,#0]
0000fc  4308              ORRS     r0,r0,r1
0000fe  60a0              STR      r0,[r4,#8]
;;;394      
;;;395        /* Configure the RTC PRER */
;;;396        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
000100  68a8              LDR      r0,[r5,#8]
000102  6120              STR      r0,[r4,#0x10]
;;;397        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
000104  6920              LDR      r0,[r4,#0x10]
000106  88a9              LDRH     r1,[r5,#4]
000108  0409              LSLS     r1,r1,#16
00010a  4308              ORRS     r0,r0,r1
00010c  6120              STR      r0,[r4,#0x10]
;;;398    
;;;399        /* Exit Initialization mode */
;;;400        RTC_ExitInitMode();
00010e  f7fffffe          BL       RTC_ExitInitMode
;;;401    
;;;402        status = SUCCESS;
000112  2601              MOVS     r6,#1
                  |L1.276|
;;;403      }
;;;404      /* Enable the write protection for RTC registers */
;;;405      RTC->WPR = 0xFF;
000114  20ff              MOVS     r0,#0xff
000116  6260              STR      r0,[r4,#0x24]
;;;406    
;;;407      return status;
000118  4630              MOV      r0,r6
;;;408    }
00011a  bd70              POP      {r4-r6,pc}
;;;409    
                          ENDP

                  RTC_StructInit PROC
;;;415      */
;;;416    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
00011c  2100              MOVS     r1,#0
;;;417    {
;;;418      /* Initialize the RTC_HourFormat member */
;;;419      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
;;;420    
;;;421      /* Initialize the RTC_AsynchPrediv member */
;;;422      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
00011e  6001              STR      r1,[r0,#0]
000120  217f              MOVS     r1,#0x7f
;;;423    
;;;424      /* Initialize the RTC_SynchPrediv member */
;;;425      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
000122  6041              STR      r1,[r0,#4]
000124  21ff              MOVS     r1,#0xff
000126  6081              STR      r1,[r0,#8]
;;;426    }
000128  4770              BX       lr
;;;427    
                          ENDP

                  RTC_WriteProtectionCmd PROC
;;;437      */
;;;438    void RTC_WriteProtectionCmd(FunctionalState NewState)
00012a  49b0              LDR      r1,|L1.1004|
;;;439    {
;;;440      /* Check the parameters */
;;;441      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;442    
;;;443      if (NewState != DISABLE)
00012c  2800              CMP      r0,#0
00012e  d001              BEQ      |L1.308|
;;;444      {
;;;445        /* Enable the write protection for RTC registers */
;;;446        RTC->WPR = 0xFF;
000130  20ff              MOVS     r0,#0xff
000132  e002              B        |L1.314|
                  |L1.308|
;;;447      }
;;;448      else
;;;449      {
;;;450        /* Disable the write protection for RTC registers */
;;;451        RTC->WPR = 0xCA;
000134  20ca              MOVS     r0,#0xca
000136  6248              STR      r0,[r1,#0x24]
;;;452        RTC->WPR = 0x53;
000138  2053              MOVS     r0,#0x53
                  |L1.314|
00013a  6248              STR      r0,[r1,#0x24]         ;446
;;;453      }
;;;454    }
00013c  4770              BX       lr
;;;455    
                          ENDP

                  RTC_RefClockCmd PROC
;;;582      */
;;;583    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
00013e  b570              PUSH     {r4-r6,lr}
;;;584    {
000140  4606              MOV      r6,r0
;;;585      ErrorStatus status = ERROR;
000142  2500              MOVS     r5,#0
;;;586    
;;;587      /* Check the parameters */
;;;588      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;589    
;;;590      /* Disable the write protection for RTC registers */
;;;591      RTC->WPR = 0xCA;
000144  4ca9              LDR      r4,|L1.1004|
000146  20ca              MOVS     r0,#0xca
000148  6260              STR      r0,[r4,#0x24]
;;;592      RTC->WPR = 0x53;
00014a  2053              MOVS     r0,#0x53
00014c  6260              STR      r0,[r4,#0x24]
;;;593    
;;;594      /* Set Initialization mode */
;;;595      if (RTC_EnterInitMode() == ERROR)
00014e  f7fffffe          BL       RTC_EnterInitMode
000152  2800              CMP      r0,#0
000154  d00a              BEQ      |L1.364|
;;;596      {
;;;597        status = ERROR;
;;;598      }
;;;599      else
;;;600      {
;;;601        if (NewState != DISABLE)
;;;602        {
;;;603          /* Enable the RTC reference clock detection */
;;;604          RTC->CR |= RTC_CR_REFCKON;
000156  2110              MOVS     r1,#0x10
;;;605        }
;;;606        else
;;;607        {
;;;608          /* Disable the RTC reference clock detection */
;;;609          RTC->CR &= ~RTC_CR_REFCKON;
000158  68a0              LDR      r0,[r4,#8]
00015a  2e00              CMP      r6,#0                 ;601
00015c  d001              BEQ      |L1.354|
00015e  4308              ORRS     r0,r0,r1              ;604
000160  e000              B        |L1.356|
                  |L1.354|
000162  4388              BICS     r0,r0,r1
                  |L1.356|
000164  60a0              STR      r0,[r4,#8]
;;;610        }
;;;611        /* Exit Initialization mode */
;;;612        RTC_ExitInitMode();
000166  f7fffffe          BL       RTC_ExitInitMode
;;;613    
;;;614        status = SUCCESS;
00016a  2501              MOVS     r5,#1
                  |L1.364|
;;;615      }
;;;616    
;;;617      /* Enable the write protection for RTC registers */
;;;618      RTC->WPR = 0xFF;
00016c  20ff              MOVS     r0,#0xff
00016e  6260              STR      r0,[r4,#0x24]
;;;619    
;;;620      return status;
000170  4628              MOV      r0,r5
;;;621    }
000172  bd70              POP      {r4-r6,pc}
;;;622    
                          ENDP

                  RTC_BypassShadowCmd PROC
;;;630    */
;;;631    void RTC_BypassShadowCmd(FunctionalState NewState)
000174  499d              LDR      r1,|L1.1004|
;;;632    {
;;;633      /* Check the parameters */
;;;634      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;635    
;;;636      /* Disable the write protection for RTC registers */
;;;637      RTC->WPR = 0xCA;
000176  22ca              MOVS     r2,#0xca
000178  624a              STR      r2,[r1,#0x24]
;;;638      RTC->WPR = 0x53;
00017a  2253              MOVS     r2,#0x53
00017c  624a              STR      r2,[r1,#0x24]
;;;639      
;;;640      if (NewState != DISABLE)
00017e  2800              CMP      r0,#0
;;;641      {
;;;642        /* Set the BYPSHAD bit */
;;;643        RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
;;;644      }
;;;645      else
;;;646      {
;;;647        /* Reset the BYPSHAD bit */
;;;648        RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
000180  6888              LDR      r0,[r1,#8]
000182  d002              BEQ      |L1.394|
000184  2220              MOVS     r2,#0x20              ;643
000186  4310              ORRS     r0,r0,r2              ;643
000188  e001              B        |L1.398|
                  |L1.394|
00018a  22df              MOVS     r2,#0xdf
00018c  4010              ANDS     r0,r0,r2
                  |L1.398|
00018e  6088              STR      r0,[r1,#8]
;;;649      }
;;;650    
;;;651      /* Enable the write protection for RTC registers */
;;;652      RTC->WPR = 0xFF;
000190  20ff              MOVS     r0,#0xff
000192  6248              STR      r0,[r1,#0x24]
;;;653    }
000194  4770              BX       lr
;;;654    
                          ENDP

                  RTC_SetTime PROC
;;;684      */
;;;685    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000196  b5f8              PUSH     {r3-r7,lr}
;;;686    {
000198  460c              MOV      r4,r1
;;;687      uint32_t tmpreg = 0;
;;;688      ErrorStatus status = ERROR;
00019a  2600              MOVS     r6,#0
;;;689    
;;;690      /* Check the parameters */
;;;691      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;692      
;;;693      if (RTC_Format == RTC_Format_BIN)
00019c  0001              MOVS     r1,r0
;;;694      {
;;;695        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00019e  4f93              LDR      r7,|L1.1004|
;;;696        {
;;;697          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;698          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
;;;699        }
;;;700        else
;;;701        {
;;;702          RTC_TimeStruct->RTC_H12 = 0x00;
;;;703          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
;;;704        }
;;;705        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;706        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
;;;707      }
;;;708      else
;;;709      {
;;;710        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;711        {
;;;712          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
0001a0  7820              LDRB     r0,[r4,#0]
0001a2  68b9              LDR      r1,[r7,#8]            ;710
0001a4  4632              MOV      r2,r6                 ;693
0001a6  d004              BEQ      |L1.434|
0001a8  0649              LSLS     r1,r1,#25             ;710
0001aa  d52d              BPL      |L1.520|
0001ac  f7fffffe          BL       RTC_Bcd2ToByte
;;;713          assert_param(IS_RTC_HOUR12(tmpreg));
;;;714          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
0001b0  e02b              B        |L1.522|
                  |L1.434|
0001b2  0649              LSLS     r1,r1,#25             ;695
0001b4  d400              BMI      |L1.440|
0001b6  70e2              STRB     r2,[r4,#3]            ;702
                  |L1.440|
;;;715        } 
;;;716        else
;;;717        {
;;;718          RTC_TimeStruct->RTC_H12 = 0x00;
;;;719          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
;;;720        }
;;;721        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;722        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
;;;723      }
;;;724      
;;;725      /* Check the input parameters format */
;;;726      if (RTC_Format != RTC_Format_BIN)
;;;727      {
;;;728        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
;;;729                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;730                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;731                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;732      }
;;;733      else
;;;734      {
;;;735        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
0001b8  f7fffffe          BL       RTC_ByteToBcd2
0001bc  0405              LSLS     r5,r0,#16
0001be  7860              LDRB     r0,[r4,#1]
0001c0  f7fffffe          BL       RTC_ByteToBcd2
0001c4  0200              LSLS     r0,r0,#8
0001c6  4305              ORRS     r5,r5,r0
0001c8  78a0              LDRB     r0,[r4,#2]
0001ca  f7fffffe          BL       RTC_ByteToBcd2
0001ce  4305              ORRS     r5,r5,r0
0001d0  78e0              LDRB     r0,[r4,#3]
0001d2  0400              LSLS     r0,r0,#16
                  |L1.468|
0001d4  4305              ORRS     r5,r5,r0
;;;736                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;737                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;738                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;739      } 
;;;740    
;;;741      /* Disable the write protection for RTC registers */
;;;742      RTC->WPR = 0xCA;
0001d6  20ca              MOVS     r0,#0xca
0001d8  6278              STR      r0,[r7,#0x24]
;;;743      RTC->WPR = 0x53;
0001da  2053              MOVS     r0,#0x53
0001dc  6278              STR      r0,[r7,#0x24]
;;;744    
;;;745      /* Set Initialization mode */
;;;746      if (RTC_EnterInitMode() == ERROR)
0001de  f7fffffe          BL       RTC_EnterInitMode
0001e2  2800              CMP      r0,#0
0001e4  d00c              BEQ      |L1.512|
;;;747      {
;;;748        status = ERROR;
;;;749      } 
;;;750      else
;;;751      {
;;;752        /* Set the RTC_TR register */
;;;753        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
0001e6  4884              LDR      r0,|L1.1016|
0001e8  4005              ANDS     r5,r5,r0
0001ea  603d              STR      r5,[r7,#0]
;;;754    
;;;755        /* Exit Initialization mode */
;;;756        RTC_ExitInitMode(); 
0001ec  f7fffffe          BL       RTC_ExitInitMode
;;;757    
;;;758        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;759        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
0001f0  68b8              LDR      r0,[r7,#8]
0001f2  0680              LSLS     r0,r0,#26
0001f4  d403              BMI      |L1.510|
;;;760        {
;;;761          if (RTC_WaitForSynchro() == ERROR)
0001f6  f7fffffe          BL       RTC_WaitForSynchro
0001fa  2800              CMP      r0,#0
0001fc  d000              BEQ      |L1.512|
                  |L1.510|
;;;762          {
;;;763            status = ERROR;
;;;764          }
;;;765          else
;;;766          {
;;;767            status = SUCCESS;
;;;768          }
;;;769        }
;;;770        else
;;;771        {
;;;772          status = SUCCESS;
0001fe  2601              MOVS     r6,#1
                  |L1.512|
;;;773        }
;;;774      
;;;775      }
;;;776      /* Enable the write protection for RTC registers */
;;;777      RTC->WPR = 0xFF;
000200  20ff              MOVS     r0,#0xff
000202  6278              STR      r0,[r7,#0x24]
;;;778        
;;;779      return status;
000204  4630              MOV      r0,r6
;;;780    }
000206  bdf8              POP      {r3-r7,pc}
                  |L1.520|
000208  70e2              STRB     r2,[r4,#3]            ;718
                  |L1.522|
00020a  7820              LDRB     r0,[r4,#0]            ;728
00020c  78a5              LDRB     r5,[r4,#2]            ;728
00020e  0400              LSLS     r0,r0,#16             ;728
000210  4305              ORRS     r5,r5,r0              ;728
000212  7860              LDRB     r0,[r4,#1]            ;728
000214  78e1              LDRB     r1,[r4,#3]            ;728
000216  0200              LSLS     r0,r0,#8              ;728
000218  0409              LSLS     r1,r1,#16             ;728
00021a  4308              ORRS     r0,r0,r1              ;728
00021c  e7da              B        |L1.468|
;;;781    
                          ENDP

                  RTC_TimeStructInit PROC
;;;788      */
;;;789    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
00021e  2100              MOVS     r1,#0
;;;790    {
;;;791      /* Time = 00h:00min:00sec */
;;;792      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
000220  70c1              STRB     r1,[r0,#3]
;;;793      RTC_TimeStruct->RTC_Hours = 0;
000222  7001              STRB     r1,[r0,#0]
;;;794      RTC_TimeStruct->RTC_Minutes = 0;
000224  7041              STRB     r1,[r0,#1]
;;;795      RTC_TimeStruct->RTC_Seconds = 0; 
000226  7081              STRB     r1,[r0,#2]
;;;796    }
000228  4770              BX       lr
;;;797    
                          ENDP

                  RTC_GetTime PROC
;;;807      */
;;;808    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
00022a  b570              PUSH     {r4-r6,lr}
;;;809    {
00022c  4603              MOV      r3,r0
;;;810      uint32_t tmpreg = 0;
;;;811    
;;;812      /* Check the parameters */
;;;813      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;814    
;;;815      /* Get the RTC_TR register */
;;;816      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
00022e  486f              LDR      r0,|L1.1004|
000230  460c              MOV      r4,r1                 ;809
000232  6802              LDR      r2,[r0,#0]
000234  4870              LDR      r0,|L1.1016|
000236  4611              MOV      r1,r2
000238  4001              ANDS     r1,r1,r0
;;;817      
;;;818      /* Fill the structure fields with the read parameters */
;;;819      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00023a  0288              LSLS     r0,r1,#10
;;;820      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
00023c  044d              LSLS     r5,r1,#17
00023e  0e80              LSRS     r0,r0,#26             ;819
000240  7020              STRB     r0,[r4,#0]            ;819
000242  0e6d              LSRS     r5,r5,#25
;;;821      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
000244  0649              LSLS     r1,r1,#25
000246  7065              STRB     r5,[r4,#1]            ;820
000248  0e49              LSRS     r1,r1,#25
00024a  70a1              STRB     r1,[r4,#2]
;;;822      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
;;;823    
;;;824      /* Check the input parameters format */
;;;825      if (RTC_Format == RTC_Format_BIN)
;;;826      {
;;;827        /* Convert the structure parameters to Binary format */
;;;828        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
;;;829        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
;;;830        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);
;;;831      }
;;;832    }
00024c  0251              LSLS     r1,r2,#9
00024e  0e49              LSRS     r1,r1,#25
000250  2240              MOVS     r2,#0x40              ;822
000252  4011              ANDS     r1,r1,r2              ;822
000254  70e1              STRB     r1,[r4,#3]            ;822
000256  2b00              CMP      r3,#0                 ;825
000258  d10a              BNE      |L1.624|
00025a  f7fffffe          BL       RTC_Bcd2ToByte
00025e  7020              STRB     r0,[r4,#0]            ;828
000260  7860              LDRB     r0,[r4,#1]            ;829
000262  f7fffffe          BL       RTC_Bcd2ToByte
000266  7060              STRB     r0,[r4,#1]            ;829
000268  78a0              LDRB     r0,[r4,#2]            ;830
00026a  f7fffffe          BL       RTC_Bcd2ToByte
00026e  70a0              STRB     r0,[r4,#2]            ;830
                  |L1.624|
000270  bd70              POP      {r4-r6,pc}
;;;833    
                          ENDP

                  RTC_GetSubSecond PROC
;;;840      */
;;;841    uint32_t RTC_GetSubSecond(void)
000272  495e              LDR      r1,|L1.1004|
;;;842    {
;;;843      uint32_t tmpreg = 0;
;;;844      
;;;845      /* Get subseconds values from the correspondent registers*/
;;;846      tmpreg = (uint32_t)(RTC->SSR);
000274  6a88              LDR      r0,[r1,#0x28]
;;;847      
;;;848      /* Read DR register to unfroze calendar registers */
;;;849      (void) (RTC->DR);
000276  6849              LDR      r1,[r1,#4]
;;;850      
;;;851      return (tmpreg);
;;;852    }
000278  4770              BX       lr
;;;853    
                          ENDP

                  RTC_SetDate PROC
;;;865      */
;;;866    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
00027a  b570              PUSH     {r4-r6,lr}
;;;867    {
00027c  460c              MOV      r4,r1
;;;868      uint32_t tmpreg = 0;
;;;869      ErrorStatus status = ERROR;
00027e  2600              MOVS     r6,#0
;;;870      
;;;871      /* Check the parameters */
;;;872      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;873    
;;;874      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
000280  0001              MOVS     r1,r0
000282  7860              LDRB     r0,[r4,#1]
000284  d00e              BEQ      |L1.676|
;;;875      {
;;;876        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
;;;877      }  
;;;878      if (RTC_Format == RTC_Format_BIN)
;;;879      {
;;;880        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;881        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;882        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
;;;883      }
;;;884      else
;;;885      {
;;;886        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;887        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
000286  f7fffffe          BL       RTC_Bcd2ToByte
;;;888        assert_param(IS_RTC_MONTH(tmpreg));
;;;889        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
00028a  78a0              LDRB     r0,[r4,#2]
00028c  f7fffffe          BL       RTC_Bcd2ToByte
;;;890        assert_param(IS_RTC_DATE(tmpreg));
;;;891      }
;;;892      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;893    
;;;894      /* Check the input parameters format */
;;;895      if (RTC_Format != RTC_Format_BIN)
;;;896      {
;;;897        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
000290  78e0              LDRB     r0,[r4,#3]
000292  78a5              LDRB     r5,[r4,#2]
000294  0400              LSLS     r0,r0,#16
000296  4305              ORRS     r5,r5,r0
000298  7860              LDRB     r0,[r4,#1]
00029a  7821              LDRB     r1,[r4,#0]
00029c  0200              LSLS     r0,r0,#8
00029e  0349              LSLS     r1,r1,#13
0002a0  4308              ORRS     r0,r0,r1
0002a2  e014              B        |L1.718|
                  |L1.676|
0002a4  06c1              LSLS     r1,r0,#27             ;874
0002a6  d503              BPL      |L1.688|
0002a8  21ef              MOVS     r1,#0xef              ;876
0002aa  4008              ANDS     r0,r0,r1              ;876
0002ac  300a              ADDS     r0,r0,#0xa            ;876
0002ae  7060              STRB     r0,[r4,#1]            ;876
                  |L1.688|
;;;898                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;899                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;900                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;901      }  
;;;902      else
;;;903      {
;;;904        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
0002b0  78e0              LDRB     r0,[r4,#3]
0002b2  f7fffffe          BL       RTC_ByteToBcd2
0002b6  0405              LSLS     r5,r0,#16
0002b8  7860              LDRB     r0,[r4,#1]
0002ba  f7fffffe          BL       RTC_ByteToBcd2
0002be  0200              LSLS     r0,r0,#8
0002c0  4305              ORRS     r5,r5,r0
0002c2  78a0              LDRB     r0,[r4,#2]
0002c4  f7fffffe          BL       RTC_ByteToBcd2
0002c8  4305              ORRS     r5,r5,r0
0002ca  7820              LDRB     r0,[r4,#0]
0002cc  0340              LSLS     r0,r0,#13
                  |L1.718|
0002ce  4305              ORRS     r5,r5,r0              ;897
;;;905                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;906                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;907                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;908      }
;;;909    
;;;910      /* Disable the write protection for RTC registers */
;;;911      RTC->WPR = 0xCA;
0002d0  4c46              LDR      r4,|L1.1004|
0002d2  20ca              MOVS     r0,#0xca
0002d4  6260              STR      r0,[r4,#0x24]
;;;912      RTC->WPR = 0x53;
0002d6  2053              MOVS     r0,#0x53
0002d8  6260              STR      r0,[r4,#0x24]
;;;913    
;;;914      /* Set Initialization mode */
;;;915      if (RTC_EnterInitMode() == ERROR)
0002da  f7fffffe          BL       RTC_EnterInitMode
0002de  2800              CMP      r0,#0
0002e0  d00c              BEQ      |L1.764|
;;;916      {
;;;917        status = ERROR;
;;;918      } 
;;;919      else
;;;920      {
;;;921        /* Set the RTC_DR register */
;;;922        RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
0002e2  4846              LDR      r0,|L1.1020|
0002e4  4005              ANDS     r5,r5,r0
0002e6  6065              STR      r5,[r4,#4]
;;;923    
;;;924        /* Exit Initialization mode */
;;;925        RTC_ExitInitMode(); 
0002e8  f7fffffe          BL       RTC_ExitInitMode
;;;926    
;;;927        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;928        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
0002ec  68a0              LDR      r0,[r4,#8]
0002ee  0680              LSLS     r0,r0,#26
0002f0  d403              BMI      |L1.762|
;;;929        {
;;;930          if (RTC_WaitForSynchro() == ERROR)
0002f2  f7fffffe          BL       RTC_WaitForSynchro
0002f6  2800              CMP      r0,#0
0002f8  d000              BEQ      |L1.764|
                  |L1.762|
;;;931          {
;;;932            status = ERROR;
;;;933          }
;;;934          else
;;;935          {
;;;936            status = SUCCESS;
;;;937          }
;;;938        }
;;;939        else
;;;940        {
;;;941          status = SUCCESS;
0002fa  2601              MOVS     r6,#1
                  |L1.764|
;;;942        }
;;;943      }
;;;944      /* Enable the write protection for RTC registers */
;;;945      RTC->WPR = 0xFF;
0002fc  20ff              MOVS     r0,#0xff
0002fe  6260              STR      r0,[r4,#0x24]
;;;946      
;;;947      return status;
000300  4630              MOV      r0,r6
;;;948    }
000302  bd70              POP      {r4-r6,pc}
;;;949    
                          ENDP

                  RTC_DateStructInit PROC
;;;956      */
;;;957    void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
000304  2101              MOVS     r1,#1
;;;958    {
;;;959      /* Monday, January 01 xx00 */
;;;960      RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000306  7001              STRB     r1,[r0,#0]
;;;961      RTC_DateStruct->RTC_Date = 1;
000308  7081              STRB     r1,[r0,#2]
;;;962      RTC_DateStruct->RTC_Month = RTC_Month_January;
00030a  7041              STRB     r1,[r0,#1]
;;;963      RTC_DateStruct->RTC_Year = 0;
00030c  2100              MOVS     r1,#0
00030e  70c1              STRB     r1,[r0,#3]
;;;964    }
000310  4770              BX       lr
;;;965    
                          ENDP

                  RTC_GetDate PROC
;;;975      */
;;;976    void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000312  4602              MOV      r2,r0
;;;977    {
000314  b510              PUSH     {r4,lr}
;;;978      uint32_t tmpreg = 0;
;;;979    
;;;980      /* Check the parameters */
;;;981      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;982      
;;;983      /* Get the RTC_TR register */
;;;984      tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
000316  4835              LDR      r0,|L1.1004|
000318  460c              MOV      r4,r1                 ;977
00031a  6840              LDR      r0,[r0,#4]
00031c  21c0              MOVS     r1,#0xc0
00031e  43c9              MVNS     r1,r1
000320  4001              ANDS     r1,r1,r0
;;;985    
;;;986      /* Fill the structure fields with the read parameters */
;;;987      RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
;;;988      RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
;;;989      RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
;;;990      RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
;;;991    
;;;992      /* Check the input parameters format */
;;;993      if (RTC_Format == RTC_Format_BIN)
;;;994      {
;;;995        /* Convert the structure parameters to Binary format */
;;;996        RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
;;;997        RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
;;;998        RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
;;;999        RTC_DateStruct->RTC_WeekDay = (uint8_t)(RTC_DateStruct->RTC_WeekDay);   
;;;1000     }
;;;1001   }
000322  0200              LSLS     r0,r0,#8
000324  0e00              LSRS     r0,r0,#24
000326  04cb              LSLS     r3,r1,#19             ;988
000328  70e0              STRB     r0,[r4,#3]            ;987
00032a  0edb              LSRS     r3,r3,#27             ;988
00032c  7063              STRB     r3,[r4,#1]            ;988
00032e  068b              LSLS     r3,r1,#26             ;989
000330  0e9b              LSRS     r3,r3,#26             ;989
000332  0409              LSLS     r1,r1,#16             ;990
000334  0f49              LSRS     r1,r1,#29             ;990
000336  70a3              STRB     r3,[r4,#2]            ;989
000338  7021              STRB     r1,[r4,#0]            ;990
00033a  2a00              CMP      r2,#0                 ;993
00033c  d10a              BNE      |L1.852|
00033e  f7fffffe          BL       RTC_Bcd2ToByte
000342  70e0              STRB     r0,[r4,#3]            ;996
000344  7860              LDRB     r0,[r4,#1]            ;997
000346  f7fffffe          BL       RTC_Bcd2ToByte
00034a  7060              STRB     r0,[r4,#1]            ;997
00034c  78a0              LDRB     r0,[r4,#2]            ;998
00034e  f7fffffe          BL       RTC_Bcd2ToByte
000352  70a0              STRB     r0,[r4,#2]            ;998
                  |L1.852|
000354  bd10              POP      {r4,pc}
;;;1002   
                          ENDP

                  RTC_SetAlarm PROC
;;;1035     */
;;;1036   void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000356  b570              PUSH     {r4-r6,lr}
;;;1037   {
000358  2100              MOVS     r1,#0
;;;1038     uint32_t tmpreg = 0;
;;;1039     
;;;1040     /* Check the parameters */
;;;1041     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1042     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1043     assert_param(IS_RTC_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
;;;1044     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
;;;1045   
;;;1046     if (RTC_Format == RTC_Format_BIN)
;;;1047     {
;;;1048       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00035a  4e24              LDR      r6,|L1.1004|
00035c  2800              CMP      r0,#0                 ;1046
;;;1049       {
;;;1050         assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1051         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
;;;1052       } 
;;;1053       else
;;;1054       {
;;;1055         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1056         assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1057       }
;;;1058       assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;1059       assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;1060       
;;;1061       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1062       {
;;;1063         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1064       }
;;;1065       else
;;;1066       {
;;;1067         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1068       }
;;;1069     }
;;;1070     else
;;;1071     {
;;;1072       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00035e  68b0              LDR      r0,[r6,#8]
000360  4614              MOV      r4,r2                 ;1037
000362  d005              BEQ      |L1.880|
000364  0640              LSLS     r0,r0,#25
000366  d51a              BPL      |L1.926|
;;;1073       {
;;;1074         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
000368  7820              LDRB     r0,[r4,#0]
00036a  f7fffffe          BL       RTC_Bcd2ToByte
;;;1075         assert_param(IS_RTC_HOUR12(tmpreg));
;;;1076         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
00036e  e017              B        |L1.928|
                  |L1.880|
000370  0640              LSLS     r0,r0,#25             ;1048
000372  d400              BMI      |L1.886|
000374  70e1              STRB     r1,[r4,#3]            ;1055
                  |L1.886|
;;;1077       } 
;;;1078       else
;;;1079       {
;;;1080         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1081         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
;;;1082       }
;;;1083       
;;;1084       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
;;;1085       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
;;;1086       
;;;1087       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1088       {
;;;1089         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1090         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
;;;1091       }
;;;1092       else
;;;1093       {
;;;1094         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1095         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
;;;1096       }    
;;;1097     }
;;;1098   
;;;1099     /* Check the input parameters format */
;;;1100     if (RTC_Format != RTC_Format_BIN)
;;;1101     {
;;;1102       tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
;;;1103                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1104                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;1105                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1106                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1107                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1108                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1109     }  
;;;1110     else
;;;1111     {
;;;1112       tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
000376  7820              LDRB     r0,[r4,#0]
000378  f7fffffe          BL       RTC_ByteToBcd2
00037c  0405              LSLS     r5,r0,#16
00037e  7860              LDRB     r0,[r4,#1]
000380  f7fffffe          BL       RTC_ByteToBcd2
000384  0200              LSLS     r0,r0,#8
000386  4305              ORRS     r5,r5,r0
000388  78a0              LDRB     r0,[r4,#2]
00038a  f7fffffe          BL       RTC_ByteToBcd2
00038e  4305              ORRS     r5,r5,r0
000390  78e0              LDRB     r0,[r4,#3]
000392  0400              LSLS     r0,r0,#16
000394  4305              ORRS     r5,r5,r0
000396  7b20              LDRB     r0,[r4,#0xc]
000398  f7fffffe          BL       RTC_ByteToBcd2
00039c  e00e              B        |L1.956|
                  |L1.926|
00039e  70e1              STRB     r1,[r4,#3]            ;1080
                  |L1.928|
0003a0  7b20              LDRB     r0,[r4,#0xc]          ;1089
0003a2  f7fffffe          BL       RTC_Bcd2ToByte
0003a6  7820              LDRB     r0,[r4,#0]            ;1102
0003a8  78a5              LDRB     r5,[r4,#2]            ;1102
0003aa  0400              LSLS     r0,r0,#16             ;1102
0003ac  4305              ORRS     r5,r5,r0              ;1102
0003ae  7860              LDRB     r0,[r4,#1]            ;1102
0003b0  78e1              LDRB     r1,[r4,#3]            ;1102
0003b2  0200              LSLS     r0,r0,#8              ;1102
0003b4  0409              LSLS     r1,r1,#16             ;1102
0003b6  4308              ORRS     r0,r0,r1              ;1102
0003b8  4305              ORRS     r5,r5,r0              ;1102
0003ba  7b20              LDRB     r0,[r4,#0xc]          ;1102
                  |L1.956|
0003bc  0600              LSLS     r0,r0,#24
0003be  4305              ORRS     r5,r5,r0
0003c0  68a0              LDR      r0,[r4,#8]
0003c2  4305              ORRS     r5,r5,r0
0003c4  6860              LDR      r0,[r4,#4]
0003c6  4305              ORRS     r5,r5,r0
;;;1113                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1114                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;1115                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1116                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1117                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1118                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1119     }
;;;1120   
;;;1121     /* Disable the write protection for RTC registers */
;;;1122     RTC->WPR = 0xCA;
0003c8  20ca              MOVS     r0,#0xca
0003ca  6270              STR      r0,[r6,#0x24]
;;;1123     RTC->WPR = 0x53;
0003cc  2053              MOVS     r0,#0x53
0003ce  6270              STR      r0,[r6,#0x24]
;;;1124   
;;;1125     /* Configure the Alarm register */
;;;1126     RTC->ALRMAR = (uint32_t)tmpreg;
0003d0  61f5              STR      r5,[r6,#0x1c]
;;;1127   
;;;1128     /* Enable the write protection for RTC registers */
;;;1129     RTC->WPR = 0xFF;
0003d2  20ff              MOVS     r0,#0xff
0003d4  6270              STR      r0,[r6,#0x24]
;;;1130   }
0003d6  bd70              POP      {r4-r6,pc}
;;;1131   
                          ENDP

                  RTC_AlarmStructInit PROC
;;;1139     */
;;;1140   void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
0003d8  2100              MOVS     r1,#0
;;;1141   {
;;;1142     /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;1143     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
0003da  70c1              STRB     r1,[r0,#3]
;;;1144     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
0003dc  7001              STRB     r1,[r0,#0]
;;;1145     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
0003de  7041              STRB     r1,[r0,#1]
;;;1146     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
0003e0  7081              STRB     r1,[r0,#2]
;;;1147   
;;;1148     /* Alarm Date Settings : Date = 1st day of the month */
;;;1149     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
;;;1150     RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
0003e2  2201              MOVS     r2,#1
0003e4  6081              STR      r1,[r0,#8]
0003e6  7302              STRB     r2,[r0,#0xc]
;;;1151   
;;;1152     /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;1153     RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
0003e8  6041              STR      r1,[r0,#4]
                  |L1.1002|
;;;1154   }
0003ea  4770              BX       lr
                  |L1.1004|
                          DCD      0x40002800
                  |L1.1008|
                          DCD      0x00002101
                  |L1.1012|
                          DCD      0x007f00ff
                  |L1.1016|
                          DCD      0x007f7f7f
                  |L1.1020|
                          DCD      0x00ffff3f
                          ENDP

                  RTC_GetAlarm PROC
;;;1168     */
;;;1169   void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000400  b570              PUSH     {r4-r6,lr}
;;;1170   {
000402  4614              MOV      r4,r2
000404  4602              MOV      r2,r0
;;;1171     uint32_t tmpreg = 0;
;;;1172   
;;;1173     /* Check the parameters */
;;;1174     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1175     assert_param(IS_RTC_ALARM(RTC_Alarm)); 
;;;1176   
;;;1177     /* Get the RTC_ALRMAR register */
;;;1178     tmpreg = (uint32_t)(RTC->ALRMAR);
000406  48fb              LDR      r0,|L1.2036|
000408  69c1              LDR      r1,[r0,#0x1c]
;;;1179   
;;;1180     /* Fill the structure with the read parameters */
;;;1181     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
;;;1182                                                        RTC_ALRMAR_HU)) >> 16);
;;;1183     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
;;;1184                                                        RTC_ALRMAR_MNU)) >> 8);
;;;1185     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
;;;1186                                                        RTC_ALRMAR_SU));
;;;1187     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
00040a  2540              MOVS     r5,#0x40
00040c  0288              LSLS     r0,r1,#10             ;1181
00040e  0e80              LSRS     r0,r0,#26             ;1181
000410  044b              LSLS     r3,r1,#17             ;1183
000412  7020              STRB     r0,[r4,#0]            ;1181
000414  0e5b              LSRS     r3,r3,#25             ;1183
000416  7063              STRB     r3,[r4,#1]            ;1183
000418  064b              LSLS     r3,r1,#25             ;1185
00041a  0e5b              LSRS     r3,r3,#25             ;1185
00041c  70a3              STRB     r3,[r4,#2]            ;1185
00041e  0c0b              LSRS     r3,r1,#16
000420  402b              ANDS     r3,r3,r5
000422  70e3              STRB     r3,[r4,#3]
;;;1188     RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
000424  008b              LSLS     r3,r1,#2
000426  0e9b              LSRS     r3,r3,#26
000428  7323              STRB     r3,[r4,#0xc]
;;;1189     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
00042a  062b              LSLS     r3,r5,#24
00042c  400b              ANDS     r3,r3,r1
;;;1190     RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
00042e  60a3              STR      r3,[r4,#8]
000430  4bf1              LDR      r3,|L1.2040|
000432  4019              ANDS     r1,r1,r3
;;;1191   
;;;1192     if (RTC_Format == RTC_Format_BIN)
000434  6061              STR      r1,[r4,#4]
000436  2a00              CMP      r2,#0
000438  d10e              BNE      |L1.1112|
;;;1193     {
;;;1194       RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
00043a  f7fffffe          BL       RTC_Bcd2ToByte
00043e  7020              STRB     r0,[r4,#0]
;;;1195                                                           RTC_AlarmTime.RTC_Hours);
;;;1196       RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000440  7860              LDRB     r0,[r4,#1]
000442  f7fffffe          BL       RTC_Bcd2ToByte
000446  7060              STRB     r0,[r4,#1]
;;;1197                                                           RTC_AlarmTime.RTC_Minutes);
;;;1198       RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000448  78a0              LDRB     r0,[r4,#2]
00044a  f7fffffe          BL       RTC_Bcd2ToByte
00044e  70a0              STRB     r0,[r4,#2]
;;;1199                                                           RTC_AlarmTime.RTC_Seconds);
;;;1200       RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000450  7b20              LDRB     r0,[r4,#0xc]
000452  f7fffffe          BL       RTC_Bcd2ToByte
000456  7320              STRB     r0,[r4,#0xc]
                  |L1.1112|
;;;1201     }  
;;;1202   }
000458  bd70              POP      {r4-r6,pc}
;;;1203   
                          ENDP

                  RTC_AlarmCmd PROC
;;;1214     */
;;;1215   ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
00045a  b518              PUSH     {r3,r4,lr}
;;;1216   {
;;;1217     __IO uint32_t alarmcounter = 0x00;
00045c  2200              MOVS     r2,#0
;;;1218     uint32_t alarmstatus = 0x00;
;;;1219     ErrorStatus status = ERROR;
;;;1220       
;;;1221     /* Check the parameters */
;;;1222     assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
;;;1223     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1224   
;;;1225     /* Disable the write protection for RTC registers */
;;;1226     RTC->WPR = 0xCA;
00045e  9200              STR      r2,[sp,#0]
000460  4be4              LDR      r3,|L1.2036|
000462  22ca              MOVS     r2,#0xca
000464  625a              STR      r2,[r3,#0x24]
;;;1227     RTC->WPR = 0x53;
000466  2253              MOVS     r2,#0x53
000468  625a              STR      r2,[r3,#0x24]
;;;1228   
;;;1229     /* Configure the Alarm state */
;;;1230     if (NewState != DISABLE)
00046a  2900              CMP      r1,#0
;;;1231     {
;;;1232       RTC->CR |= (uint32_t)RTC_Alarm;
;;;1233   
;;;1234       status = SUCCESS;    
;;;1235     }
;;;1236     else
;;;1237     { 
;;;1238       /* Disable the Alarm in RTC_CR register */
;;;1239       RTC->CR &= (uint32_t)~RTC_Alarm;
00046c  6899              LDR      r1,[r3,#8]
00046e  d002              BEQ      |L1.1142|
000470  4301              ORRS     r1,r1,r0              ;1232
000472  6099              STR      r1,[r3,#8]            ;1232
000474  e010              B        |L1.1176|
                  |L1.1142|
000476  4381              BICS     r1,r1,r0
000478  6099              STR      r1,[r3,#8]
;;;1240      
;;;1241       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1242       do
;;;1243       {
;;;1244         alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
00047a  0a00              LSRS     r0,r0,#8
;;;1245         alarmcounter++;  
;;;1246       } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
00047c  2401              MOVS     r4,#1
00047e  03a4              LSLS     r4,r4,#14
                  |L1.1152|
000480  68d9              LDR      r1,[r3,#0xc]          ;1244
000482  9a00              LDR      r2,[sp,#0]            ;1245
000484  4001              ANDS     r1,r1,r0              ;1244
000486  1c52              ADDS     r2,r2,#1              ;1245
000488  9200              STR      r2,[sp,#0]
00048a  42a2              CMP      r2,r4
00048c  d001              BEQ      |L1.1170|
00048e  2900              CMP      r1,#0
000490  d0f6              BEQ      |L1.1152|
                  |L1.1170|
;;;1247       
;;;1248       if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
000492  68d9              LDR      r1,[r3,#0xc]
000494  4201              TST      r1,r0
000496  d003              BEQ      |L1.1184|
                  |L1.1176|
;;;1249       {
;;;1250         status = ERROR;
;;;1251       } 
;;;1252       else
;;;1253       {
;;;1254         status = SUCCESS;
000498  2001              MOVS     r0,#1
                  |L1.1178|
;;;1255       }        
;;;1256     } 
;;;1257   
;;;1258     /* Enable the write protection for RTC registers */
;;;1259     RTC->WPR = 0xFF;
00049a  21ff              MOVS     r1,#0xff
00049c  6259              STR      r1,[r3,#0x24]
;;;1260     
;;;1261     return status;
;;;1262   }
00049e  bd18              POP      {r3,r4,pc}
                  |L1.1184|
0004a0  2000              MOVS     r0,#0                 ;1250
0004a2  e7fa              B        |L1.1178|
;;;1263   
                          ENDP

                  RTC_AlarmSubSecondConfig PROC
;;;1307     */
;;;1308   void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint8_t RTC_AlarmSubSecondMask)
0004a4  48d3              LDR      r0,|L1.2036|
;;;1309   {
;;;1310     uint32_t tmpreg = 0;
;;;1311   
;;;1312     /* Check the parameters */
;;;1313     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1314     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
;;;1315     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
;;;1316     
;;;1317     /* Disable the write protection for RTC registers */
;;;1318     RTC->WPR = 0xCA;
0004a6  23ca              MOVS     r3,#0xca
0004a8  6243              STR      r3,[r0,#0x24]
;;;1319     RTC->WPR = 0x53;
0004aa  2353              MOVS     r3,#0x53
0004ac  6243              STR      r3,[r0,#0x24]
;;;1320     
;;;1321     /* Configure the Alarm A or Alarm B SubSecond registers */
;;;1322     tmpreg = (uint32_t) (((uint32_t)(RTC_AlarmSubSecondValue)) | ((uint32_t)(RTC_AlarmSubSecondMask) << 24));
0004ae  0612              LSLS     r2,r2,#24
0004b0  430a              ORRS     r2,r2,r1
;;;1323     
;;;1324     /* Configure the AlarmA SubSecond register */
;;;1325     RTC->ALRMASSR = tmpreg;
0004b2  49d0              LDR      r1,|L1.2036|
0004b4  3140              ADDS     r1,r1,#0x40
0004b6  604a              STR      r2,[r1,#4]
;;;1326   
;;;1327     /* Enable the write protection for RTC registers */
;;;1328     RTC->WPR = 0xFF;
0004b8  21ff              MOVS     r1,#0xff
0004ba  6241              STR      r1,[r0,#0x24]
;;;1329   
;;;1330   }
0004bc  e795              B        |L1.1002|
;;;1331   
                          ENDP

                  RTC_GetAlarmSubSecond PROC
;;;1339     */
;;;1340   uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
0004be  48cd              LDR      r0,|L1.2036|
;;;1341   {
;;;1342     uint32_t tmpreg = 0;
;;;1343     
;;;1344     /* Get the RTC_ALRMAR register */
;;;1345     tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
0004c0  3040              ADDS     r0,r0,#0x40
0004c2  6840              LDR      r0,[r0,#4]
0004c4  0440              LSLS     r0,r0,#17
0004c6  0c40              LSRS     r0,r0,#17
;;;1346   
;;;1347     return (tmpreg);
;;;1348   }
0004c8  e78f              B        |L1.1002|
;;;1349   
                          ENDP

                  RTC_DayLightSavingConfig PROC
;;;1381     */
;;;1382   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
0004ca  b510              PUSH     {r4,lr}
;;;1383   {
;;;1384     /* Check the parameters */
;;;1385     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
;;;1386     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
;;;1387   
;;;1388     /* Disable the write protection for RTC registers */
;;;1389     RTC->WPR = 0xCA;
0004cc  4ac9              LDR      r2,|L1.2036|
0004ce  23ca              MOVS     r3,#0xca
0004d0  6253              STR      r3,[r2,#0x24]
;;;1390     RTC->WPR = 0x53;
0004d2  2353              MOVS     r3,#0x53
0004d4  6253              STR      r3,[r2,#0x24]
;;;1391   
;;;1392     /* Clear the bits to be configured */
;;;1393     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
0004d6  6893              LDR      r3,[r2,#8]
0004d8  2401              MOVS     r4,#1
0004da  04a4              LSLS     r4,r4,#18
0004dc  43a3              BICS     r3,r3,r4
0004de  6093              STR      r3,[r2,#8]
;;;1394   
;;;1395     /* Configure the RTC_CR register */
;;;1396     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
0004e0  6893              LDR      r3,[r2,#8]
0004e2  4308              ORRS     r0,r0,r1
0004e4  4303              ORRS     r3,r3,r0
0004e6  6093              STR      r3,[r2,#8]
;;;1397   
;;;1398     /* Enable the write protection for RTC registers */
;;;1399     RTC->WPR = 0xFF;
0004e8  20ff              MOVS     r0,#0xff
0004ea  6250              STR      r0,[r2,#0x24]
;;;1400   }
0004ec  bd10              POP      {r4,pc}
;;;1401   
                          ENDP

                  RTC_GetStoreOperation PROC
;;;1408     */
;;;1409   uint32_t RTC_GetStoreOperation(void)
0004ee  48c1              LDR      r0,|L1.2036|
;;;1410   {
;;;1411     return (RTC->CR & RTC_CR_BCK);
0004f0  6880              LDR      r0,[r0,#8]
0004f2  2101              MOVS     r1,#1
0004f4  0489              LSLS     r1,r1,#18
0004f6  4008              ANDS     r0,r0,r1
;;;1412   }
0004f8  e777              B        |L1.1002|
;;;1413   
                          ENDP

                  RTC_OutputConfig PROC
;;;1444     */
;;;1445   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
0004fa  b510              PUSH     {r4,lr}
;;;1446   {
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_RTC_OUTPUT(RTC_Output));
;;;1449     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
;;;1450   
;;;1451     /* Disable the write protection for RTC registers */
;;;1452     RTC->WPR = 0xCA;
0004fc  4abd              LDR      r2,|L1.2036|
0004fe  23ca              MOVS     r3,#0xca
000500  6253              STR      r3,[r2,#0x24]
;;;1453     RTC->WPR = 0x53;
000502  2353              MOVS     r3,#0x53
000504  6253              STR      r3,[r2,#0x24]
;;;1454   
;;;1455     /* Clear the bits to be configured */
;;;1456     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
000506  6893              LDR      r3,[r2,#8]
000508  2407              MOVS     r4,#7
00050a  0524              LSLS     r4,r4,#20
00050c  43a3              BICS     r3,r3,r4
00050e  6093              STR      r3,[r2,#8]
;;;1457   
;;;1458     /* Configure the output selection and polarity */
;;;1459     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
000510  6893              LDR      r3,[r2,#8]
000512  4308              ORRS     r0,r0,r1
000514  4303              ORRS     r3,r3,r0
000516  6093              STR      r3,[r2,#8]
;;;1460   
;;;1461     /* Enable the write protection for RTC registers */
;;;1462     RTC->WPR = 0xFF;
000518  20ff              MOVS     r0,#0xff
00051a  6250              STR      r0,[r2,#0x24]
;;;1463   }
00051c  bd10              POP      {r4,pc}
;;;1464   
                          ENDP

                  RTC_CalibOutputCmd PROC
;;;1487     */
;;;1488   void RTC_CalibOutputCmd(FunctionalState NewState)
00051e  49b5              LDR      r1,|L1.2036|
;;;1489   {
;;;1490     /* Check the parameters */
;;;1491     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1492     
;;;1493     /* Disable the write protection for RTC registers */
;;;1494     RTC->WPR = 0xCA;
000520  22ca              MOVS     r2,#0xca
000522  624a              STR      r2,[r1,#0x24]
;;;1495     RTC->WPR = 0x53;
000524  2253              MOVS     r2,#0x53
000526  624a              STR      r2,[r1,#0x24]
;;;1496     
;;;1497     if (NewState != DISABLE)
;;;1498     {
;;;1499       /* Enable the RTC clock output */
;;;1500       RTC->CR |= (uint32_t)RTC_CR_COE;
000528  2201              MOVS     r2,#1
00052a  05d2              LSLS     r2,r2,#23
00052c  2800              CMP      r0,#0                 ;1497
;;;1501     }
;;;1502     else
;;;1503     { 
;;;1504       /* Disable the RTC clock output */
;;;1505       RTC->CR &= (uint32_t)~RTC_CR_COE;
00052e  6888              LDR      r0,[r1,#8]
000530  d001              BEQ      |L1.1334|
000532  4310              ORRS     r0,r0,r2              ;1500
000534  e000              B        |L1.1336|
                  |L1.1334|
000536  4390              BICS     r0,r0,r2
                  |L1.1336|
000538  6088              STR      r0,[r1,#8]
;;;1506     }
;;;1507     
;;;1508     /* Enable the write protection for RTC registers */
;;;1509     RTC->WPR = 0xFF; 
00053a  20ff              MOVS     r0,#0xff
00053c  6248              STR      r0,[r1,#0x24]
;;;1510   }
00053e  e754              B        |L1.1002|
;;;1511   
                          ENDP

                  RTC_CalibOutputConfig PROC
;;;1519   */
;;;1520   void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
000540  49ac              LDR      r1,|L1.2036|
;;;1521   {
;;;1522     /* Check the parameters */
;;;1523     assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
;;;1524   
;;;1525     /* Disable the write protection for RTC registers */
;;;1526     RTC->WPR = 0xCA;
000542  22ca              MOVS     r2,#0xca
000544  624a              STR      r2,[r1,#0x24]
;;;1527     RTC->WPR = 0x53;
000546  2253              MOVS     r2,#0x53
000548  624a              STR      r2,[r1,#0x24]
;;;1528     
;;;1529     /*clear flags before config*/
;;;1530     RTC->CR &= (uint32_t)~(RTC_CR_CALSEL);
00054a  688a              LDR      r2,[r1,#8]
00054c  2301              MOVS     r3,#1
00054e  04db              LSLS     r3,r3,#19
000550  439a              BICS     r2,r2,r3
000552  608a              STR      r2,[r1,#8]
;;;1531   
;;;1532     /* Configure the RTC_CR register */
;;;1533     RTC->CR |= (uint32_t)RTC_CalibOutput;
000554  688a              LDR      r2,[r1,#8]
000556  4302              ORRS     r2,r2,r0
000558  608a              STR      r2,[r1,#8]
;;;1534   
;;;1535     /* Enable the write protection for RTC registers */
;;;1536     RTC->WPR = 0xFF;
00055a  20ff              MOVS     r0,#0xff
00055c  6248              STR      r0,[r1,#0x24]
;;;1537   }
00055e  e744              B        |L1.1002|
;;;1538   
                          ENDP

                  RTC_SmoothCalibConfig PROC
;;;1555   */
;;;1556   ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
000560  b570              PUSH     {r4-r6,lr}
;;;1557                                     uint32_t RTC_SmoothCalibPlusPulses,
;;;1558                                     uint32_t RTC_SmouthCalibMinusPulsesValue)
;;;1559   {
;;;1560     ErrorStatus status = ERROR;
;;;1561     uint32_t recalpfcount = 0;
000562  2300              MOVS     r3,#0
;;;1562   
;;;1563     /* Check the parameters */
;;;1564     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
;;;1565     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
;;;1566     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
;;;1567   
;;;1568     /* Disable the write protection for RTC registers */
;;;1569     RTC->WPR = 0xCA;
000564  4ca3              LDR      r4,|L1.2036|
000566  25ca              MOVS     r5,#0xca
000568  6265              STR      r5,[r4,#0x24]
;;;1570     RTC->WPR = 0x53;
00056a  2553              MOVS     r5,#0x53
00056c  6265              STR      r5,[r4,#0x24]
;;;1571     
;;;1572     /* check if a calibration is pending*/
;;;1573     if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
00056e  68e5              LDR      r5,[r4,#0xc]
000570  03ed              LSLS     r5,r5,#15
000572  d507              BPL      |L1.1412|
;;;1574     {
;;;1575       /* wait until the Calibration is completed*/
;;;1576       while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
000574  14a5              ASRS     r5,r4,#18
                  |L1.1398|
000576  68e6              LDR      r6,[r4,#0xc]
000578  03f6              LSLS     r6,r6,#15
00057a  d503              BPL      |L1.1412|
00057c  42ab              CMP      r3,r5
00057e  d001              BEQ      |L1.1412|
;;;1577       {
;;;1578         recalpfcount++;
000580  1c5b              ADDS     r3,r3,#1
000582  e7f8              B        |L1.1398|
                  |L1.1412|
;;;1579       }
;;;1580     }
;;;1581   
;;;1582     /* check if the calibration pending is completed or if there is no calibration operation at all*/
;;;1583     if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
000584  68e3              LDR      r3,[r4,#0xc]
000586  03db              LSLS     r3,r3,#15
000588  d404              BMI      |L1.1428|
;;;1584     {
;;;1585       /* Configure the Smooth calibration settings */
;;;1586       RTC->CAL = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
00058a  4308              ORRS     r0,r0,r1
00058c  4310              ORRS     r0,r0,r2
00058e  63e0              STR      r0,[r4,#0x3c]
;;;1587   
;;;1588       status = SUCCESS;
000590  2001              MOVS     r0,#1
000592  e000              B        |L1.1430|
                  |L1.1428|
;;;1589     }
;;;1590     else
;;;1591     {
;;;1592       status = ERROR;
000594  2000              MOVS     r0,#0
                  |L1.1430|
;;;1593     }
;;;1594   
;;;1595     /* Enable the write protection for RTC registers */
;;;1596     RTC->WPR = 0xFF;
000596  21ff              MOVS     r1,#0xff
000598  6261              STR      r1,[r4,#0x24]
;;;1597     
;;;1598     return (ErrorStatus)(status);
;;;1599   }
00059a  bd70              POP      {r4-r6,pc}
;;;1600   
                          ENDP

                  RTC_TimeStampCmd PROC
;;;1631     */
;;;1632   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
00059c  b510              PUSH     {r4,lr}
;;;1633   {
;;;1634     uint32_t tmpreg = 0;
;;;1635   
;;;1636     /* Check the parameters */
;;;1637     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
;;;1638     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1639   
;;;1640     /* Get the RTC_CR register and clear the bits to be configured */
;;;1641     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
00059e  4b95              LDR      r3,|L1.2036|
0005a0  689a              LDR      r2,[r3,#8]
0005a2  4c96              LDR      r4,|L1.2044|
0005a4  4022              ANDS     r2,r2,r4
;;;1642   
;;;1643     /* Get the new configuration */
;;;1644     if (NewState != DISABLE)
0005a6  2900              CMP      r1,#0
0005a8  d001              BEQ      |L1.1454|
;;;1645     {
;;;1646       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
0005aa  4302              ORRS     r2,r2,r0
0005ac  14d8              ASRS     r0,r3,#19
                  |L1.1454|
;;;1647     }
;;;1648     else
;;;1649     {
;;;1650       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
0005ae  4302              ORRS     r2,r2,r0
;;;1651     }
;;;1652   
;;;1653     /* Disable the write protection for RTC registers */
;;;1654     RTC->WPR = 0xCA;
0005b0  20ca              MOVS     r0,#0xca
0005b2  6258              STR      r0,[r3,#0x24]
;;;1655     RTC->WPR = 0x53;
0005b4  2053              MOVS     r0,#0x53
0005b6  6258              STR      r0,[r3,#0x24]
;;;1656   
;;;1657     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;1658     RTC->CR = (uint32_t)tmpreg;
0005b8  609a              STR      r2,[r3,#8]
;;;1659   
;;;1660     /* Enable the write protection for RTC registers */
;;;1661     RTC->WPR = 0xFF;
0005ba  20ff              MOVS     r0,#0xff
0005bc  6258              STR      r0,[r3,#0x24]
;;;1662   }
0005be  bd10              POP      {r4,pc}
;;;1663   
                          ENDP

                  RTC_GetTimeStamp PROC
;;;1675     */
;;;1676   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
0005c0  b570              PUSH     {r4-r6,lr}
;;;1677                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;1678   {
0005c2  460d              MOV      r5,r1
;;;1679     uint32_t tmptime = 0, tmpdate = 0;
;;;1680   
;;;1681     /* Check the parameters */
;;;1682     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1683   
;;;1684     /* Get the TimeStamp time and date registers values */
;;;1685     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
0005c4  498b              LDR      r1,|L1.2036|
0005c6  4614              MOV      r4,r2                 ;1678
0005c8  6b0b              LDR      r3,[r1,#0x30]
0005ca  4a8d              LDR      r2,|L1.2048|
;;;1686     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
0005cc  6b49              LDR      r1,[r1,#0x34]
0005ce  401a              ANDS     r2,r2,r3              ;1685
0005d0  26c0              MOVS     r6,#0xc0
0005d2  43f6              MVNS     r6,r6
0005d4  4031              ANDS     r1,r1,r6
;;;1687   
;;;1688     /* Fill the Time structure fields with the read parameters */
;;;1689     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
0005d6  0296              LSLS     r6,r2,#10
0005d8  0eb6              LSRS     r6,r6,#26
0005da  702e              STRB     r6,[r5,#0]
;;;1690     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
0005dc  0456              LSLS     r6,r2,#17
0005de  0e76              LSRS     r6,r6,#25
;;;1691     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
0005e0  0652              LSLS     r2,r2,#25
0005e2  706e              STRB     r6,[r5,#1]            ;1690
0005e4  0e52              LSRS     r2,r2,#25
0005e6  70aa              STRB     r2,[r5,#2]
;;;1692     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
;;;1693   
;;;1694     /* Fill the Date structure fields with the read parameters */
;;;1695     RTC_StampDateStruct->RTC_Year = 0;
;;;1696     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
;;;1697     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
;;;1698     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
;;;1699   
;;;1700     /* Check the input parameters format */
;;;1701     if (RTC_Format == RTC_Format_BIN)
;;;1702     {
;;;1703       /* Convert the Time structure parameters to Binary format */
;;;1704       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
;;;1705       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
;;;1706       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
;;;1707   
;;;1708       /* Convert the Date structure parameters to Binary format */
;;;1709       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
;;;1710       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
;;;1711       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
;;;1712     }
;;;1713   }
0005e8  025a              LSLS     r2,r3,#9
0005ea  0e52              LSRS     r2,r2,#25
0005ec  2340              MOVS     r3,#0x40              ;1692
0005ee  401a              ANDS     r2,r2,r3              ;1692
0005f0  70ea              STRB     r2,[r5,#3]            ;1692
0005f2  2200              MOVS     r2,#0                 ;1695
0005f4  70e2              STRB     r2,[r4,#3]            ;1695
0005f6  04ca              LSLS     r2,r1,#19             ;1696
0005f8  0ed2              LSRS     r2,r2,#27             ;1696
0005fa  7062              STRB     r2,[r4,#1]            ;1696
0005fc  068a              LSLS     r2,r1,#26             ;1697
0005fe  0e92              LSRS     r2,r2,#26             ;1697
000600  0409              LSLS     r1,r1,#16             ;1698
000602  0f49              LSRS     r1,r1,#29             ;1698
000604  70a2              STRB     r2,[r4,#2]            ;1697
000606  7021              STRB     r1,[r4,#0]            ;1698
000608  2800              CMP      r0,#0                 ;1701
00060a  d117              BNE      |L1.1596|
00060c  7828              LDRB     r0,[r5,#0]            ;1704
00060e  f7fffffe          BL       RTC_Bcd2ToByte
000612  7028              STRB     r0,[r5,#0]            ;1704
000614  7868              LDRB     r0,[r5,#1]            ;1705
000616  f7fffffe          BL       RTC_Bcd2ToByte
00061a  7068              STRB     r0,[r5,#1]            ;1705
00061c  78a8              LDRB     r0,[r5,#2]            ;1706
00061e  f7fffffe          BL       RTC_Bcd2ToByte
000622  70a8              STRB     r0,[r5,#2]            ;1706
000624  7860              LDRB     r0,[r4,#1]            ;1709
000626  f7fffffe          BL       RTC_Bcd2ToByte
00062a  7060              STRB     r0,[r4,#1]            ;1709
00062c  78a0              LDRB     r0,[r4,#2]            ;1710
00062e  f7fffffe          BL       RTC_Bcd2ToByte
000632  70a0              STRB     r0,[r4,#2]            ;1710
000634  7820              LDRB     r0,[r4,#0]            ;1711
000636  f7fffffe          BL       RTC_Bcd2ToByte
00063a  7020              STRB     r0,[r4,#0]            ;1711
                  |L1.1596|
00063c  bd70              POP      {r4-r6,pc}
;;;1714   
                          ENDP

                  RTC_GetTimeStampSubSecond PROC
;;;1719     */
;;;1720   uint32_t RTC_GetTimeStampSubSecond(void)
00063e  486d              LDR      r0,|L1.2036|
;;;1721   {
;;;1722     /* Get timestamp subseconds values from the correspondent registers */
;;;1723     return (uint32_t)(RTC->TSSSR);
000640  6b80              LDR      r0,[r0,#0x38]
;;;1724   }
000642  e6d2              B        |L1.1002|
;;;1725   
                          ENDP

                  RTC_TamperTriggerConfig PROC
;;;1757     */
;;;1758   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000644  4a6b              LDR      r2,|L1.2036|
;;;1759   {
;;;1760     /* Check the parameters */
;;;1761     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
;;;1762     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;1763    
;;;1764     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
;;;1765     {  
;;;1766       /* Configure the RTC_TAFCR register */
;;;1767       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
000646  0040              LSLS     r0,r0,#1
000648  3240              ADDS     r2,r2,#0x40
00064a  2900              CMP      r1,#0                 ;1764
;;;1768     }
;;;1769     else
;;;1770     { 
;;;1771       /* Configure the RTC_TAFCR register */
;;;1772       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
00064c  6811              LDR      r1,[r2,#0]
00064e  d002              BEQ      |L1.1622|
000650  4301              ORRS     r1,r1,r0
                  |L1.1618|
000652  6011              STR      r1,[r2,#0]            ;1767
;;;1773     }  
;;;1774   }
000654  e6c9              B        |L1.1002|
                  |L1.1622|
000656  4381              BICS     r1,r1,r0              ;1767
000658  e7fb              B        |L1.1618|
;;;1775   
                          ENDP

                  RTC_TamperCmd PROC
;;;1786     */
;;;1787   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
00065a  4a66              LDR      r2,|L1.2036|
;;;1788   {
;;;1789     /* Check the parameters */
;;;1790     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
;;;1791     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1792     
;;;1793     if (NewState != DISABLE)
;;;1794     {
;;;1795       /* Enable the selected Tamper pin */
;;;1796       RTC->TAFCR |= (uint32_t)RTC_Tamper;
00065c  3240              ADDS     r2,r2,#0x40
00065e  2900              CMP      r1,#0                 ;1793
;;;1797     }
;;;1798     else
;;;1799     {
;;;1800       /* Disable the selected Tamper pin */
;;;1801       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
000660  6811              LDR      r1,[r2,#0]
000662  d001              BEQ      |L1.1640|
000664  4301              ORRS     r1,r1,r0              ;1796
000666  e000              B        |L1.1642|
                  |L1.1640|
000668  4381              BICS     r1,r1,r0
                  |L1.1642|
00066a  6011              STR      r1,[r2,#0]            ;1796
;;;1802     }  
;;;1803   }
00066c  e6bd              B        |L1.1002|
;;;1804   
                          ENDP

                  RTC_TamperFilterConfig PROC
;;;1817     */
;;;1818   void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
00066e  4961              LDR      r1,|L1.2036|
;;;1819   {
;;;1820     /* Check the parameters */
;;;1821     assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
;;;1822      
;;;1823     /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
;;;1824     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
000670  3140              ADDS     r1,r1,#0x40
000672  680a              LDR      r2,[r1,#0]
000674  2303              MOVS     r3,#3
000676  02db              LSLS     r3,r3,#11
000678  439a              BICS     r2,r2,r3
00067a  600a              STR      r2,[r1,#0]
;;;1825   
;;;1826     /* Configure the RTC_TAFCR register */
;;;1827     RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
00067c  680a              LDR      r2,[r1,#0]
00067e  4302              ORRS     r2,r2,r0
000680  600a              STR      r2,[r1,#0]
;;;1828   }
000682  e6b2              B        |L1.1002|
;;;1829   
                          ENDP

                  RTC_TamperSamplingFreqConfig PROC
;;;1851     */
;;;1852   void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
000684  495b              LDR      r1,|L1.2036|
;;;1853   {
;;;1854     /* Check the parameters */
;;;1855     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
;;;1856    
;;;1857     /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
;;;1858     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
000686  3140              ADDS     r1,r1,#0x40
000688  680a              LDR      r2,[r1,#0]
00068a  2307              MOVS     r3,#7
00068c  021b              LSLS     r3,r3,#8
00068e  439a              BICS     r2,r2,r3
000690  600a              STR      r2,[r1,#0]
;;;1859   
;;;1860     /* Configure the RTC_TAFCR register */
;;;1861     RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
000692  680a              LDR      r2,[r1,#0]
000694  4302              ORRS     r2,r2,r0
000696  600a              STR      r2,[r1,#0]
;;;1862   }
000698  e6a7              B        |L1.1002|
;;;1863   
                          ENDP

                  RTC_TamperPinsPrechargeDuration PROC
;;;1874     */
;;;1875   void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
00069a  4956              LDR      r1,|L1.2036|
;;;1876   {
;;;1877     /* Check the parameters */
;;;1878     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
;;;1879      
;;;1880     /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
;;;1881     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
00069c  3140              ADDS     r1,r1,#0x40
00069e  680a              LDR      r2,[r1,#0]
0006a0  2303              MOVS     r3,#3
0006a2  035b              LSLS     r3,r3,#13
0006a4  439a              BICS     r2,r2,r3
0006a6  600a              STR      r2,[r1,#0]
;;;1882   
;;;1883     /* Configure the RTC_TAFCR register */
;;;1884     RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
0006a8  680a              LDR      r2,[r1,#0]
0006aa  4302              ORRS     r2,r2,r0
0006ac  600a              STR      r2,[r1,#0]
;;;1885   }
0006ae  e69c              B        |L1.1002|
;;;1886   
                          ENDP

                  RTC_TimeStampOnTamperDetectionCmd PROC
;;;1894     */
;;;1895   void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
0006b0  4950              LDR      r1,|L1.2036|
;;;1896   {
;;;1897     /* Check the parameters */
;;;1898     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1899      
;;;1900     if (NewState != DISABLE)
;;;1901     {
;;;1902       /* Save timestamp on tamper detection event */
;;;1903       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
0006b2  2280              MOVS     r2,#0x80
0006b4  3140              ADDS     r1,r1,#0x40
0006b6  2800              CMP      r0,#0                 ;1900
;;;1904     }
;;;1905     else
;;;1906     {
;;;1907       /* Tamper detection does not cause a timestamp to be saved */
;;;1908       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
0006b8  6808              LDR      r0,[r1,#0]
0006ba  d001              BEQ      |L1.1728|
0006bc  4310              ORRS     r0,r0,r2              ;1903
0006be  e000              B        |L1.1730|
                  |L1.1728|
0006c0  4390              BICS     r0,r0,r2
                  |L1.1730|
0006c2  6008              STR      r0,[r1,#0]            ;1903
;;;1909     }
;;;1910   }
0006c4  e691              B        |L1.1002|
;;;1911   
                          ENDP

                  RTC_TamperPullUpCmd PROC
;;;1917     */
;;;1918   void RTC_TamperPullUpCmd(FunctionalState NewState)
0006c6  494b              LDR      r1,|L1.2036|
;;;1919   {
;;;1920     /* Check the parameters */
;;;1921     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1922     
;;;1923    if (NewState != DISABLE)
;;;1924     {
;;;1925       /* Enable precharge of the selected Tamper pin */
;;;1926       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
0006c8  3140              ADDS     r1,r1,#0x40
0006ca  13ca              ASRS     r2,r1,#15
0006cc  2800              CMP      r0,#0                 ;1923
;;;1927     }
;;;1928     else
;;;1929     {
;;;1930       /* Disable precharge of the selected Tamper pin */
;;;1931       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
0006ce  6808              LDR      r0,[r1,#0]
0006d0  d001              BEQ      |L1.1750|
0006d2  4390              BICS     r0,r0,r2              ;1926
0006d4  e000              B        |L1.1752|
                  |L1.1750|
0006d6  4310              ORRS     r0,r0,r2
                  |L1.1752|
0006d8  6008              STR      r0,[r1,#0]            ;1926
;;;1932     } 
;;;1933   }
0006da  e686              B        |L1.1002|
;;;1934   
                          ENDP

                  RTC_WriteBackupRegister PROC
;;;1958     */
;;;1959   void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
0006dc  4a45              LDR      r2,|L1.2036|
;;;1960   {
0006de  b508              PUSH     {r3,lr}
;;;1961     __IO uint32_t tmp = 0;
;;;1962     
;;;1963     /* Check the parameters */
;;;1964     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;1965   
;;;1966     tmp = RTC_BASE + 0x50;
0006e0  3250              ADDS     r2,r2,#0x50
;;;1967     tmp += (RTC_BKP_DR * 4);
0006e2  0080              LSLS     r0,r0,#2
0006e4  1880              ADDS     r0,r0,r2
;;;1968   
;;;1969     /* Write the specified register */
;;;1970     *(__IO uint32_t *)tmp = (uint32_t)Data;
0006e6  9000              STR      r0,[sp,#0]
0006e8  6001              STR      r1,[r0,#0]
;;;1971   }
0006ea  bd08              POP      {r3,pc}
;;;1972   
                          ENDP

                  RTC_ReadBackupRegister PROC
;;;1979     */
;;;1980   uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
0006ec  4941              LDR      r1,|L1.2036|
;;;1981   {
0006ee  b508              PUSH     {r3,lr}
;;;1982     __IO uint32_t tmp = 0;
;;;1983     
;;;1984     /* Check the parameters */
;;;1985     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;1986   
;;;1987     tmp = RTC_BASE + 0x50;
0006f0  3150              ADDS     r1,r1,#0x50
;;;1988     tmp += (RTC_BKP_DR * 4);
0006f2  0080              LSLS     r0,r0,#2
0006f4  1840              ADDS     r0,r0,r1
;;;1989     
;;;1990     /* Read the specified register */
;;;1991     return (*(__IO uint32_t *)tmp);
0006f6  9000              STR      r0,[sp,#0]
0006f8  6800              LDR      r0,[r0,#0]
;;;1992   }
0006fa  bd08              POP      {r3,pc}
;;;1993   
                          ENDP

                  RTC_OutputTypeConfig PROC
;;;2019     */
;;;2020   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
0006fc  493d              LDR      r1,|L1.2036|
;;;2021   {
;;;2022     /* Check the parameters */
;;;2023     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
;;;2024     
;;;2025     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
0006fe  3140              ADDS     r1,r1,#0x40
000700  680a              LDR      r2,[r1,#0]
000702  2301              MOVS     r3,#1
000704  049b              LSLS     r3,r3,#18
000706  439a              BICS     r2,r2,r3
000708  600a              STR      r2,[r1,#0]
;;;2026     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
00070a  680a              LDR      r2,[r1,#0]
00070c  4302              ORRS     r2,r2,r0
00070e  600a              STR      r2,[r1,#0]
;;;2027   }
000710  e66b              B        |L1.1002|
;;;2028   
                          ENDP

                  RTC_SynchroShiftConfig PROC
;;;2057   */
;;;2058   ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
000712  b530              PUSH     {r4,r5,lr}
;;;2059   {
;;;2060     ErrorStatus status = ERROR;
;;;2061     uint32_t shpfcount = 0;
000714  2200              MOVS     r2,#0
;;;2062   
;;;2063     /* Check the parameters */
;;;2064     assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
;;;2065     assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
;;;2066   
;;;2067     /* Disable the write protection for RTC registers */
;;;2068     RTC->WPR = 0xCA;
000716  4c37              LDR      r4,|L1.2036|
000718  23ca              MOVS     r3,#0xca
00071a  6263              STR      r3,[r4,#0x24]
;;;2069     RTC->WPR = 0x53;
00071c  2353              MOVS     r3,#0x53
00071e  6263              STR      r3,[r4,#0x24]
;;;2070     
;;;2071     /* Check if a Shift is pending*/
;;;2072     if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
000720  68e3              LDR      r3,[r4,#0xc]
000722  071b              LSLS     r3,r3,#28
000724  d507              BPL      |L1.1846|
;;;2073     {
;;;2074       /* Wait until the shift is completed*/
;;;2075       while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
000726  14a3              ASRS     r3,r4,#18
                  |L1.1832|
000728  68e5              LDR      r5,[r4,#0xc]
00072a  072d              LSLS     r5,r5,#28
00072c  d503              BPL      |L1.1846|
00072e  429a              CMP      r2,r3
000730  d001              BEQ      |L1.1846|
;;;2076       {
;;;2077         shpfcount++;
000732  1c52              ADDS     r2,r2,#1
000734  e7f8              B        |L1.1832|
                  |L1.1846|
;;;2078       }
;;;2079     }
;;;2080   
;;;2081     /* Check if the Shift pending is completed or if there is no Shift operation at all*/
;;;2082     if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
000736  68e2              LDR      r2,[r4,#0xc]
000738  0712              LSLS     r2,r2,#28
00073a  d40a              BMI      |L1.1874|
;;;2083     {
;;;2084       /* check if the reference clock detection is disabled */
;;;2085       if((RTC->CR & RTC_CR_REFCKON) == RESET)
00073c  68a2              LDR      r2,[r4,#8]
00073e  06d2              LSLS     r2,r2,#27
000740  d407              BMI      |L1.1874|
;;;2086       {
;;;2087         /* Configure the Shift settings */
;;;2088         RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
000742  4301              ORRS     r1,r1,r0
000744  62e1              STR      r1,[r4,#0x2c]
;;;2089       
;;;2090         if(RTC_WaitForSynchro() == ERROR)
000746  f7fffffe          BL       RTC_WaitForSynchro
00074a  2800              CMP      r0,#0
00074c  d002              BEQ      |L1.1876|
;;;2091         {
;;;2092           status = ERROR;
;;;2093         }
;;;2094         else
;;;2095         {
;;;2096           status = SUCCESS;
00074e  2001              MOVS     r0,#1
000750  e000              B        |L1.1876|
                  |L1.1874|
;;;2097         }
;;;2098       }
;;;2099       else
;;;2100       {
;;;2101         status = ERROR;
000752  2000              MOVS     r0,#0
                  |L1.1876|
;;;2102       }
;;;2103     }
;;;2104     else
;;;2105     {
;;;2106       status = ERROR;
;;;2107     }
;;;2108   
;;;2109     /* Enable the write protection for RTC registers */
;;;2110     RTC->WPR = 0xFF;
000754  21ff              MOVS     r1,#0xff
000756  6261              STR      r1,[r4,#0x24]
;;;2111     
;;;2112     return (ErrorStatus)(status);
;;;2113   }
000758  bd30              POP      {r4,r5,pc}
;;;2114   
                          ENDP

                  RTC_ITConfig PROC
;;;2166     */
;;;2167   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
00075a  b530              PUSH     {r4,r5,lr}
;;;2168   {
;;;2169     /* Check the parameters */
;;;2170     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
;;;2171     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2172   
;;;2173     /* Disable the write protection for RTC registers */
;;;2174     RTC->WPR = 0xCA;
00075c  4b25              LDR      r3,|L1.2036|
00075e  22ca              MOVS     r2,#0xca
000760  625a              STR      r2,[r3,#0x24]
;;;2175     RTC->WPR = 0x53;
000762  2253              MOVS     r2,#0x53
000764  625a              STR      r2,[r3,#0x24]
;;;2176   
;;;2177     if (NewState != DISABLE)
;;;2178     {
;;;2179       /* Configure the Interrupts in the RTC_CR register */
;;;2180       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
000766  2504              MOVS     r5,#4
000768  4602              MOV      r2,r0
;;;2181       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2182       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
00076a  4c22              LDR      r4,|L1.2036|
00076c  43aa              BICS     r2,r2,r5              ;2180
00076e  3440              ADDS     r4,r4,#0x40
000770  4028              ANDS     r0,r0,r5
000772  2900              CMP      r1,#0                 ;2177
;;;2183     }
;;;2184     else
;;;2185     {
;;;2186       /* Configure the Interrupts in the RTC_CR register */
;;;2187       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
000774  6899              LDR      r1,[r3,#8]
000776  d004              BEQ      |L1.1922|
000778  4311              ORRS     r1,r1,r2              ;2180
00077a  6099              STR      r1,[r3,#8]            ;2180
00077c  6821              LDR      r1,[r4,#0]            ;2182
00077e  4301              ORRS     r1,r1,r0              ;2182
000780  e003              B        |L1.1930|
                  |L1.1922|
000782  4391              BICS     r1,r1,r2
000784  6099              STR      r1,[r3,#8]
;;;2188       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2189       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000786  6821              LDR      r1,[r4,#0]
000788  4381              BICS     r1,r1,r0
                  |L1.1930|
00078a  6021              STR      r1,[r4,#0]
;;;2190     }
;;;2191     /* Enable the write protection for RTC registers */
;;;2192     RTC->WPR = 0xFF; 
00078c  20ff              MOVS     r0,#0xff
00078e  6258              STR      r0,[r3,#0x24]
;;;2193   }
000790  bd30              POP      {r4,r5,pc}
;;;2194   
                          ENDP

                  RTC_GetFlagStatus PROC
;;;2210     */
;;;2211   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
000792  4918              LDR      r1,|L1.2036|
;;;2212   {
000794  4602              MOV      r2,r0
;;;2213     FlagStatus bitstatus = RESET;
;;;2214     uint32_t tmpreg = 0;
;;;2215     
;;;2216     /* Check the parameters */
;;;2217     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
;;;2218     
;;;2219     /* Get all the flags */
;;;2220     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
000796  68c9              LDR      r1,[r1,#0xc]
000798  2000              MOVS     r0,#0                 ;2213
00079a  4b1a              LDR      r3,|L1.2052|
00079c  4019              ANDS     r1,r1,r3
;;;2221     
;;;2222     /* Return the status of the flag */
;;;2223     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
00079e  4211              TST      r1,r2
0007a0  d000              BEQ      |L1.1956|
;;;2224     {
;;;2225       bitstatus = SET;
0007a2  2001              MOVS     r0,#1
                  |L1.1956|
;;;2226     }
;;;2227     else
;;;2228     {
;;;2229       bitstatus = RESET;
;;;2230     }
;;;2231     return bitstatus;
;;;2232   }
0007a4  e621              B        |L1.1002|
;;;2233   
                          ENDP

                  RTC_ClearFlag PROC
;;;2246     */
;;;2247   void RTC_ClearFlag(uint32_t RTC_FLAG)
0007a6  2180              MOVS     r1,#0x80
;;;2248   {
;;;2249     /* Check the parameters */
;;;2250     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
;;;2251   
;;;2252     /* Clear the Flags in the RTC_ISR register */
;;;2253     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0001FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));    
0007a8  4308              ORRS     r0,r0,r1
0007aa  03c0              LSLS     r0,r0,#15
0007ac  0bc0              LSRS     r0,r0,#15
0007ae  43c3              MVNS     r3,r0
0007b0  4810              LDR      r0,|L1.2036|
0007b2  68c2              LDR      r2,[r0,#0xc]
0007b4  400a              ANDS     r2,r2,r1
0007b6  4313              ORRS     r3,r3,r2
0007b8  60c3              STR      r3,[r0,#0xc]
;;;2254   }
0007ba  e616              B        |L1.1002|
;;;2255   
                          ENDP

                  RTC_GetITStatus PROC
;;;2266     */
;;;2267   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
0007bc  b570              PUSH     {r4-r6,lr}
;;;2268   {
;;;2269     ITStatus bitstatus = RESET;
;;;2270     uint32_t tmpreg = 0, enablestatus = 0;
;;;2271    
;;;2272     /* Check the parameters */
;;;2273     assert_param(IS_RTC_GET_IT(RTC_IT));
;;;2274     
;;;2275     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;2276     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
0007be  4a0d              LDR      r2,|L1.2036|
0007c0  2100              MOVS     r1,#0                 ;2269
0007c2  3240              ADDS     r2,r2,#0x40
0007c4  6812              LDR      r2,[r2,#0]
0007c6  2304              MOVS     r3,#4
;;;2277    
;;;2278     /* Get the Interrupt enable Status */
;;;2279     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
0007c8  4c0a              LDR      r4,|L1.2036|
0007ca  401a              ANDS     r2,r2,r3              ;2276
0007cc  68a3              LDR      r3,[r4,#8]
0007ce  0c86              LSRS     r6,r0,#18
0007d0  4605              MOV      r5,r0
0007d2  40f5              LSRS     r5,r5,r6
0007d4  0bed              LSRS     r5,r5,#15
0007d6  4015              ANDS     r5,r5,r2
0007d8  4003              ANDS     r3,r3,r0
;;;2280     
;;;2281     /* Get the Interrupt pending bit */
;;;2282     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
0007da  68e2              LDR      r2,[r4,#0xc]
0007dc  432b              ORRS     r3,r3,r5              ;2279
0007de  0900              LSRS     r0,r0,#4
0007e0  4002              ANDS     r2,r2,r0
;;;2283     
;;;2284     /* Get the status of the Interrupt */
;;;2285     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
0007e2  2b00              CMP      r3,#0
0007e4  d003              BEQ      |L1.2030|
0007e6  0410              LSLS     r0,r2,#16
0007e8  0c00              LSRS     r0,r0,#16
0007ea  d000              BEQ      |L1.2030|
;;;2286     {
;;;2287       bitstatus = SET;
0007ec  2101              MOVS     r1,#1
                  |L1.2030|
;;;2288     }
;;;2289     else
;;;2290     {
;;;2291       bitstatus = RESET;
;;;2292     }
;;;2293     return bitstatus;
0007ee  4608              MOV      r0,r1
;;;2294   }
0007f0  bd70              POP      {r4-r6,pc}
0007f2  0000              DCW      0x0000
                  |L1.2036|
                          DCD      0x40002800
                  |L1.2040|
                          DCD      0x80808080
                  |L1.2044|
                          DCD      0xfffff7f7
                  |L1.2048|
                          DCD      0x007f7f7f
                  |L1.2052|
                          DCD      0x0001f978
                          ENDP

                  RTC_ClearITPendingBit PROC
;;;2306     */
;;;2307   void RTC_ClearITPendingBit(uint32_t RTC_IT)
000808  0900              LSRS     r0,r0,#4
;;;2308   {
;;;2309     uint32_t tmpreg = 0;
;;;2310   
;;;2311     /* Check the parameters */
;;;2312     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
;;;2313   
;;;2314     /* Get the RTC_ISR Interrupt pending bits mask */
;;;2315     tmpreg = (uint32_t)(RTC_IT >> 4);
;;;2316   
;;;2317     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;2318     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
00080a  2180              MOVS     r1,#0x80
00080c  4308              ORRS     r0,r0,r1
00080e  b280              UXTH     r0,r0
000810  4a0d              LDR      r2,|L1.2120|
000812  43c3              MVNS     r3,r0
000814  68d0              LDR      r0,[r2,#0xc]
000816  4008              ANDS     r0,r0,r1
000818  4303              ORRS     r3,r3,r0
00081a  60d3              STR      r3,[r2,#0xc]
;;;2319   }
00081c  e5e5              B        |L1.1002|
;;;2320   
                          ENDP

                  RTC_ByteToBcd2 PROC
;;;2329     */
;;;2330   static uint8_t RTC_ByteToBcd2(uint8_t Value)
00081e  2100              MOVS     r1,#0
;;;2331   {
000820  e003              B        |L1.2090|
                  |L1.2082|
;;;2332     uint8_t bcdhigh = 0;
;;;2333     
;;;2334     while (Value >= 10)
;;;2335     {
;;;2336       bcdhigh++;
000822  1c49              ADDS     r1,r1,#1
;;;2337       Value -= 10;
000824  380a              SUBS     r0,r0,#0xa
000826  b2c9              UXTB     r1,r1                 ;2336
000828  b2c0              UXTB     r0,r0
                  |L1.2090|
00082a  280a              CMP      r0,#0xa               ;2334
00082c  d2f9              BCS      |L1.2082|
;;;2338     }
;;;2339     
;;;2340     return  ((uint8_t)(bcdhigh << 4) | Value);
00082e  0709              LSLS     r1,r1,#28
000830  0e09              LSRS     r1,r1,#24
000832  4308              ORRS     r0,r0,r1
;;;2341   }
000834  e5d9              B        |L1.1002|
;;;2342   
                          ENDP

                  RTC_Bcd2ToByte PROC
;;;2347     */
;;;2348   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000836  0901              LSRS     r1,r0,#4
;;;2349   {
;;;2350     uint8_t tmp = 0;
;;;2351     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000838  220a              MOVS     r2,#0xa
;;;2352     return (tmp + (Value & (uint8_t)0x0F));
00083a  0700              LSLS     r0,r0,#28
00083c  4351              MULS     r1,r2,r1              ;2351
00083e  0f00              LSRS     r0,r0,#28
000840  1840              ADDS     r0,r0,r1
000842  b2c0              UXTB     r0,r0
;;;2353   }
000844  e5d1              B        |L1.1002|
;;;2354   
                          ENDP

000846  0000              DCW      0x0000
                  |L1.2120|
                          DCD      0x40002800

;*** Start embedded assembler ***

#line 1 "..\\arch\\arm\\stm32f05x\\lib\\src\\stm32f0xx_rtc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_rtc_c_81435638____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f0xx_rtc_c_81435638____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_rtc_c_81435638____REVSH|
#line 144
|__asm___15_stm32f0xx_rtc_c_81435638____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
