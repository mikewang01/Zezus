; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\message.o --asm_dir=.\ --list_dir=.\ --depend=.\message.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\message.crf ..\kernel\message\message.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  get_message PROC
;;;27      */
;;;28     os_err_t get_message(PCB* task_state , smessage** msg)
000000  4603              MOV      r3,r0
;;;29     {
;;;30         u8 msg_num=0;
;;;31         /*get cuurent message ptr from task PCB*/	
;;;32         *msg=	(smessage*)task_state->ptr;
000002  6880              LDR      r0,[r0,#8]
;;;33     	
;;;34         /*if no message existed, return 0*/	
;;;35         if(msg==NULL)
000004  6008              STR      r0,[r1,#0]
000006  2900              CMP      r1,#0
000008  d002              BEQ      |L1.16|
;;;36         {
;;;37             return 0;
;;;38         }
;;;39         
;;;40     		/*statistic  message num that hook in PCB*/
;;;41         msg_num++;
00000a  2001              MOVS     r0,#1
;;;42         while((*msg)->next!=NULL)
00000c  680a              LDR      r2,[r1,#0]
00000e  e004              B        |L1.26|
                  |L1.16|
000010  2000              MOVS     r0,#0                 ;37
;;;43         {
;;;44             msg_num++;
;;;45             (*msg)=(*msg)->next;
;;;46         }
;;;47         
;;;48         /*copy message ptr to uer pointer */
;;;49         *msg=(smessage*)task_state->ptr;
;;;50         
;;;51         
;;;52         return msg_num;
;;;53     }
000012  4770              BX       lr
                  |L1.20|
000014  1c40              ADDS     r0,r0,#1              ;44
000016  b2c0              UXTB     r0,r0                 ;44
000018  600a              STR      r2,[r1,#0]            ;45
                  |L1.26|
00001a  6912              LDR      r2,[r2,#0x10]         ;42
00001c  2a00              CMP      r2,#0                 ;42
00001e  d1f9              BNE      |L1.20|
000020  689a              LDR      r2,[r3,#8]            ;49
000022  600a              STR      r2,[r1,#0]            ;49
000024  4770              BX       lr
;;;54     
                          ENDP

                  delete_message PROC
;;;65     static  u8 message_lock=released;
;;;66     os_err_t delete_message(u8 task_id,u8 message_type)
000026  b5f8              PUSH     {r3-r7,lr}
;;;67     {
000028  460d              MOV      r5,r1
00002a  4604              MOV      r4,r0
;;;68         PCB * ptaskstate=NULL;
;;;69         smessage* msg=NULL;
;;;70     	
;;;71     	  /*get task state by task_id*/
;;;72         GET_TASKSATE_BYID(task_id,ptaskstate);
00002c  f7fffffe          BL       OS_get_taskstate
000030  210c              MOVS     r1,#0xc
000032  434c              MULS     r4,r1,r4
;;;73     	
;;;74     	  /*get message ptr*/
;;;75         msg=(smessage*)ptaskstate->ptr;
;;;76         
;;;77     	  /*wait until other thread release this lock*/
;;;78         while(message_lock==locked);	
000034  4e35              LDR      r6,|L1.268|
000036  1820              ADDS     r0,r4,r0              ;72
000038  7831              LDRB     r1,[r6,#0]
00003a  6884              LDR      r4,[r0,#8]
                  |L1.60|
00003c  2900              CMP      r1,#0
00003e  d0fd              BEQ      |L1.60|
;;;79     	
;;;80     	  /*lock up message*/
;;;81         message_lock=locked;
000040  2100              MOVS     r1,#0
000042  7031              STRB     r1,[r6,#0]
;;;82           
;;;83         ptaskstate->ptr=NULL;
;;;84     	  
;;;85     	  /*remove state mark in case making thread running again*/
;;;86         ptaskstate->State^=message_type;
000044  6081              STR      r1,[r0,#8]
000046  8801              LDRH     r1,[r0,#0]
000048  4069              EORS     r1,r1,r5
00004a  8001              STRH     r1,[r0,#0]
;;;87     	
;;;88         while(msg!=NULL)
;;;89         {
;;;90             smessage* temp=msg;
;;;91             msg=msg->next;
;;;92             if(temp->ptr!=NULL)
;;;93             {
;;;94                /*free message memory taht has been occupied*/ 
;;;95     					 if(osfree((void*)(temp->ptr))==ERROR)
;;;96                 {
;;;97                     goto fault;
;;;98                 }
;;;99             }
;;;100    				/*erroe happens return fault*/
;;;101            if(osfree((void*)(temp))==ERROR)
;;;102            {
;;;103                goto fault;
;;;104            }
;;;105            
;;;106        }
;;;107        
;;;108        /*release message lock*/
;;;109        message_lock=released;
00004c  2701              MOVS     r7,#1
00004e  e00d              B        |L1.108|
                  |L1.80|
000050  4625              MOV      r5,r4                 ;90
000052  68e8              LDR      r0,[r5,#0xc]          ;92
000054  6924              LDR      r4,[r4,#0x10]         ;91
000056  2800              CMP      r0,#0                 ;92
000058  d003              BEQ      |L1.98|
00005a  f7fffffe          BL       osfree
00005e  2800              CMP      r0,#0                 ;95
000060  d009              BEQ      |L1.118|
                  |L1.98|
000062  4628              MOV      r0,r5                 ;101
000064  f7fffffe          BL       osfree
000068  2800              CMP      r0,#0                 ;101
00006a  d004              BEQ      |L1.118|
                  |L1.108|
00006c  2c00              CMP      r4,#0                 ;88
00006e  d1ef              BNE      |L1.80|
000070  7037              STRB     r7,[r6,#0]
;;;110        
;;;111        return SUCCESS;	 
000072  2001              MOVS     r0,#1
;;;112    fault:
;;;113        message_lock=released;
;;;114        return ERROR;
;;;115    }
000074  bdf8              POP      {r3-r7,pc}
                  |L1.118|
000076  7037              STRB     r7,[r6,#0]            ;113
000078  2000              MOVS     r0,#0                 ;114
00007a  bdf8              POP      {r3-r7,pc}
;;;116    
                          ENDP

                  send_message PROC
;;;129    
;;;130    os_err_t send_message(u8 task_id , u16 pcb_type , u16 message_type , u16 event,void *data, u16 length)
00007c  b5ff              PUSH     {r0-r7,lr}
;;;131    {
00007e  b081              SUB      sp,sp,#4
;;;132        smessage* msg=(smessage*)osmalloc(sizeof(smessage));
000080  2014              MOVS     r0,#0x14
000082  f7fffffe          BL       osmalloc
;;;133        u8 *data_temp=NULL;
;;;134        
;;;135        smessage* msg_tmp=NULL;
;;;136        PCB *  taskstate_tmp=NULL;
;;;137        u16 circle=0;
;;;138        if(message_lock==locked)
000086  4e21              LDR      r6,|L1.268|
000088  4604              MOV      r4,r0                 ;132
00008a  2700              MOVS     r7,#0                 ;133
00008c  7830              LDRB     r0,[r6,#0]  ; message_lock
00008e  463d              MOV      r5,r7                 ;137
000090  2800              CMP      r0,#0
000092  d035              BEQ      |L1.256|
;;;139        {
;;;140            return ERROR;
;;;141        }
;;;142        message_lock=locked;
000094  2000              MOVS     r0,#0
000096  7030              STRB     r0,[r6,#0]
;;;143        
;;;144        /*copy data in buffer into newly allocated space*/
;;;145        if(length!=0)
000098  980b              LDR      r0,[sp,#0x2c]
00009a  2800              CMP      r0,#0
00009c  d006              BEQ      |L1.172|
;;;146        {
;;;147            data_temp=(u8*)osmalloc(sizeof(u8)*length);
00009e  f7fffffe          BL       osmalloc
0000a2  4607              MOV      r7,r0
;;;148            osmemcpy(data_temp ,data , length);
0000a4  9a0b              LDR      r2,[sp,#0x2c]
0000a6  990a              LDR      r1,[sp,#0x28]
0000a8  f7fffffe          BL       osmemcpy
                  |L1.172|
;;;149        }
;;;150        /*if there is no message return erroe*/
;;;151        if(msg==NULL)
0000ac  2c00              CMP      r4,#0
0000ae  d029              BEQ      |L1.260|
;;;152        {
;;;153            goto fault;
;;;154        }	
;;;155        
;;;156        osmemset(msg,0,sizeof(smessage));
0000b0  2214              MOVS     r2,#0x14
0000b2  2100              MOVS     r1,#0
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       osmemset
;;;157    		
;;;158    		/*set event group type*/
;;;159        msg->type= message_type; 
0000ba  9803              LDR      r0,[sp,#0xc]
0000bc  7020              STRB     r0,[r4,#0]
;;;160    		/*set message length*/
;;;161        msg->length= length;
0000be  980b              LDR      r0,[sp,#0x2c]
0000c0  8120              STRH     r0,[r4,#8]
;;;162    		/*set user data ptr*/
;;;163        msg->ptr=data_temp;
;;;164        /*set specific event*/
;;;165        msg->event=event;
0000c2  60e7              STR      r7,[r4,#0xc]
0000c4  9804              LDR      r0,[sp,#0x10]
;;;166    		/*set next ptr to NULL*/
;;;167        msg->next=NULL;
0000c6  6060              STR      r0,[r4,#4]
0000c8  2000              MOVS     r0,#0
;;;168        
;;;169        
;;;170    		/*get the task PCB corresponded to task_id*/
;;;171        taskstate_tmp=OS_get_taskstate();
0000ca  6120              STR      r0,[r4,#0x10]
0000cc  f7fffffe          BL       OS_get_taskstate
;;;172    		/*set task to run */
;;;173        taskstate_tmp[task_id].State|=pcb_type;
0000d0  9901              LDR      r1,[sp,#4]
0000d2  220c              MOVS     r2,#0xc
0000d4  4351              MULS     r1,r2,r1
0000d6  5a42              LDRH     r2,[r0,r1]
0000d8  9b02              LDR      r3,[sp,#8]
0000da  431a              ORRS     r2,r2,r3
0000dc  5242              STRH     r2,[r0,r1]
;;;174        
;;;175    		/*if this is the fist message*/
;;;176        if(taskstate_tmp[task_id].ptr==NULL)
0000de  1809              ADDS     r1,r1,r0
0000e0  6888              LDR      r0,[r1,#8]
0000e2  2800              CMP      r0,#0
0000e4  d106              BNE      |L1.244|
;;;177        {
;;;178            taskstate_tmp[task_id].ptr=(void*)msg;
0000e6  608c              STR      r4,[r1,#8]
0000e8  e008              B        |L1.252|
                  |L1.234|
;;;179        }
;;;180        else /*there are some message existed in PCB ptr area*/
;;;181        {
;;;182            msg_tmp=(smessage*)taskstate_tmp[task_id].ptr;
;;;183            
;;;184            /*find the end of the message chain*/
;;;185            while(msg_tmp->next!=NULL)
;;;186            {
;;;187                msg_tmp=msg_tmp->next;
;;;188    					/*in case it is a dead loop*/
;;;189                circle++;
0000ea  1c6d              ADDS     r5,r5,#1
0000ec  b2ad              UXTH     r5,r5
0000ee  4608              MOV      r0,r1                 ;178
;;;190                if(circle>30)
0000f0  2d1e              CMP      r5,#0x1e
0000f2  d802              BHI      |L1.250|
                  |L1.244|
0000f4  6901              LDR      r1,[r0,#0x10]         ;185
0000f6  2900              CMP      r1,#0                 ;185
0000f8  d1f7              BNE      |L1.234|
                  |L1.250|
;;;191                {
;;;192                    break;
;;;193                }
;;;194            }
;;;195            
;;;196            
;;;197            msg_tmp->next=msg;
0000fa  6104              STR      r4,[r0,#0x10]
                  |L1.252|
;;;198        }
;;;199    		
;;;200    		/*release message lock*/
;;;201        message_lock=released;
0000fc  2001              MOVS     r0,#1
0000fe  7030              STRB     r0,[r6,#0]
                  |L1.256|
;;;202        return SUCCESS;
;;;203        
;;;204    fault:
;;;205        message_lock=released;
;;;206        return ERROR;
;;;207    }
000100  b005              ADD      sp,sp,#0x14
000102  bdf0              POP      {r4-r7,pc}
                  |L1.260|
000104  2001              MOVS     r0,#1                 ;205
000106  7030              STRB     r0,[r6,#0]            ;205
000108  2000              MOVS     r0,#0                 ;206
00010a  e7f9              B        |L1.256|
;;;208    
                          ENDP

                  |L1.268|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=0

                  message_lock
000000  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "..\\kernel\\message\\message.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_message_c_2f3e61d1____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_message_c_2f3e61d1____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_message_c_2f3e61d1____REVSH|
#line 144
|__asm___9_message_c_2f3e61d1____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
