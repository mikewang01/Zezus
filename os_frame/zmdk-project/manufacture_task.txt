; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\manufacture_task.o --asm_dir=.\ --list_dir=.\ --depend=.\manufacture_task.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\manufacture_task.crf ..\task\usertask\manufacture_task.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  task_manufacture_init PROC
;;;74      */
;;;75     void  task_manufacture_init()
000000  b510              PUSH     {r4,lr}
;;;76     {
;;;77         u8 this_task_id=Current_Task;
000002  4870              LDR      r0,|L1.452|
000004  7800              LDRB     r0,[r0,#0]  ; Current_Task
;;;78     	  eeprom_register(this_task_id);
000006  f7fffffe          BL       eeprom_register
;;;79         os_device_init_all();
00000a  f7fffffe          BL       os_device_init_all
;;;80         
;;;81     }
00000e  bd10              POP      {r4,pc}
;;;82     /*********************************************************************
                          ENDP

                  process_order PROC
;;;218    
;;;219    static os_err_t process_order(data_packge package)
000010  b40f              PUSH     {r0-r3}
;;;220    {
000012  b5fe              PUSH     {r1-r7,lr}
;;;221        os_device_t *dev_serial = os_device_get("USART1");
000014  a06c              ADR      r0,|L1.456|
000016  f7fffffe          BL       os_device_get
00001a  0005              MOVS     r5,r0
;;;222        
;;;223     
;;;224         /*if opened failed return error*/
;;;225    		EXAM_ASSERT( (dev_serial!=NULL) );
00001c  d103              BNE      |L1.38|
00001e  21e1              MOVS     r1,#0xe1
000020  a06b              ADR      r0,|L1.464|
000022  f7fffffe          BL       exam_assert
                  |L1.38|
;;;226        
;;;227        /*order of get_mac adress*/
;;;228        if(package.order == get_mac)
000026  a808              ADD      r0,sp,#0x20
000028  7842              LDRB     r2,[r0,#1]
00002a  4604              MOV      r4,r0
00002c  2a01              CMP      r2,#1
00002e  d012              BEQ      |L1.86|
;;;229        {
;;;230            
;;;231    			   os_device_t *dev = os_device_get("me2_ch2o");
;;;232    			
;;;233    			    u8 temp[10]={0 , 11,22,33,44,55,66,77,88}; 
;;;234    			   	temp[0]= sizeof(correction_para);
;;;235    				
;;;236    		  #ifdef _TASK_DEBUG_
;;;237    			    printf("%d [%s]:%d",package.order , __FILE__ , __LINE__ );
;;;238    			#endif
;;;239    			
;;;240    			  os_device_control(dev, set_correction_para , temp);
;;;241    			
;;;242    			  /*get payload length*/
;;;243            package.payload.lenth = sizeof(mac_adress);
;;;244            
;;;245            /*copy corresponed mac adress to pay load */
;;;246            os_memmove(package.payload.pay_load , mac_adress , package.payload.lenth);
;;;247            
;;;248    			  
;;;249            /*send the response data*/
;;;250            return os_device_write(dev_serial , 0 , (u8*)(&package) , sizeof(data_packge)); 
;;;251            
;;;252        }else if(package.order == get_vol) /*order of get_vol to get curent volatge cpu sampled*/
;;;253        {
;;;254            /*set payload lenth*/
;;;255            package.payload.lenth = sizeof(u16);
000030  2602              MOVS     r6,#2
000032  2a04              CMP      r2,#4                 ;252
000034  d025              BEQ      |L1.130|
000036  2000              MOVS     r0,#0                 ;252
;;;256            
;;;257            /*fullfill the corresponed data area*/
;;;258            *((u16*)package.payload.pay_load) = sensor_get_voltage();
;;;259            
;;;260            /*send  response data*/
;;;261            return os_device_write(dev_serial , 0 , (u8*)(&package) , sizeof(data_packge));
;;;262    			
;;;263        }else if(package.order == get_dsy)/*order of get_dsy to get curent density cpu sampled*/
000038  2a05              CMP      r2,#5
00003a  d029              BEQ      |L1.144|
;;;264    		{
;;;265    			   u16 density=0;
;;;266    			   
;;;267    			  
;;;268    			   os_device_t *dev = os_device_get("me2_ch2o");
;;;269    			
;;;270    			#ifdef _TASK_DEBUG_
;;;271    			    printf("%d [%s]:%d",package.order , __FILE__ , __LINE__ );
;;;272    			#endif
;;;273    			
;;;274    			    /*if opened fialed return error*/
;;;275    			    EXAM_ASSERT( (dev!=NULL) );
;;;276          
;;;277    				 /*get data lenth*/
;;;278    				 package.payload.lenth = sizeof(u16);
;;;279    				 
;;;280    		     /*read data from me_ch2o device*/ 	
;;;281              os_device_read(dev , 0 , (void*)&density , package.payload.lenth);
;;;282    				 
;;;283    			   /*copy corresponed mac adress to pay load */
;;;284             os_memmove(package.payload.pay_load , (void*)&density , package.payload.lenth);
;;;285    				 
;;;286    				 	/*save new parameter to eeprom*/
;;;287    			   os_device_control(dev, update_correction_sensor , NULL);
;;;288    				 
;;;289    				  /*send  coresponded data*/
;;;290             return os_device_write(dev_serial , 0 , (u8*)(&package) , sizeof(data_packge));
;;;291    				 
;;;292    		}else if(package.order == set_para) /*set_parameter order distributed by host software*/
00003c  2a0b              CMP      r2,#0xb
00003e  d045              BEQ      |L1.204|
;;;293    		{
;;;294    			  
;;;295    			  u8 argument[sizeof(correction_para)+2] = {0};
;;;296    			  os_device_t *dev = os_device_get("me2_ch2o");
;;;297    		
;;;298    	      
;;;299    			  /*if opened failed return error*/
;;;300    			  EXAM_ASSERT( (dev!=NULL) );
;;;301    				/*size of the pakage*/
;;;302    			  argument[0] = package.payload.lenth;
;;;303    			  os_memmove((argument+1) , (void*)&package.payload.pay_load , package.payload.lenth);
;;;304    			  
;;;305    				/*save new parameter to eeprom*/
;;;306    			  os_device_control(dev, set_correction_para , argument);
;;;307    				
;;;308    			  /*send  the same data to response*/
;;;309            return os_device_write(dev_serial , 0 , (u8*)(&package) , sizeof(data_packge));
;;;310            
;;;311        }else if(package.order == get_para) /*get parameter from device*/
000040  2a0a              CMP      r2,#0xa
000042  d003              BEQ      |L1.76|
;;;312        {
;;;313    			  
;;;314    			  
;;;315        }else if(package.order == get_hard_version) /*get hardware version*/
000044  2a02              CMP      r2,#2
000046  d001              BEQ      |L1.76|
;;;316    		{
;;;317    				
;;;318    		}
;;;319    		else if(package.order == get_soft_version) /*get sorfware versiom*/
000048  2a03              CMP      r2,#3
00004a  d059              BEQ      |L1.256|
                  |L1.76|
;;;320    		{
;;;321          u32 version;
;;;322    			/*get detailed version by macros*/
;;;323    			version = GET_VERSION();
;;;324    			
;;;325    			package.payload.lenth = sizeof(u32);
;;;326    			/*copy data from buffer to package payload*/
;;;327    			os_memmove( (void*)&package.payload.pay_load , &version , package.payload.lenth );
;;;328    			
;;;329    			/*send  corresponded data to host*/
;;;330          return os_device_write(dev_serial , 0 , (u8*)(&package) , sizeof(data_packge));
;;;331    			
;;;332        }
;;;333        return ERROR;
00004c  2000              MOVS     r0,#0
                  |L1.78|
;;;334    }
00004e  bcfe              POP      {r1-r7}
000050  bc08              POP      {r3}
000052  b004              ADD      sp,sp,#0x10
000054  4718              BX       r3
                  |L1.86|
000056  a067              ADR      r0,|L1.500|
000058  f7fffffe          BL       os_device_get
00005c  4a68              LDR      r2,|L1.512|
00005e  4603              MOV      r3,r0                 ;231
000060  3214              ADDS     r2,r2,#0x14           ;233
000062  ca07              LDM      r2,{r0-r2}            ;233
000064  466f              MOV      r7,sp                 ;234
000066  c707              STM      r7!,{r0-r2}           ;234
000068  2608              MOVS     r6,#8                 ;234
00006a  4668              MOV      r0,sp                 ;234
00006c  7006              STRB     r6,[r0,#0]            ;234
00006e  466a              MOV      r2,sp                 ;240
000070  2101              MOVS     r1,#1                 ;240
000072  4618              MOV      r0,r3                 ;240
000074  f7fffffe          BL       os_device_control
000078  4668              MOV      r0,sp                 ;243
00007a  8446              STRH     r6,[r0,#0x22]         ;243
00007c  4632              MOV      r2,r6                 ;246
00007e  4960              LDR      r1,|L1.512|
000080  e045              B        |L1.270|
                  |L1.130|
000082  4669              MOV      r1,sp                 ;255
000084  844e              STRH     r6,[r1,#0x22]         ;255
000086  f7fffffe          BL       sensor_get_voltage
00008a  4669              MOV      r1,sp                 ;258
00008c  8488              STRH     r0,[r1,#0x24]         ;258
00008e  e041              B        |L1.276|
                  |L1.144|
000090  4669              MOV      r1,sp                 ;265
000092  8008              STRH     r0,[r1,#0]            ;265
000094  a057              ADR      r0,|L1.500|
000096  f7fffffe          BL       os_device_get
00009a  0007              MOVS     r7,r0                 ;268
00009c  d104              BNE      |L1.168|
00009e  21ff              MOVS     r1,#0xff              ;275
0000a0  3114              ADDS     r1,r1,#0x14           ;275
0000a2  a04b              ADR      r0,|L1.464|
0000a4  f7fffffe          BL       exam_assert
                  |L1.168|
0000a8  4668              MOV      r0,sp                 ;278
0000aa  8446              STRH     r6,[r0,#0x22]         ;278
0000ac  4633              MOV      r3,r6                 ;278
0000ae  466a              MOV      r2,sp                 ;281
0000b0  2100              MOVS     r1,#0                 ;281
0000b2  4638              MOV      r0,r7                 ;281
0000b4  f7fffffe          BL       os_device_read
0000b8  4668              MOV      r0,sp                 ;284
0000ba  8c42              LDRH     r2,[r0,#0x22]         ;284
0000bc  4669              MOV      r1,sp                 ;284
0000be  1d20              ADDS     r0,r4,#4              ;284
0000c0  f7fffffe          BL       os_memmove
0000c4  2200              MOVS     r2,#0                 ;287
0000c6  2102              MOVS     r1,#2                 ;287
0000c8  4638              MOV      r0,r7                 ;287
0000ca  e016              B        |L1.250|
                  |L1.204|
0000cc  9000              STR      r0,[sp,#0]            ;295
0000ce  9001              STR      r0,[sp,#4]            ;295
0000d0  9002              STR      r0,[sp,#8]            ;296
0000d2  a048              ADR      r0,|L1.500|
0000d4  f7fffffe          BL       os_device_get
0000d8  0006              MOVS     r6,r0                 ;296
0000da  d104              BNE      |L1.230|
0000dc  21ff              MOVS     r1,#0xff              ;300
0000de  312d              ADDS     r1,r1,#0x2d           ;300
0000e0  a03b              ADR      r0,|L1.464|
0000e2  f7fffffe          BL       exam_assert
                  |L1.230|
0000e6  4668              MOV      r0,sp                 ;302
0000e8  8c42              LDRH     r2,[r0,#0x22]         ;302
0000ea  7002              STRB     r2,[r0,#0]            ;302
0000ec  1c40              ADDS     r0,r0,#1              ;302
0000ee  1d21              ADDS     r1,r4,#4              ;303
0000f0  f7fffffe          BL       os_memmove
0000f4  466a              MOV      r2,sp                 ;306
0000f6  2101              MOVS     r1,#1                 ;306
0000f8  4630              MOV      r0,r6                 ;306
                  |L1.250|
0000fa  f7fffffe          BL       os_device_control
0000fe  e009              B        |L1.276|
                  |L1.256|
000100  2001              MOVS     r0,#1                 ;323
000102  0400              LSLS     r0,r0,#16             ;323
000104  9000              STR      r0,[sp,#0]            ;325
000106  2204              MOVS     r2,#4                 ;325
000108  4668              MOV      r0,sp                 ;325
00010a  8442              STRH     r2,[r0,#0x22]         ;325
00010c  4669              MOV      r1,sp                 ;327
                  |L1.270|
00010e  1d20              ADDS     r0,r4,#4              ;246
000110  f7fffffe          BL       os_memmove
                  |L1.276|
000114  2312              MOVS     r3,#0x12              ;330
000116  aa08              ADD      r2,sp,#0x20           ;330
000118  2100              MOVS     r1,#0                 ;330
00011a  4628              MOV      r0,r5                 ;330
00011c  f7fffffe          BL       os_device_write
000120  b2c0              UXTB     r0,r0                 ;330
000122  e794              B        |L1.78|
;;;335    
                          ENDP

                  task_manufacture PROC
;;;90      */
;;;91     void task_manufacture()
000124  b538              PUSH     {r3-r5,lr}
;;;92     {
;;;93         
;;;94         u8 My_Id=Current_Task;
000126  4827              LDR      r0,|L1.452|
000128  7805              LDRB     r5,[r0,#0]  ; Current_Task
;;;95         PCB* task_state=0; 
;;;96     	  /*get self PCB to lead a further process */
;;;97         get_self_taskstate(My_Id,task_state);
00012a  f7fffffe          BL       OS_get_taskstate
00012e  462c              MOV      r4,r5
000130  210c              MOVS     r1,#0xc
000132  434c              MULS     r4,r1,r4
000134  1820              ADDS     r0,r4,r0
;;;98         
;;;99         // printf("taskid = %d" , My_Id );
;;;100        /*it actully get some message recieve and process it*/
;;;101        if(((task_state->State)&SYSTEM_EVENT)==SYSTEM_EVENT)
000136  7801              LDRB     r1,[r0,#0]
000138  0749              LSLS     r1,r1,#29
00013a  d507              BPL      |L1.332|
;;;102        {
;;;103            
;;;104            smessage* msg_get;
;;;105    			
;;;106            /*get detailed message through PCB*/
;;;107            u8 msg_num=get_message(task_state , &msg_get);
00013c  4669              MOV      r1,sp
00013e  f7fffffe          BL       get_message
000142  4601              MOV      r1,r0
;;;108           // printf("get message %d", msg_num);
;;;109    			
;;;110            /*process the message has been recieved*/
;;;111            process_msg(My_Id, msg_num , msg_get);
000144  4628              MOV      r0,r5
000146  9a00              LDR      r2,[sp,#0]
000148  f7fffffe          BL       process_msg
                  |L1.332|
;;;112        }
;;;113        
;;;114        /*delete messge recieved or memmory leakage gonna happen*/
;;;115        delete_message(My_Id,SYSTEM_EVENT);
00014c  2104              MOVS     r1,#4
00014e  4628              MOV      r0,r5
000150  f7fffffe          BL       delete_message
;;;116        
;;;117        /*statistic the the oppupation of cpu*/
;;;118        task_ticks_inc(My_Id);
000154  f7fffffe          BL       OS_get_taskstate
000158  1900              ADDS     r0,r0,r4
00015a  6841              LDR      r1,[r0,#4]
00015c  1c49              ADDS     r1,r1,#1
00015e  6041              STR      r1,[r0,#4]
;;;119    }
000160  bd38              POP      {r3-r5,pc}
;;;120    
                          ENDP

                  process_msg PROC
;;;134    
;;;135    static void process_msg(u16 taskid , u16 msg_num , smessage* msg)
000162  b570              PUSH     {r4-r6,lr}
;;;136    {
000164  b086              SUB      sp,sp,#0x18
000166  4614              MOV      r4,r2
000168  460d              MOV      r5,r1
                  |L1.362|
;;;137        do{
;;;138            
;;;139            switch(msg->type)
00016a  7820              LDRB     r0,[r4,#0]
00016c  2801              CMP      r0,#1
00016e  d002              BEQ      |L1.374|
000170  2802              CMP      r0,#2
000172  d120              BNE      |L1.438|
000174  e01c              B        |L1.432|
                  |L1.374|
;;;140            {
;;;141            /* inter process communication message*/
;;;142            case IPC_MSG: 
;;;143    				 {
;;;144                 u8 buffer[10]={1,2,3,4,5,6,7,8};
;;;145    					   os_device_t *dev = os_device_get("EEPROM");
000176  a023              ADR      r0,|L1.516|
000178  f7fffffe          BL       os_device_get
00017c  0006              MOVS     r6,r0
;;;146    						 /*device open fialed  return NULL*/
;;;147    						 if(dev == NULL)
00017e  d102              BNE      |L1.390|
;;;148    						 {
;;;149    							 printf("open failed");
000180  a022              ADR      r0,|L1.524|
000182  f7fffffe          BL       __2printf
                  |L1.390|
;;;150    						 }
;;;151    						 
;;;152    					  os_device_open(dev, 1); //make sure  usart1 
000186  2101              MOVS     r1,#1
000188  4630              MOV      r0,r6
00018a  f7fffffe          BL       os_device_open
;;;153              //  os_device_write(dev, 2 , buffer , 8);
;;;154    					//   os_device_read(dev , 0 , buffer , 9);
;;;155    				//		 os_device_close(dev);
;;;156    				//		 printf("%s" , buffer);
;;;157    						 
;;;158                /*CALIBRATION_COMMAND  event ,process it*/
;;;159                if((msg->event&CALIBRATION_COMMAND) == CALIBRATION_COMMAND )
00018e  7920              LDRB     r0,[r4,#4]
000190  43c0              MVNS     r0,r0
000192  0780              LSLS     r0,r0,#30
000194  d10f              BNE      |L1.438|
;;;160                {
;;;161                    
;;;162                    data_packge *calibration_data=(data_packge*)msg->ptr;
;;;163                    
;;;164                    process_order(*calibration_data);
000196  68e1              LDR      r1,[r4,#0xc]
000198  466a              MOV      r2,sp
00019a  8a08              LDRH     r0,[r1,#0x10]
00019c  8010              STRH     r0,[r2,#0]
00019e  2212              MOVS     r2,#0x12
0001a0  a801              ADD      r0,sp,#4
0001a2  f7fffffe          BL       __aeabi_memcpy
0001a6  a801              ADD      r0,sp,#4
0001a8  c80f              LDM      r0,{r0-r3}
0001aa  f7fffffe          BL       process_order
;;;165                 //   printf("order = %d" , calibration_data->order );
;;;166                }
0001ae  e002              B        |L1.438|
                  |L1.432|
;;;167             }break;
;;;168    				 
;;;169            /*timer related message*/
;;;170            case TIMER_MSG: 
;;;171                if((msg->event&TIMEOUT_500MS)==TIMEOUT_500MS)
0001b0  6860              LDR      r0,[r4,#4]
0001b2  43c1              MVNS     r1,r0
0001b4  0789              LSLS     r1,r1,#30
                  |L1.438|
;;;172                {
;;;173                    
;;;174                    
;;;175                    
;;;176                }else if((msg->event&TIMEOUT_250MS)==TIMEOUT_250MS)
;;;177                {
;;;178                    
;;;179                    
;;;180                }
;;;181                else if((msg->event&TIMEOUT_125MS)==TIMEOUT_125MS)
;;;182                {
;;;183                    
;;;184                    
;;;185                }					 
;;;186                else if((msg->event&TIMEOUT_RELAY1)==TIMEOUT_RELAY1)
;;;187                {
;;;188                    
;;;189                }		
;;;190                
;;;191                
;;;192                break;
;;;193                
;;;194            /*device related message*/
;;;195            case DEV_MSG: 
;;;196                
;;;197                
;;;198                break;
;;;199            }
;;;200            
;;;201            /*get next message from message queue*/
;;;202            msg=msg->next;
;;;203        }while((--msg_num)>0);
0001b6  1e6d              SUBS     r5,r5,#1
0001b8  6924              LDR      r4,[r4,#0x10]         ;202
0001ba  042d              LSLS     r5,r5,#16
0001bc  0c2d              LSRS     r5,r5,#16
0001be  d1d4              BNE      |L1.362|
;;;204    }
0001c0  b006              ADD      sp,sp,#0x18
0001c2  bd70              POP      {r4-r6,pc}
;;;205    
                          ENDP

                  |L1.452|
                          DCD      Current_Task
                  |L1.456|
0001c8  55534152          DCB      "USART1",0
0001cc  543100  
0001cf  00                DCB      0
                  |L1.464|
0001d0  2e2e5c74          DCB      "..\\task\\usertask\\manufacture_task.c",0
0001d4  61736b5c
0001d8  75736572
0001dc  7461736b
0001e0  5c6d616e
0001e4  75666163
0001e8  74757265
0001ec  5f746173
0001f0  6b2e6300
                  |L1.500|
0001f4  6d65325f          DCB      "me2_ch2o",0
0001f8  6368326f
0001fc  00      
0001fd  00                DCB      0
0001fe  00                DCB      0
0001ff  00                DCB      0
                  |L1.512|
                          DCD      ||.constdata||
                  |L1.516|
000204  45455052          DCB      "EEPROM",0
000208  4f4d00  
00020b  00                DCB      0
                  |L1.524|
00020c  6f70656e          DCB      "open failed",0
000210  20666169
000214  6c656400

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  mac_adress
000000  11223344          DCB      0x11,0x22,0x33,0x44
000004  55667788          DCB      0x55,0x66,0x77,0x88
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  05060708          DCB      0x05,0x06,0x07,0x08
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  000b1621          DCB      0x00,0x0b,0x16,0x21
000018  2c37424d          DCB      0x2c,0x37,0x42,0x4d
00001c  5800              DCB      0x58,0x00

;*** Start embedded assembler ***

#line 1 "..\\task\\usertask\\manufacture_task.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___18_manufacture_task_c_ea5c2a4a____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___18_manufacture_task_c_ea5c2a4a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___18_manufacture_task_c_ea5c2a4a____REVSH|
#line 144
|__asm___18_manufacture_task_c_ea5c2a4a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
