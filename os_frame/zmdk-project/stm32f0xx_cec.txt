; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\stm32f0xx_cec.o --asm_dir=.\ --list_dir=.\ --depend=.\stm32f0xx_cec.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\stm32f0xx_cec.crf ..\arch\arm\stm32f05x\lib\src\stm32f0xx_cec.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CEC_DeInit PROC
;;;143      */
;;;144    void CEC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;145    {
;;;146      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, ENABLE);
000002  2101              MOVS     r1,#1
000004  078c              LSLS     r4,r1,#30
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;147      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, DISABLE);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;148    }
000014  bd10              POP      {r4,pc}
;;;149    
                          ENDP

                  CEC_Init PROC
;;;157      */
;;;158    void CEC_Init(CEC_InitTypeDef* CEC_InitStruct)
000016  b530              PUSH     {r4,r5,lr}
;;;159    {
;;;160      uint32_t tmpreg = 0;
;;;161    
;;;162      /* Check the parameters */
;;;163      assert_param(IS_CEC_SIGNAL_FREE_TIME(CEC_InitStruct->CEC_SignalFreeTime));
;;;164      assert_param(IS_CEC_RX_TOLERANCE(CEC_InitStruct->CEC_RxTolerance));
;;;165      assert_param(IS_CEC_STOP_RECEPTION(CEC_InitStruct->CEC_StopReception));
;;;166      assert_param(IS_CEC_BIT_RISING_ERROR(CEC_InitStruct->CEC_BitRisingError));
;;;167      assert_param(IS_CEC_LONG_BIT_PERIOD_ERROR(CEC_InitStruct->CEC_LongBitPeriodError));
;;;168      assert_param(IS_CEC_BDR_NO_GEN_ERROR(CEC_InitStruct->CEC_BRDNoGen));
;;;169      assert_param(IS_CEC_SFT_OPTION(CEC_InitStruct->CEC_SFTOption));
;;;170    
;;;171      /* Get the CEC CFGR value */
;;;172      tmpreg = CEC->CFGR;
000018  4b3b              LDR      r3,|L1.264|
00001a  6859              LDR      r1,[r3,#4]
;;;173    
;;;174      /* Clear CFGR bits */
;;;175      tmpreg &= CFGR_CLEAR_MASK;
00001c  4a3b              LDR      r2,|L1.268|
;;;176    
;;;177      /* Configure the CEC peripheral */
;;;178      tmpreg |= (CEC_InitStruct->CEC_SignalFreeTime | CEC_InitStruct->CEC_RxTolerance |
00001e  6844              LDR      r4,[r0,#4]
000020  4011              ANDS     r1,r1,r2              ;175
000022  6802              LDR      r2,[r0,#0]
000024  68c5              LDR      r5,[r0,#0xc]
000026  4322              ORRS     r2,r2,r4
000028  6884              LDR      r4,[r0,#8]
00002a  432c              ORRS     r4,r4,r5
00002c  4322              ORRS     r2,r2,r4
00002e  6904              LDR      r4,[r0,#0x10]
000030  4322              ORRS     r2,r2,r4
000032  6944              LDR      r4,[r0,#0x14]
000034  6980              LDR      r0,[r0,#0x18]
000036  4322              ORRS     r2,r2,r4
000038  4302              ORRS     r2,r2,r0
00003a  430a              ORRS     r2,r2,r1
;;;179                 CEC_InitStruct->CEC_StopReception  | CEC_InitStruct->CEC_BitRisingError |
;;;180                 CEC_InitStruct->CEC_LongBitPeriodError| CEC_InitStruct->CEC_BRDNoGen |
;;;181                 CEC_InitStruct->CEC_SFTOption);
;;;182    
;;;183      /* Write to CEC CFGR  register */
;;;184      CEC->CFGR = tmpreg;
00003c  605a              STR      r2,[r3,#4]
;;;185    }
00003e  bd30              POP      {r4,r5,pc}
;;;186    
                          ENDP

                  CEC_StructInit PROC
;;;192      */
;;;193    void CEC_StructInit(CEC_InitTypeDef* CEC_InitStruct)
000040  2100              MOVS     r1,#0
;;;194    {
;;;195      CEC_InitStruct->CEC_SignalFreeTime = CEC_SignalFreeTime_Standard;
;;;196      CEC_InitStruct->CEC_RxTolerance = CEC_RxTolerance_Standard;
000042  6001              STR      r1,[r0,#0]
;;;197      CEC_InitStruct->CEC_StopReception = CEC_StopReception_Off;
000044  6041              STR      r1,[r0,#4]
;;;198      CEC_InitStruct->CEC_BitRisingError = CEC_BitRisingError_Off;
000046  6081              STR      r1,[r0,#8]
;;;199      CEC_InitStruct->CEC_LongBitPeriodError = CEC_LongBitPeriodError_Off;
000048  60c1              STR      r1,[r0,#0xc]
;;;200      CEC_InitStruct->CEC_BRDNoGen = CEC_BRDNoGen_Off;
00004a  6101              STR      r1,[r0,#0x10]
;;;201      CEC_InitStruct->CEC_SFTOption = CEC_SFTOption_Off;
00004c  6141              STR      r1,[r0,#0x14]
00004e  6181              STR      r1,[r0,#0x18]
;;;202    }
000050  4770              BX       lr
;;;203    
                          ENDP

                  CEC_Cmd PROC
;;;209      */
;;;210    void CEC_Cmd(FunctionalState NewState)
000052  492d              LDR      r1,|L1.264|
;;;211    {
;;;212      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;213    
;;;214      if (NewState != DISABLE)
000054  2800              CMP      r0,#0
;;;215      {
;;;216        /* Enable the CEC peripheral */
;;;217        CEC->CR |= CEC_CR_CECEN;
;;;218      }
;;;219      else
;;;220      {
;;;221        /* Disable the CEC peripheral */
;;;222        CEC->CR &= ~CEC_CR_CECEN;
000056  6808              LDR      r0,[r1,#0]
000058  d002              BEQ      |L1.96|
00005a  2201              MOVS     r2,#1                 ;217
00005c  4310              ORRS     r0,r0,r2              ;217
00005e  e001              B        |L1.100|
                  |L1.96|
000060  0840              LSRS     r0,r0,#1
000062  0040              LSLS     r0,r0,#1
                  |L1.100|
000064  6008              STR      r0,[r1,#0]            ;217
;;;223      }
;;;224    }
000066  4770              BX       lr
;;;225    
                          ENDP

                  CEC_ListenModeCmd PROC
;;;231      */
;;;232    void CEC_ListenModeCmd(FunctionalState NewState)
000068  4927              LDR      r1,|L1.264|
;;;233    {
;;;234      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;235    
;;;236      if (NewState != DISABLE)
00006a  2800              CMP      r0,#0
;;;237      {
;;;238        /* Enable the Listen Mode */
;;;239        CEC->CFGR |= CEC_CFGR_LSTN;
;;;240      }
;;;241      else
;;;242      {
;;;243        /* Disable the Listen Mode */
;;;244        CEC->CFGR &= ~CEC_CFGR_LSTN;
00006c  6848              LDR      r0,[r1,#4]
00006e  d002              BEQ      |L1.118|
000070  050a              LSLS     r2,r1,#20             ;239
000072  4310              ORRS     r0,r0,r2              ;239
000074  e001              B        |L1.122|
                  |L1.118|
000076  0040              LSLS     r0,r0,#1
000078  0840              LSRS     r0,r0,#1
                  |L1.122|
00007a  6048              STR      r0,[r1,#4]            ;239
;;;245      }
;;;246    }
00007c  4770              BX       lr
;;;247    
                          ENDP

                  CEC_OwnAddressConfig PROC
;;;252      */
;;;253    void CEC_OwnAddressConfig(uint8_t CEC_OwnAddress)
00007e  3010              ADDS     r0,r0,#0x10
;;;254    {
;;;255      uint32_t tmp =0x00;
;;;256      /* Check the parameters */
;;;257      assert_param(IS_CEC_ADDRESS(CEC_OwnAddress));
;;;258      tmp = 1 <<(CEC_OwnAddress + 16);
000080  2101              MOVS     r1,#1
000082  4081              LSLS     r1,r1,r0
;;;259      /* Set the CEC own address */
;;;260      CEC->CFGR |= tmp;
000084  4820              LDR      r0,|L1.264|
000086  6842              LDR      r2,[r0,#4]
000088  430a              ORRS     r2,r2,r1
00008a  6042              STR      r2,[r0,#4]
;;;261    }
00008c  4770              BX       lr
;;;262    
                          ENDP

                  CEC_OwnAddressClear PROC
;;;267      */
;;;268    void CEC_OwnAddressClear(void)
00008e  491e              LDR      r1,|L1.264|
;;;269    {
;;;270      /* Set the CEC own address */
;;;271      CEC->CFGR = 0x0;
000090  2000              MOVS     r0,#0
000092  6048              STR      r0,[r1,#4]
;;;272    }
000094  4770              BX       lr
;;;273    
                          ENDP

                  CEC_SendData PROC
;;;297      */
;;;298    void CEC_SendData(uint8_t Data)
000096  491c              LDR      r1,|L1.264|
;;;299    {
;;;300      /* Transmit Data */
;;;301      CEC->TXDR = Data;
000098  6088              STR      r0,[r1,#8]
;;;302    }
00009a  4770              BX       lr
;;;303    
                          ENDP

                  CEC_ReceiveData PROC
;;;308      */
;;;309    uint8_t CEC_ReceiveData(void)
00009c  481a              LDR      r0,|L1.264|
;;;310    {
;;;311      /* Receive Data */
;;;312      return (uint8_t)(CEC->RXDR);
00009e  68c0              LDR      r0,[r0,#0xc]
0000a0  b2c0              UXTB     r0,r0
;;;313    }
0000a2  4770              BX       lr
;;;314    
                          ENDP

                  CEC_StartOfMessage PROC
;;;319      */
;;;320    void CEC_StartOfMessage(void)
0000a4  4818              LDR      r0,|L1.264|
;;;321    {
;;;322      /* Starts of new message */
;;;323      CEC->CR |= CEC_CR_TXSOM; 
0000a6  6801              LDR      r1,[r0,#0]
0000a8  2202              MOVS     r2,#2
0000aa  4311              ORRS     r1,r1,r2
0000ac  6001              STR      r1,[r0,#0]
;;;324    }
0000ae  4770              BX       lr
;;;325    
                          ENDP

                  CEC_EndOfMessage PROC
;;;330      */
;;;331    void CEC_EndOfMessage(void)
0000b0  4815              LDR      r0,|L1.264|
;;;332    {
;;;333      /* The data byte will be transmitted with an EOM bit */
;;;334      CEC->CR |= CEC_CR_TXEOM;
0000b2  6801              LDR      r1,[r0,#0]
0000b4  2204              MOVS     r2,#4
0000b6  4311              ORRS     r1,r1,r2
0000b8  6001              STR      r1,[r0,#0]
;;;335    }
0000ba  4770              BX       lr
;;;336    
                          ENDP

                  CEC_ITConfig PROC
;;;430      */
;;;431    void CEC_ITConfig(uint16_t CEC_IT, FunctionalState NewState)
0000bc  4a12              LDR      r2,|L1.264|
;;;432    {
;;;433      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;434      assert_param(IS_CEC_IT(CEC_IT));
;;;435    
;;;436      if (NewState != DISABLE)
0000be  2900              CMP      r1,#0
0000c0  d002              BEQ      |L1.200|
;;;437      {
;;;438        /* Enable the selected CEC interrupt */
;;;439        CEC->IER |= CEC_IT;
0000c2  6951              LDR      r1,[r2,#0x14]
0000c4  4301              ORRS     r1,r1,r0
0000c6  e003              B        |L1.208|
                  |L1.200|
;;;440      }
;;;441      else
;;;442      {
;;;443        CEC_IT =~CEC_IT;
0000c8  43c0              MVNS     r0,r0
;;;444        /* Disable the selected CEC interrupt */
;;;445        CEC->IER &= CEC_IT;
0000ca  6951              LDR      r1,[r2,#0x14]
0000cc  b280              UXTH     r0,r0                 ;443
0000ce  4001              ANDS     r1,r1,r0
                  |L1.208|
0000d0  6151              STR      r1,[r2,#0x14]         ;439
;;;446      }
;;;447    }
0000d2  4770              BX       lr
;;;448    
                          ENDP

                  CEC_GetFlagStatus PROC
;;;467      */
;;;468    FlagStatus CEC_GetFlagStatus(uint16_t CEC_FLAG) 
0000d4  4a0c              LDR      r2,|L1.264|
;;;469    {
0000d6  4601              MOV      r1,r0
;;;470      FlagStatus bitstatus = RESET;
;;;471      
;;;472      assert_param(IS_CEC_GET_FLAG(CEC_FLAG));
;;;473      
;;;474      /* Check the status of the specified CEC flag */
;;;475      if ((CEC->ISR & CEC_FLAG) != (uint16_t)RESET)
0000d8  6912              LDR      r2,[r2,#0x10]
0000da  2000              MOVS     r0,#0                 ;470
0000dc  420a              TST      r2,r1
0000de  d000              BEQ      |L1.226|
;;;476      {
;;;477        /* CEC flag is set */
;;;478        bitstatus = SET;
0000e0  2001              MOVS     r0,#1
                  |L1.226|
;;;479      }
;;;480      else
;;;481      {
;;;482        /* CEC flag is reset */
;;;483        bitstatus = RESET;
;;;484      }
;;;485    
;;;486      /* Return the CEC flag status */
;;;487      return  bitstatus;
;;;488    }
0000e2  4770              BX       lr
;;;489    
                          ENDP

                  CEC_ClearFlag PROC
;;;508      */
;;;509    void CEC_ClearFlag(uint32_t CEC_FLAG)
0000e4  4908              LDR      r1,|L1.264|
;;;510    {
;;;511      assert_param(IS_CEC_CLEAR_FLAG(CEC_FLAG));
;;;512    
;;;513      /* Clear the selected CEC flag */
;;;514      CEC->ISR = CEC_FLAG;
0000e6  6108              STR      r0,[r1,#0x10]
;;;515    }
0000e8  4770              BX       lr
;;;516    
                          ENDP

                  CEC_GetITStatus PROC
;;;535      */
;;;536    ITStatus CEC_GetITStatus(uint16_t CEC_IT)
0000ea  4b07              LDR      r3,|L1.264|
;;;537    {
0000ec  4602              MOV      r2,r0
;;;538      ITStatus bitstatus = RESET;
;;;539      uint32_t enablestatus = 0;
;;;540    
;;;541      /* Check the parameters */
;;;542      assert_param(IS_CEC_GET_IT(CEC_IT));
;;;543    
;;;544      /* Get the CEC IT enable bit status */
;;;545      enablestatus = (CEC->IER & CEC_IT);
0000ee  6959              LDR      r1,[r3,#0x14]
0000f0  2000              MOVS     r0,#0                 ;538
;;;546    
;;;547      /* Check the status of the specified CEC interrupt */
;;;548      if (((CEC->ISR & CEC_IT) != (uint32_t)RESET) && enablestatus)
0000f2  691b              LDR      r3,[r3,#0x10]
0000f4  4011              ANDS     r1,r1,r2              ;545
0000f6  4213              TST      r3,r2
0000f8  d002              BEQ      |L1.256|
0000fa  2900              CMP      r1,#0
0000fc  d000              BEQ      |L1.256|
;;;549      {
;;;550        /* CEC interrupt is set */
;;;551        bitstatus = SET;
0000fe  2001              MOVS     r0,#1
                  |L1.256|
;;;552      }
;;;553      else
;;;554      {
;;;555        /* CEC interrupt is reset */
;;;556        bitstatus = RESET;
;;;557      }
;;;558    
;;;559      /* Return the CEC interrupt status */
;;;560      return  bitstatus;
;;;561    }
000100  4770              BX       lr
;;;562    
                          ENDP

                  CEC_ClearITPendingBit PROC
;;;581      */
;;;582    void CEC_ClearITPendingBit(uint16_t CEC_IT)
000102  4901              LDR      r1,|L1.264|
;;;583    {
;;;584      assert_param(IS_CEC_IT(CEC_IT));
;;;585    
;;;586      /* Clear the selected CEC interrupt pending bits */
;;;587      CEC->ISR = CEC_IT;
000104  6108              STR      r0,[r1,#0x10]
;;;588    }
000106  4770              BX       lr
;;;589    
                          ENDP

                  |L1.264|
                          DCD      0x40007800
                  |L1.268|
                          DCD      0x7000fe00

;*** Start embedded assembler ***

#line 1 "..\\arch\\arm\\stm32f05x\\lib\\src\\stm32f0xx_cec.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_cec_c_f294eadc____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f0xx_cec_c_f294eadc____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f0xx_cec_c_f294eadc____REVSH|
#line 144
|__asm___15_stm32f0xx_cec_c_f294eadc____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
