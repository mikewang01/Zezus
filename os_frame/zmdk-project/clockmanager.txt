; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\clockmanager.o --asm_dir=.\ --list_dir=.\ --depend=.\clockmanager.d --cpu=Cortex-M0 --apcs=interwork -I..\incs\asm-arm\stm32f0xx -I..\incs\kernel -I..\incs\driver -I..\incs\driver\stm32f051x -I..\task\usertask -I..\incs\driver\stm32f103x -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F0xx -DSTM32F051 --omf_browse=.\clockmanager.crf ..\kernel\clockmanager\clockmanager.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  os_clock_register PROC
;;;31      */
;;;32     os_err_t os_clock_register(Peripheral_clock *clock,   
000000  2800              CMP      r0,#0
;;;33                                const char  *name 
;;;34                                )   
;;;35     {   
000002  d002              BEQ      |L1.10|
;;;36         if (clock == NULL)   
;;;37             return ERROR;   
;;;38         
;;;39         
;;;40     #ifdef CLOCK_IN_ROM
;;;41         clock_list=&clock->parent;
000004  49a6              LDR      r1,|L1.672|
;;;42     #else
;;;43         if (os_object_find(clock_list,name) != NULL)//if this device has been registored return error  
;;;44             return ERROR;   
;;;45         clock->status = clock_closed;
;;;46         clock->last_status = clock_closed;
;;;47         
;;;48         os_object_init(&clock_list, &(clock->parent), OS_Object_Class_Clock , name);//???????,?????????????????????,??????   
;;;49     #endif    
;;;50         return SUCCESS;   
000006  6008              STR      r0,[r1,#0]  ; clock_list
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;51     }
00000a  4770              BX       lr
;;;52     
                          ENDP

                  os_clock_get PROC
;;;63      */	
;;;64     Peripheral_clock* os_clock_get(const char * name)  
00000c  b570              PUSH     {r4-r6,lr}
;;;65     {  
00000e  4605              MOV      r5,r0
;;;66         if(clock_list==NULL)
000010  48a3              LDR      r0,|L1.672|
000012  6804              LDR      r4,[r0,#0]  ; clock_list
000014  2c00              CMP      r4,#0
000016  d007              BEQ      |L1.40|
                  |L1.24|
;;;67         {
;;;68             return NULL;
;;;69         }	else
;;;70         {
;;;71             
;;;72     #ifdef CLOCK_IN_ROM	
;;;73             struct os_object *obj=clock_list;
;;;74             while(obj!=NULL)
;;;75             {
;;;76                 
;;;77                 if(strcmp(name,obj->name)==0)
000018  4621              MOV      r1,r4
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       strcmp
000020  2800              CMP      r0,#0
000022  d003              BEQ      |L1.44|
;;;78                 {
;;;79                     struct os_object *__mptr = (obj);
;;;80                     return ((Peripheral_clock *)( (char *)__mptr - offsetof(Peripheral_clock,parent)));
;;;81                 }
;;;82                 
;;;83                 obj++;			
000024  3410              ADDS     r4,r4,#0x10
000026  d1f7              BNE      |L1.24|
                  |L1.40|
;;;84                 
;;;85             }
;;;86     #else
;;;87             struct os_object *obj=os_object_find(clock_list,name);
;;;88             if(obj!=NULL)
;;;89             {
;;;90                 struct os_object *__mptr = (obj);
;;;91                 return ((Peripheral_clock *)( (char *)__mptr - offsetof(Peripheral_clock,parent)));
;;;92             }
;;;93     #endif
;;;94         }
;;;95         return NULL;
000028  2000              MOVS     r0,#0
;;;96     } 
00002a  bd70              POP      {r4-r6,pc}
                  |L1.44|
00002c  4620              MOV      r0,r4                 ;79
00002e  bd70              POP      {r4-r6,pc}
;;;97     
                          ENDP

                  os_clock_open PROC
;;;110     */	
;;;111    os_err_t os_clock_open(const char * name)  
000030  b570              PUSH     {r4-r6,lr}
;;;112    {  
000032  0004              MOVS     r4,r0
000034  d023              BEQ      |L1.126|
;;;113        if(name==NULL)
;;;114        {
;;;115            return NULL;
;;;116        }else if(strcmp(name,"ALL")==0) // this means open all clock registered
000036  a19b              ADR      r1,|L1.676|
000038  f7fffffe          BL       strcmp
;;;117        {
;;;118            
;;;119            struct os_object *__mptr=clock_list;
;;;120    #ifdef CLOCK_IN_ROM		
;;;121            while(__mptr!=NULL)
;;;122            {
;;;123                Peripheral_clock *phr_clock=((Peripheral_clock *)( (char *)__mptr - offsetof(Peripheral_clock,parent)));
;;;124                if(phr_clock->clock_enable!=NULL&&phr_clock->pstatus_record->status!=clock_opened)
;;;125                {
;;;126                    phr_clock->clock_enable();
;;;127                    
;;;128                    phr_clock->pstatus_record->last_status=phr_clock->pstatus_record->status; //save last status ;
00003c  25f3              MOVS     r5,#0xf3
00003e  2800              CMP      r0,#0                 ;116
000040  d01f              BEQ      |L1.130|
;;;129                    phr_clock->pstatus_record->status=clock_opened;
;;;130                }
;;;131                __mptr++;
;;;132            }
;;;133    #else
;;;134            while(__mptr!=NULL)
;;;135            {
;;;136                Peripheral_clock *phr_clock=((Peripheral_clock *)( (char *)__mptr - offsetof(Peripheral_clock,parent)));
;;;137                
;;;138                
;;;139                
;;;140                if(phr_clock->clock_enable!=NULL&&phr_clock->status!=clock_opened)
;;;141                {
;;;142                    phr_clock->clock_enable();
;;;143                    
;;;144                    
;;;145                    phr_clock->last_status=phr_clock->status; //save last status ;
;;;146                    phr_clock->status=clock_opened;
;;;147                }
;;;148                __mptr=__mptr->next;
;;;149            }
;;;150            
;;;151            
;;;152    #endif
;;;153        }else// initiate a specific device here
;;;154        {
;;;155            Peripheral_clock *phr_clock=os_clock_get(name);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       os_clock_get
000048  0004              MOVS     r4,r0
;;;156            
;;;157            if(phr_clock!=NULL)
00004a  d016              BEQ      |L1.122|
;;;158            {
;;;159                
;;;160                if(phr_clock->clock_enable!=NULL)
00004c  6960              LDR      r0,[r4,#0x14]
00004e  2800              CMP      r0,#0
000050  d013              BEQ      |L1.122|
;;;161                {
;;;162    #ifdef CLOCK_IN_ROM	
;;;163                    
;;;164                    if(phr_clock->pstatus_record->status!=clock_opened)
000052  69e1              LDR      r1,[r4,#0x1c]
000054  7809              LDRB     r1,[r1,#0]
000056  0789              LSLS     r1,r1,#30
000058  0f89              LSRS     r1,r1,#30
00005a  2901              CMP      r1,#1
00005c  d00d              BEQ      |L1.122|
;;;165    #else
;;;166                    if(phr_clock->status!=clock_opened)
;;;167    #endif
;;;168                    {
;;;169                        phr_clock->clock_enable();
00005e  4780              BLX      r0
;;;170                        
;;;171                        
;;;172    #ifdef CLOCK_IN_ROM	
;;;173                        
;;;174                        (phr_clock->pstatus_record->last_status)=phr_clock->pstatus_record->status; //save last status ;
000060  69e1              LDR      r1,[r4,#0x1c]
000062  7808              LDRB     r0,[r1,#0]
000064  4602              MOV      r2,r0
000066  0792              LSLS     r2,r2,#30
000068  4028              ANDS     r0,r0,r5
00006a  0f12              LSRS     r2,r2,#28
00006c  4310              ORRS     r0,r0,r2
00006e  7008              STRB     r0,[r1,#0]
;;;175                        (phr_clock->pstatus_record->status)=clock_opened;
000070  0880              LSRS     r0,r0,#2
000072  0080              LSLS     r0,r0,#2
000074  69e1              LDR      r1,[r4,#0x1c]
000076  1c40              ADDS     r0,r0,#1
000078  7008              STRB     r0,[r1,#0]
                  |L1.122|
;;;176    #else	
;;;177                        phr_clock->last_status=phr_clock->status; //save last status ;
;;;178                        phr_clock->status=clock_opened;
;;;179    #endif
;;;180                    }
;;;181                }
;;;182            }
;;;183            
;;;184        }
;;;185        return SUCCESS;
00007a  2001              MOVS     r0,#1
;;;186    } 
00007c  bd70              POP      {r4-r6,pc}
                  |L1.126|
00007e  2000              MOVS     r0,#0                 ;115
000080  bd70              POP      {r4-r6,pc}
                  |L1.130|
000082  4887              LDR      r0,|L1.672|
000084  6804              LDR      r4,[r0,#0]            ;121  ; clock_list
000086  e017              B        |L1.184|
                  |L1.136|
000088  6960              LDR      r0,[r4,#0x14]         ;124
00008a  2800              CMP      r0,#0                 ;124
00008c  d013              BEQ      |L1.182|
00008e  69e1              LDR      r1,[r4,#0x1c]         ;124
000090  7809              LDRB     r1,[r1,#0]            ;124
000092  0789              LSLS     r1,r1,#30             ;124
000094  0f89              LSRS     r1,r1,#30             ;124
000096  2901              CMP      r1,#1                 ;124
000098  d00d              BEQ      |L1.182|
00009a  4780              BLX      r0                    ;126
00009c  69e1              LDR      r1,[r4,#0x1c]         ;128
00009e  7808              LDRB     r0,[r1,#0]            ;128
0000a0  4602              MOV      r2,r0                 ;128
0000a2  0792              LSLS     r2,r2,#30             ;128
0000a4  4028              ANDS     r0,r0,r5              ;128
0000a6  0f12              LSRS     r2,r2,#28             ;128
0000a8  4310              ORRS     r0,r0,r2              ;128
0000aa  7008              STRB     r0,[r1,#0]            ;128
0000ac  0880              LSRS     r0,r0,#2              ;129
0000ae  0080              LSLS     r0,r0,#2              ;129
0000b0  69e1              LDR      r1,[r4,#0x1c]         ;129
0000b2  1c40              ADDS     r0,r0,#1              ;129
0000b4  7008              STRB     r0,[r1,#0]            ;129
                  |L1.182|
0000b6  3410              ADDS     r4,r4,#0x10           ;131
                  |L1.184|
0000b8  2c00              CMP      r4,#0                 ;121
0000ba  d1e5              BNE      |L1.136|
0000bc  e7dd              B        |L1.122|
;;;187    
                          ENDP

                  os_clock_close PROC
;;;198     */	
;;;199    os_err_t os_clock_close(const char * name)  
0000be  b570              PUSH     {r4-r6,lr}
;;;200    {  
0000c0  0004              MOVS     r4,r0
0000c2  d020              BEQ      |L1.262|
;;;201        if(name==NULL)
;;;202        {
;;;203            return NULL;
;;;204        }else if(strcmp(name,"ALL")==0) // this means open all clock registered
0000c4  a177              ADR      r1,|L1.676|
0000c6  f7fffffe          BL       strcmp
;;;205        {
;;;206            struct os_object *__mptr=clock_list;
;;;207    #ifdef CLOCK_IN_ROM		
;;;208            while(__mptr!=NULL)
;;;209            {
;;;210                Peripheral_clock *phr_clock=((Peripheral_clock *)( (char *)__mptr - offsetof(Peripheral_clock,parent)));
;;;211                if(phr_clock->clock_disable!=NULL&&phr_clock->pstatus_record->status!=clock_closed)
;;;212                {
;;;213                    phr_clock->clock_disable();
;;;214                    
;;;215                    phr_clock->pstatus_record->last_status=phr_clock->pstatus_record->status; //save last status ;
0000ca  25f3              MOVS     r5,#0xf3
0000cc  2800              CMP      r0,#0                 ;204
0000ce  d01c              BEQ      |L1.266|
;;;216                    phr_clock->pstatus_record->status=clock_closed;
;;;217                }
;;;218                __mptr++;
;;;219            }
;;;220    #else
;;;221            while(__mptr!=NULL)
;;;222            {
;;;223                Peripheral_clock *phr_clock=((Peripheral_clock *)( (char *)__mptr - offsetof(Peripheral_clock,parent)));
;;;224                
;;;225                //save last status 
;;;226                if(phr_clock->clock_disable!=NULL&&phr_clock->status!=clock_closed)
;;;227                {
;;;228                    phr_clock->clock_disable();
;;;229                    phr_clock->last_status=phr_clock->status; 
;;;230                    phr_clock->status=clock_closed; 
;;;231                }
;;;232                
;;;233                __mptr=__mptr->next;
;;;234            }
;;;235    #endif
;;;236        }else// initiate a specific device here
;;;237        {
;;;238            Peripheral_clock *phr_clock=os_clock_get(name);
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       os_clock_get
0000d6  0004              MOVS     r4,r0
;;;239            
;;;240            if(phr_clock!=NULL)
0000d8  d013              BEQ      |L1.258|
;;;241            {
;;;242                
;;;243                if(phr_clock->clock_disable!=NULL)
0000da  69a0              LDR      r0,[r4,#0x18]
0000dc  2800              CMP      r0,#0
0000de  d010              BEQ      |L1.258|
;;;244                {
;;;245    #ifdef CLOCK_IN_ROM	
;;;246                    if(phr_clock->pstatus_record->status!=clock_closed)
0000e0  69e1              LDR      r1,[r4,#0x1c]
0000e2  7809              LDRB     r1,[r1,#0]
0000e4  0789              LSLS     r1,r1,#30
0000e6  d00c              BEQ      |L1.258|
;;;247    #else
;;;248                    if(phr_clock->status!=clock_closed)
;;;249    #endif
;;;250                    { 
;;;251                        
;;;252                        phr_clock->clock_disable();
0000e8  4780              BLX      r0
;;;253    #ifdef CLOCK_IN_ROM	
;;;254                        phr_clock->pstatus_record->last_status=phr_clock->pstatus_record->status; //save last status ;
0000ea  69e1              LDR      r1,[r4,#0x1c]
0000ec  7808              LDRB     r0,[r1,#0]
0000ee  4602              MOV      r2,r0
0000f0  0792              LSLS     r2,r2,#30
0000f2  4028              ANDS     r0,r0,r5
0000f4  0f12              LSRS     r2,r2,#28
0000f6  4310              ORRS     r0,r0,r2
0000f8  7008              STRB     r0,[r1,#0]
;;;255                        phr_clock->pstatus_record->status=clock_closed;
0000fa  0880              LSRS     r0,r0,#2
0000fc  69e1              LDR      r1,[r4,#0x1c]
0000fe  0080              LSLS     r0,r0,#2
000100  7008              STRB     r0,[r1,#0]
                  |L1.258|
;;;256    #else	
;;;257                        phr_clock->last_status=phr_clock->status; 
;;;258                        phr_clock->status=clock_closed;
;;;259    #endif
;;;260                    }
;;;261                }
;;;262            }
;;;263        }
;;;264        return SUCCESS;
000102  2001              MOVS     r0,#1
;;;265    }
000104  bd70              POP      {r4-r6,pc}
                  |L1.262|
000106  2000              MOVS     r0,#0                 ;203
000108  bd70              POP      {r4-r6,pc}
                  |L1.266|
00010a  4865              LDR      r0,|L1.672|
00010c  6804              LDR      r4,[r0,#0]            ;208  ; clock_list
00010e  e014              B        |L1.314|
                  |L1.272|
000110  69a0              LDR      r0,[r4,#0x18]         ;211
000112  2800              CMP      r0,#0                 ;211
000114  d010              BEQ      |L1.312|
000116  69e1              LDR      r1,[r4,#0x1c]         ;211
000118  7809              LDRB     r1,[r1,#0]            ;211
00011a  0789              LSLS     r1,r1,#30             ;211
00011c  d00c              BEQ      |L1.312|
00011e  4780              BLX      r0                    ;213
000120  69e1              LDR      r1,[r4,#0x1c]         ;215
000122  7808              LDRB     r0,[r1,#0]            ;215
000124  4602              MOV      r2,r0                 ;215
000126  0792              LSLS     r2,r2,#30             ;215
000128  4028              ANDS     r0,r0,r5              ;215
00012a  0f12              LSRS     r2,r2,#28             ;215
00012c  4310              ORRS     r0,r0,r2              ;215
00012e  7008              STRB     r0,[r1,#0]            ;215
000130  0880              LSRS     r0,r0,#2              ;216
000132  69e1              LDR      r1,[r4,#0x1c]         ;216
000134  0080              LSLS     r0,r0,#2              ;216
000136  7008              STRB     r0,[r1,#0]            ;216
                  |L1.312|
000138  3410              ADDS     r4,r4,#0x10           ;218
                  |L1.314|
00013a  2c00              CMP      r4,#0                 ;208
00013c  d1e8              BNE      |L1.272|
00013e  e7e0              B        |L1.258|
;;;266    
                          ENDP

                  os_clock_restore PROC
;;;277     */	
;;;278    os_err_t os_clock_restore(const char * name)  
000140  b570              PUSH     {r4-r6,lr}
;;;279    {  
000142  0004              MOVS     r4,r0
000144  d024              BEQ      |L1.400|
;;;280        if(name==NULL)
;;;281        {
;;;282            return NULL;
;;;283        }else if(strcmp(name,"ALL")==0) // this means open all clock registered
000146  a157              ADR      r1,|L1.676|
000148  f7fffffe          BL       strcmp
;;;284        {
;;;285            struct os_object *__mptr=clock_list;
;;;286            u8 temp;
;;;287    #ifdef CLOCK_IN_ROM		
;;;288            while(__mptr!=NULL)
;;;289            {
;;;290                Peripheral_clock *phr_clock=((Peripheral_clock *)( (char *)__mptr - offsetof(Peripheral_clock,parent)));
;;;291                if(phr_clock->pstatus_record->last_status==clock_opened)
;;;292                {
;;;293                    if(phr_clock->clock_enable!=NULL)
;;;294                    {
;;;295                        phr_clock->clock_enable();
;;;296                    }		
;;;297                }else
;;;298                {
;;;299                    
;;;300                    if(phr_clock->clock_disable!=NULL)
;;;301                    {
;;;302                        phr_clock->clock_disable();
;;;303                    }	
;;;304                }	
;;;305                temp                   =	 phr_clock->pstatus_record->last_status;					 
;;;306                phr_clock->pstatus_record->last_status =   phr_clock->pstatus_record->status;
00014c  25f3              MOVS     r5,#0xf3
00014e  2800              CMP      r0,#0                 ;283
000150  d020              BEQ      |L1.404|
;;;307                phr_clock->pstatus_record->status      =   temp;		
;;;308                __mptr                 =   __mptr->next;
;;;309                
;;;310                __mptr++;
;;;311            }
;;;312    #else
;;;313            while(__mptr!=NULL)
;;;314            {
;;;315                Peripheral_clock *phr_clock=((Peripheral_clock *)( (char *)__mptr - offsetof(Peripheral_clock,parent)));
;;;316                u8 temp;
;;;317                if(phr_clock->last_status==clock_opened)
;;;318                {
;;;319                    if(phr_clock->clock_enable!=NULL)
;;;320                    {
;;;321                        phr_clock->clock_enable();
;;;322                    }		
;;;323                }else
;;;324                {
;;;325                    
;;;326                    if(phr_clock->clock_disable!=NULL)
;;;327                    {
;;;328                        phr_clock->clock_disable();
;;;329                    }	
;;;330                }	
;;;331                
;;;332                temp                   =	 phr_clock->last_status;					 
;;;333                phr_clock->last_status =   phr_clock->status;
;;;334                phr_clock->status      =   temp;		
;;;335                __mptr                 =   __mptr->next;
;;;336            }
;;;337    #endif
;;;338        }else// initiate a specific device here
;;;339        {  
;;;340            Peripheral_clock *phr_clock=os_clock_get(name);
000152  4620              MOV      r0,r4
000154  f7fffffe          BL       os_clock_get
000158  4604              MOV      r4,r0
;;;341            u8 temp;
;;;342    #ifdef CLOCK_IN_ROM		
;;;343            if(phr_clock->pstatus_record->last_status==clock_opened)
00015a  69c0              LDR      r0,[r0,#0x1c]
00015c  7800              LDRB     r0,[r0,#0]
00015e  0700              LSLS     r0,r0,#28
000160  0f80              LSRS     r0,r0,#30
000162  2801              CMP      r0,#1
000164  d039              BEQ      |L1.474|
;;;344            {
;;;345                if(phr_clock->clock_enable!=NULL)
;;;346                {
;;;347                    phr_clock->clock_enable();
;;;348                }		
;;;349            }else
;;;350            {
;;;351                
;;;352                if(phr_clock->clock_disable!=NULL)
000166  69a0              LDR      r0,[r4,#0x18]
                  |L1.360|
000168  2800              CMP      r0,#0
00016a  d000              BEQ      |L1.366|
;;;353                {
;;;354                    phr_clock->clock_disable();
00016c  4780              BLX      r0
                  |L1.366|
;;;355                }	
;;;356            }	
;;;357            
;;;358            temp                   =	 phr_clock->pstatus_record->last_status;					 
00016e  69e2              LDR      r2,[r4,#0x1c]
000170  7810              LDRB     r0,[r2,#0]
000172  0701              LSLS     r1,r0,#28
000174  0f8b              LSRS     r3,r1,#30
000176  4601              MOV      r1,r0
;;;359            phr_clock->pstatus_record->last_status =   phr_clock->pstatus_record->status;
000178  0780              LSLS     r0,r0,#30
00017a  4029              ANDS     r1,r1,r5
00017c  0f00              LSRS     r0,r0,#28
00017e  4301              ORRS     r1,r1,r0
000180  7011              STRB     r1,[r2,#0]
;;;360            phr_clock->pstatus_record->status      =   temp;
000182  0889              LSRS     r1,r1,#2
000184  0089              LSLS     r1,r1,#2
000186  69e0              LDR      r0,[r4,#0x1c]
000188  4319              ORRS     r1,r1,r3
00018a  7001              STRB     r1,[r0,#0]
                  |L1.396|
;;;361            
;;;362    #else
;;;363            
;;;364            if(phr_clock->last_status==clock_opened)
;;;365            {
;;;366                if(phr_clock->clock_enable!=NULL)
;;;367                {
;;;368                    phr_clock->clock_enable();
;;;369                }		
;;;370            }else
;;;371            {
;;;372                
;;;373                if(phr_clock->clock_disable!=NULL)
;;;374                {
;;;375                    phr_clock->clock_disable();
;;;376                }	
;;;377            }	
;;;378            
;;;379            temp                   =	 phr_clock->last_status;					 
;;;380            phr_clock->last_status =   phr_clock->status;
;;;381            phr_clock->status      =   temp;
;;;382    #endif								
;;;383        }
;;;384        return SUCCESS;
00018c  2001              MOVS     r0,#1
;;;385    }
00018e  bd70              POP      {r4-r6,pc}
                  |L1.400|
000190  2000              MOVS     r0,#0                 ;282
000192  bd70              POP      {r4-r6,pc}
                  |L1.404|
000194  4842              LDR      r0,|L1.672|
000196  6804              LDR      r4,[r0,#0]            ;288  ; clock_list
000198  e01a              B        |L1.464|
                  |L1.410|
00019a  69e0              LDR      r0,[r4,#0x1c]         ;291
00019c  7800              LDRB     r0,[r0,#0]            ;291
00019e  0700              LSLS     r0,r0,#28             ;291
0001a0  0f80              LSRS     r0,r0,#30             ;291
0001a2  2801              CMP      r0,#1                 ;291
0001a4  d017              BEQ      |L1.470|
0001a6  69a0              LDR      r0,[r4,#0x18]         ;300
                  |L1.424|
0001a8  2800              CMP      r0,#0                 ;300
0001aa  d000              BEQ      |L1.430|
0001ac  4780              BLX      r0                    ;302
                  |L1.430|
0001ae  69e2              LDR      r2,[r4,#0x1c]         ;305
0001b0  7810              LDRB     r0,[r2,#0]            ;305
0001b2  0701              LSLS     r1,r0,#28             ;305
0001b4  0f8b              LSRS     r3,r1,#30             ;305
0001b6  4601              MOV      r1,r0                 ;305
0001b8  0780              LSLS     r0,r0,#30             ;306
0001ba  4029              ANDS     r1,r1,r5              ;306
0001bc  0f00              LSRS     r0,r0,#28             ;306
0001be  4301              ORRS     r1,r1,r0              ;306
0001c0  7011              STRB     r1,[r2,#0]            ;306
0001c2  0889              LSRS     r1,r1,#2              ;307
0001c4  0089              LSLS     r1,r1,#2              ;307
0001c6  69e0              LDR      r0,[r4,#0x1c]         ;307
0001c8  4319              ORRS     r1,r1,r3              ;307
0001ca  7001              STRB     r1,[r0,#0]            ;307
0001cc  68e4              LDR      r4,[r4,#0xc]          ;308
0001ce  3410              ADDS     r4,r4,#0x10           ;310
                  |L1.464|
0001d0  2c00              CMP      r4,#0                 ;288
0001d2  d1e2              BNE      |L1.410|
0001d4  e7da              B        |L1.396|
                  |L1.470|
0001d6  6960              LDR      r0,[r4,#0x14]         ;293
0001d8  e7e6              B        |L1.424|
                  |L1.474|
0001da  6960              LDR      r0,[r4,#0x14]         ;345
0001dc  e7c4              B        |L1.360|
;;;386    
                          ENDP

                  MY_NVIC_SetVectorTable PROC
;;;387    
;;;388    void MY_NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)	 
0001de  4770              BX       lr
;;;389    { 	   	 
;;;390        
;;;391    }
;;;392    //设置NVIC分组
                          ENDP

                  MY_NVIC_PriorityGroupConfig PROC
;;;393    //NVIC_Group:NVIC分组 0~4 总共5组 		   
;;;394    void MY_NVIC_PriorityGroupConfig(u8 NVIC_Group)	 
0001e0  2107              MOVS     r1,#7
;;;395    { 
;;;396        u32 temp,temp1;	  
;;;397        temp1=(~NVIC_Group)&0x07;//取后三位
;;;398        temp1<<=8;
;;;399        temp=SCB->AIRCR;  //读取先前的设置
0001e2  4a31              LDR      r2,|L1.680|
0001e4  4381              BICS     r1,r1,r0              ;397
0001e6  68d0              LDR      r0,[r2,#0xc]
0001e8  0209              LSLS     r1,r1,#8              ;398
;;;400        temp&=0X0000F8FF; //清空先前分组
0001ea  4b30              LDR      r3,|L1.684|
0001ec  4018              ANDS     r0,r0,r3
;;;401        temp|=0X05FA0000; //写入钥匙
0001ee  4b30              LDR      r3,|L1.688|
0001f0  4318              ORRS     r0,r0,r3
;;;402        temp|=temp1;	   
0001f2  4308              ORRS     r0,r0,r1
;;;403        SCB->AIRCR=temp;  //设置分组	    	  				   
0001f4  60d0              STR      r0,[r2,#0xc]
;;;404    }
0001f6  4770              BX       lr
;;;405    //设置NVIC 
                          ENDP

                  MY_NVIC_Init PROC
;;;417    //NVIC_SubPriority和NVIC_PreemptionPriority的原则是,数值越小,越优先	   
;;;418    void MY_NVIC_Init(u8 NVIC_PreemptionPriority,u8 NVIC_SubPriority,u8 NVIC_Channel,u8 NVIC_Group)	 
0001f8  b5f0              PUSH     {r4-r7,lr}
;;;419    { 
0001fa  4605              MOV      r5,r0
0001fc  4614              MOV      r4,r2
0001fe  460f              MOV      r7,r1
000200  461e              MOV      r6,r3
;;;420        u32 temp;	
;;;421        MY_NVIC_PriorityGroupConfig(NVIC_Group);//设置分组
000202  4618              MOV      r0,r3
000204  f7fffffe          BL       MY_NVIC_PriorityGroupConfig
;;;422        temp=NVIC_PreemptionPriority<<(4-NVIC_Group);	  
000208  2004              MOVS     r0,#4
00020a  1b80              SUBS     r0,r0,r6
00020c  4085              LSLS     r5,r5,r0
;;;423        temp|=NVIC_SubPriority&(0x0f>>NVIC_Group);
00020e  200f              MOVS     r0,#0xf
000210  40f0              LSRS     r0,r0,r6
000212  4038              ANDS     r0,r0,r7
000214  4328              ORRS     r0,r0,r5
;;;424        temp&=0xf;//取低四位  
000216  0701              LSLS     r1,r0,#28
;;;425        NVIC->ISER[NVIC_Channel/32]|=(1<<NVIC_Channel%32);//使能中断位(要清除的话,相反操作就OK) 
000218  0960              LSRS     r0,r4,#5
00021a  0082              LSLS     r2,r0,#2
00021c  4825              LDR      r0,|L1.692|
00021e  1810              ADDS     r0,r2,r0
000220  6802              LDR      r2,[r0,#0]
000222  06e5              LSLS     r5,r4,#27
000224  0eed              LSRS     r5,r5,#27
000226  2301              MOVS     r3,#1
000228  40ab              LSLS     r3,r3,r5
00022a  431a              ORRS     r2,r2,r3
00022c  6002              STR      r2,[r0,#0]
;;;426        NVIC->IP[NVIC_Channel]|=temp<<4;//设置响应优先级和抢断优先级   	    	  				   
00022e  4822              LDR      r0,|L1.696|
000230  00a2              LSLS     r2,r4,#2
000232  1810              ADDS     r0,r2,r0
000234  6802              LDR      r2,[r0,#0]
000236  0e09              LSRS     r1,r1,#24
000238  430a              ORRS     r2,r2,r1
00023a  6002              STR      r2,[r0,#0]
;;;427    } 
00023c  bdf0              POP      {r4-r7,pc}
;;;428    //外部中断配置函数
                          ENDP

                  Ex_NVIC_Config PROC
;;;435    //该函数会自动开启对应中断,以及屏蔽线   	    
;;;436    void Ex_NVIC_Config(u8 GPIOx,u8 BITx,u8 TRIM) 
00023e  4770              BX       lr
;;;437    {
;;;438        
;;;439    } 	  
;;;440    //不能在这里执行所有外设复位!否则至少引起串口不工作.		    
                          ENDP

                  MYRCC_DeInit PROC
;;;441    //把所有时钟寄存器复位		  
;;;442    void MYRCC_DeInit(void)
000240  4770              BX       lr
;;;443    {	
;;;444        
;;;445    }
;;;446    
                          ENDP

                  Sys_Soft_Reset PROC
;;;448    //系统软复位   
;;;449    void Sys_Soft_Reset(void)
000242  481b              LDR      r0,|L1.688|
;;;450    {   
;;;451        SCB->AIRCR =0X05FA0000|(u32)0x04;	  
000244  4918              LDR      r1,|L1.680|
000246  1d00              ADDS     r0,r0,#4
000248  60c8              STR      r0,[r1,#0xc]
;;;452    } 		 
00024a  4770              BX       lr
;;;453    //JTAG模式设置,用于设置JTAG的模式
                          ENDP

                  JTAG_Set PROC
;;;457    //#define JTAG_SWD_ENABLE    0X00		  
;;;458    void JTAG_Set(u8 mode)
00024c  4770              BX       lr
;;;459    {
;;;460        
;;;461    } 
;;;462    
                          ENDP

                  WFI_SET PROC
;;;464    
;;;465    void WFI_SET(void)
00024e  bf30              WFI      
;;;466    
;;;467    {
;;;468        
;;;469        __WFI();
;;;470        
;;;471    }
000250  4770              BX       lr
;;;472    
                          ENDP

                  Sys_Standby PROC
;;;474    
;;;475    void Sys_Standby(u8 var)
000252  491a              LDR      r1,|L1.700|
;;;476    {
;;;477        
;;;478        
;;;479        
;;;480        RCC->APB1ENR |= 1<<28;             //open power reggitor 
000254  69ca              LDR      r2,[r1,#0x1c]
000256  040b              LSLS     r3,r1,#16
000258  431a              ORRS     r2,r2,r3
00025a  61ca              STR      r2,[r1,#0x1c]
;;;481        
;;;482        switch(var)
;;;483            
;;;484        {
;;;485        
;;;486        case sleepmode:{ break; }           //WFI??????
;;;487            
;;;488        case stopmode:{                    //PDDS+LPDS+SLEEPDEEP+WFI??????
;;;489            SCB->SCR |= 1<<2;      //??SLEEPDEEP? (SYS->CTRL)          
00025c  2204              MOVS     r2,#4
;;;490            
;;;491            PWR->CR  |= 1<<0;      //LPDS??   
00025e  4918              LDR      r1,|L1.704|
000260  2800              CMP      r0,#0                 ;482
000262  d012              BEQ      |L1.650|
000264  4b10              LDR      r3,|L1.680|
000266  2801              CMP      r0,#1                 ;482
000268  d002              BEQ      |L1.624|
00026a  2802              CMP      r0,#2                 ;482
00026c  d10d              BNE      |L1.650|
00026e  e005              B        |L1.636|
                  |L1.624|
000270  6918              LDR      r0,[r3,#0x10]         ;489
000272  4310              ORRS     r0,r0,r2              ;489
000274  6118              STR      r0,[r3,#0x10]         ;489
000276  6808              LDR      r0,[r1,#0]
000278  2301              MOVS     r3,#1
;;;492            
;;;493            
;;;494            break;         
00027a  e004              B        |L1.646|
                  |L1.636|
;;;495        }
;;;496            
;;;497        case standbymode:{                    //PDDS+SLEEPDEEP+WFI??????
;;;498            SCB->SCR |= 1<<2;      //??SLEEPDEEP? (SYS->CTRL)
00027c  6918              LDR      r0,[r3,#0x10]
00027e  4310              ORRS     r0,r0,r2
000280  6118              STR      r0,[r3,#0x10]
;;;499            
;;;500            PWR->CR|=1<<1;          //PDDS??  
000282  6808              LDR      r0,[r1,#0]
000284  2302              MOVS     r3,#2
                  |L1.646|
000286  4318              ORRS     r0,r0,r3              ;491
000288  6008              STR      r0,[r1,#0]            ;491
                  |L1.650|
;;;501            
;;;502            break;         
;;;503            
;;;504        }
;;;505            
;;;506        }
;;;507        
;;;508        PWR->CR  |= 1<<2;                  //clear Wake-up flags
00028a  6808              LDR      r0,[r1,#0]
00028c  4310              ORRS     r0,r0,r2
00028e  6008              STR      r0,[r1,#0]
;;;509        PWR->CSR |= 1<<8;                  //设置WKUP用于唤醒
000290  6848              LDR      r0,[r1,#4]
000292  22ff              MOVS     r2,#0xff
000294  3201              ADDS     r2,#1
000296  4310              ORRS     r0,r0,r2
000298  6048              STR      r0,[r1,#4]
00029a  bf30              WFI      
;;;510        
;;;511        WFI_SET();                      //??WFI??       
;;;512    }
00029c  4770              BX       lr
;;;513    
                          ENDP

00029e  0000              DCW      0x0000
                  |L1.672|
                          DCD      ||.data||
                  |L1.676|
0002a4  414c4c00          DCB      "ALL",0
                  |L1.680|
                          DCD      0xe000ed00
                  |L1.684|
                          DCD      0x0000f8ff
                  |L1.688|
                          DCD      0x05fa0000
                  |L1.692|
                          DCD      0xe000e100
                  |L1.696|
                          DCD      0xe000e400
                  |L1.700|
                          DCD      0x40021000
                  |L1.704|
                          DCD      0x40007000

                          AREA ||.data||, DATA, ALIGN=2

                  clock_list
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\kernel\\clockmanager\\clockmanager.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_clockmanager_c_19059168____REV16|
#line 129 "d:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_clockmanager_c_19059168____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_clockmanager_c_19059168____REVSH|
#line 144
|__asm___14_clockmanager_c_19059168____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
