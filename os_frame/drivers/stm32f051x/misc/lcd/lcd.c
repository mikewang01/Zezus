/***************************************************************
 * Name:      USART.c
 * Purpose:   code for lenth sample  to store and send
 * Author:    mikewang(s)
 * Created:   2014-06-12
 * Copyright: mikewang(mikewang01@hotmail.com)
 * License:
 **************************************************************/

/*********************************************************************
 * INCLUDES
 */

#include "stdio.h"
#include "spi.h"

#include "kernel-includes.h"
#include "drivers-includes.h"
#include "lcd.h"
/*********************************************************************
* MACROS
*/


#define LCD_NAME 			 "LCD"
#define BUS_INTERFACE   "SPI1"

#define LCD_CS_PORT        GPIOA
#define LCD_PIN_CS        15

#define LCD_RS_PORT        GPIOB
#define LCD_PIN_RS        4

#define LCD_RESET_PORT     GPIOB
#define LCD_PIN_REST      6
/*********************************************************************
 * TYPEDEFS
 */

enum font_type{font6x8_t , font16x8_t};

/*********************************************************************
 * GLOBAL VARIABLES
 */


/*********************************************************************
 * LOCAL VARIABLES
 */
static lcd_device  *lcd_dev=NULL;
static os_device_t *bus_dev=NULL;

#ifdef _FONT6X8_

static const unsigned char  font6x8[][6] ;

#else

#ifdef __FONT_16X8_

static const  unsigned char font16x8[][16];	

#endif

#endif


/*define lcd buffer*/
//lcd data stored format
//[0]0 1 2 3 ... 127	
//[1]0 1 2 3 ... 127	
//[2]0 1 2 3 ... 127	
//[3]0 1 2 3 ... 127	
//[4]0 1 2 3 ... 127	
//[5]0 1 2 3 ... 127	
//[6]0 1 2 3 ... 127	
//[7]0 1 2 3 ... 127
#ifdef _LCD_BUFFER_USING_
static u8 lcd_dram_buffer[LCD_X_SOLUTON][LCD_Y_SOLUTON>>3]={0};
#endif
/*********************************************************************
 * LOCAL function declarement
 */
static  os_err_t   transfer_data       (u8 data);

static  os_err_t   transfer_command    (u8 cmd); 

  void       clear_screen        (u8 data); 


static  os_err_t   lcd_init            (os_device_t* dev);

static  os_size_t  lcd_write           (os_device_t* dev, os_off_t pos, const void *buffer, os_size_t size);

static os_err_t    lcd_control         (os_device_t* dev, u8 cmd, void *args);

static  os_err_t   lcd_open            (os_device_t* dev, u16 oflag);

static os_err_t    lcd_showstring      (u8 x,u8 y ,  const u8 *p , u16 size_1);

 void       lcd_refresh_buffer   (void);
/*********************************************************************
 * @fn      os_err_t os_device_init_all
 *
 * @brief   This function initiate all the device registered
 *
 * 			    @param none 
 *			
 * 
 *   @return the error code, success on initialization successfully. 
 */

os_err_t lcd_register(u16 task_id)
{
    
    lcd_dev=osmalloc(sizeof(lcd_device));
    
    
    lcd_dev->os_device.type = OS_Device_Class_MTD;
    
    lcd_dev->os_device.device_id = OS_DEVICE_USART_ID;
    
    lcd_dev->register_taskid = task_id;
    
    lcd_dev->lcd_solution.x_pixel=LCD_X_SOLUTON;
    
    lcd_dev->lcd_solution.y_pixel=LCD_Y_SOLUTON;
    
    lcd_dev->lcd_scan_mode.x_direction=LCD_LEFT2RIGHT;
    
    lcd_dev->lcd_scan_mode.y_direction=LCD_DOWN2UP;
    
    lcd_dev->cursor_record.x_cord=0;
    lcd_dev->cursor_record.y_cord=0;
    
    /*set font by macros*/    
#ifdef _FONT6X8_
    
    
    lcd_dev->font.font_type = font6x8_t;
    lcd_dev->font.font_ptr  = (u8 (*)[6])font6x8;
    lcd_dev->font.font_x_model = FONT_X_MODEL;
    lcd_dev->font.font_y_model = FONT_Y_MODEL;
#else
    
#ifdef __FONT_16X8_
    
    lcd_dev->font.font_type = font16x8_t;
    lcd_dev->font.font_ptr  = (u8 (*)[16])font16x8;
    lcd_dev->font.font_x_model = FONT_X_MODEL;
    lcd_dev->font.font_y_model = FONT_Y_MODEL;
#endif
    
#endif
    
    
    /*set lcd buffer pointer if not used set buffer pionter to NULL*/  
#ifdef _LCD_BUFFER_USING_
    lcd_dev->buffer = lcd_dram_buffer;
#else
    lcd_dev->buffer=NULL;
#endif  
    
    
    lcd_dev->current_status = lcd_reset;
    
    lcd_dev->os_device.init  = lcd_init;
    
    lcd_dev->os_device.open  = lcd_open;
    
    lcd_dev->os_device.write = lcd_write;
    
    lcd_dev->os_device.control = lcd_control;
    
    
    return os_device_register(&(lcd_dev->os_device), LCD_NAME, OS_DEVICE_FLAG_INACTIVATED);
    
}
/*********************************************************************
 * @fn      os_err_t uart1_init
 *
 * @brief   This function initiate device uaart1
 *
 * 			    @param none 
 *			
 * 
 *   @return the error code, success on initialization successfully. 
* nition!! before U configure any register ,opening clock first
 */
/*********************LCD 延时1ms************************************/
static void lcd_delay_ms(unsigned int ms)
	{                         
		unsigned int a;
		while(ms)
		{
			a=1800;
			while(a--);
			ms--;
		}
	 return;
	}
static os_err_t  lcd_init   (os_device_t* dev)
{  	 
    

    os_clock_open("GPIOB");
    
    
    
    /* Speed mode configuration */
    gpio_speed_set(LCD_CS_PORT , LCD_PIN_CS ,  GPIO_Speed_50MHz );
    
    gpio_speed_set(LCD_RS_PORT, LCD_PIN_RS, GPIO_Speed_50MHz );
    
	  gpio_speed_set(LCD_RESET_PORT, LCD_PIN_REST, GPIO_Speed_50MHz );
    
    /* Output mode configuration */
    gpio_outtype_set(LCD_CS_PORT , LCD_PIN_CS , GPIO_OType_PP);  
    gpio_outtype_set(LCD_RS_PORT , LCD_PIN_RS , GPIO_OType_PP);  
	  gpio_outtype_set(LCD_RESET_PORT, LCD_PIN_REST, GPIO_OType_PP);
    
	
    gpio_outmode_set(LCD_CS_PORT , LCD_PIN_CS , GPIO_Mode_OUT); 
    gpio_outmode_set(LCD_RS_PORT , LCD_PIN_RS ,  GPIO_Mode_OUT);
    gpio_outmode_set(LCD_RESET_PORT , LCD_PIN_REST ,  GPIO_Mode_OUT);
		
    /* Pull-up Pull down resistor configuration */
    gpio_pupdr_set(LCD_CS_PORT , LCD_PIN_CS , GPIO_PuPd_UP);    
    gpio_pupdr_set(LCD_RS_PORT , LCD_PIN_RS , GPIO_PuPd_UP);
    gpio_pupdr_set(LCD_RESET_PORT , LCD_PIN_REST , GPIO_PuPd_UP);
		
		LCD_RESET_PORT->BRR =1<<LCD_PIN_REST;
		
		lcd_delay_ms(1000);
		LCD_RESET_PORT->BSRR = 1<<LCD_PIN_REST;
		
    bus_dev= os_device_get("SPI1");
    
    if(bus_dev==NULL)
    {
        transfer_command(0xe2);   /*???*/ 
    }
    
//    lcd_software_reset();
//    
//    lcd_powercontraist_set();
//    
//    lcd_set_scroll_directon(lcd_dev->lcd_scan_mode.x_direction , lcd_dev->lcd_scan_mode.y_direction);
//    
//    lcd_display_on_off(LCD_DISPLAY_ON);
//    
//    lcd_dev->current_status = lcd_normal ;
    
    
    
    
    //	 os_clock_open(BUS_INTERFACE);
    //	 os_clock_open("GPIOB");
		transfer_command(0xae);//--turn off oled panel
		transfer_command(0x00);//---set low column address
		transfer_command(0x10);//---set high column address
		transfer_command(0x40);//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)
		transfer_command(0x81);//--set contrast control register
		transfer_command(0xcf); // Set SEG Output Current Brightness
		transfer_command(0xa0);//--Set SEG/Column Mapping     0xa0左右反置 0xa1正常
		transfer_command(0xc8);//Set COM/Row Scan Direction   0xc0上下反置 0xc8正常
		transfer_command(0xa6);//--set normal display
		transfer_command(0xa8);//--set multiplex ratio(1 to 64)
		transfer_command(0x3f);//--1/64 duty 若是128*32 transfer_command(0x1F);
		transfer_command(0xd3);//-set display offset	Shift Mapping RAM Counter (0x00~0x3F)
		transfer_command(0x00);//-not offset
		transfer_command(0xd5);//--set display clock divide ratio/oscillator frequency
		transfer_command(0x80);//--set divide ratio, Set Clock as 100 Frames/Sec
		transfer_command(0xd9);//--set pre-charge period
		transfer_command(0xf1);//Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
		transfer_command(0xda);//--set com pins hardware configuration
		transfer_command(0x12);
		transfer_command(0xdb);//--set vcomh
		transfer_command(0x40);//Set VCOM Deselect Level
		transfer_command(0x20);//-Set Page Addressing Mode (0x00/0x01/0x02)  若是128*32 transfer_command(0x02);*/ 
		transfer_command(0x02);//
		transfer_command(0x8d);//--set Charge Pump enable/disable
		transfer_command(0x14);//--set(0x10) disable
		transfer_command(0xa4);// Disable Entire Display On (0xa4/0xa5)
		transfer_command(0xa6);// Disable Inverse Display On (0xa6/a7) 
		transfer_command(0xaf);//--turn on oled panel
		lcd_refresh_buffer();
	 	clear_screen(0x00);  //初始清屏	
    
    return SUCCESS;
    
    
}


/*********************************************************************
 * @fn      os_err_t uart2_open
 *
 * @brief   This function initiate all the device registered
 *
 * 			    @param none 
 *			
 * 
 *   @return the error code, success on initialization successfully. 
 */
static os_err_t  lcd_open(os_device_t* dev, u16 oflag)
{
    os_clock_open(BUS_INTERFACE);
    os_clock_open("GPIOB");
    os_clock_open("GPIOA");
    return SUCCESS;	
}

/*********************************************************************
 * @fn      os_err_t uart2_close
 *
 * @brief   This function initiate all the device registered
 *
 * 			    @param none 
 *			
 * 
 *   @return the error code, success on initialization successfully. 
 */
static os_err_t  lcd_close(os_device_t* dev, u16 oflag)
{
    
    os_clock_close(BUS_INTERFACE);
    os_clock_open("GPIOB");
    os_clock_open("GPIOA");;
    
    return SUCCESS;		
    
}
/*********************************************************************
 * @fn      os_err_t uart2_write(os_device_t* dev, os_off_t pos, const void *buffer, os_size_t size)
 *
 * @brief   This function is write driver for uart2
 *
* 			    @param dev: device poniter 
*								   pos: offset in the data
*									 buffer: data need tansfering
* 								 size: data size tansfered
 *   @return number of data transfered
 */

static os_size_t  lcd_write(os_device_t* dev, os_off_t pos, const void *buffer, os_size_t size)
{
    
    if(pos>=size||buffer==NULL||size>USART_TX_BUFFER_SIZE)
    {
        return  NULL;
    }else
    {
        lcd_showstring((pos/LCD_X_SOLUTON)*8 , pos%LCD_X_SOLUTON   , buffer , size );
        lcd_refresh_buffer();
    }
    
    return SUCCESS;
}	


/*********************************************************************
 * @fn      os_err_t relays_control(os_device_t* dev, u8 cmd, void *args)
 *
 * @brief   This function is write driver for uart1
 *
* 			    @param dev: device poniter 
*								   pos: offset in the data
*									 buffer: data need tansfering
* 								 size: data size tansfered
 *   @return number of data transfered
 */

static os_err_t  lcd_control(os_device_t* dev, u8 cmd, void *args)
{
    u8 clear_data=((u8*)args)[1];
    
    if(dev==NULL)
    {
        return ERROR;
    }
    switch(cmd)
    {
    case lcd_command:  	  break;
        
    case lcd_x_inv: 	/* change the state recorded in device pcb*/         
        if(lcd_dev->lcd_scan_mode.x_direction == LCD_LEFT2RIGHT )
        {
            lcd_dev->lcd_scan_mode.x_direction = LCD_RIGHT2LEFT;
        }else
        {
            lcd_dev->lcd_scan_mode.x_direction = LCD_LEFT2RIGHT;
        }
        lcd_set_scroll_directon(lcd_dev->lcd_scan_mode.x_direction , lcd_dev->lcd_scan_mode.y_direction);				
        break;
        
    case lcd_y_inv:      /* change the state recorded in device pcb*/         
        if(lcd_dev->lcd_scan_mode.y_direction == LCD_UP2DOWN )
        {
            lcd_dev->lcd_scan_mode.y_direction = LCD_DOWN2UP ;
        }else
        {
            lcd_dev->lcd_scan_mode.y_direction = LCD_UP2DOWN;
        }
        lcd_set_scroll_directon(lcd_dev->lcd_scan_mode.x_direction , lcd_dev->lcd_scan_mode.y_direction);				
        break; 
        
    case lcd_clear:      clear_screen(clear_data); break;
        
    case lcd_pwrdown:     break;
        
    case lcd_wakeup:     break;
        /*refresh buffer data to lcd*/															
    case lcd_refresh:  lcd_refresh_buffer(); break;
    
    //case lcd_reset:				;
    default:break;
        
    }
    return SUCCESS;
}

/*********************************************************************
 * @fn      os_err_t transfer_command(u8 cmd) 
 *
 * @brief   This function is write driver for uart1
 *
* 			    @param dev: device poniter 
*								   pos: offset in the data
*									 buffer: data need tansfering
* 								 size: data size tansfered
 *   @return number of data transfered
 */


static os_err_t transfer_command(u8 cmd) 
{ 
    u8 status;
    /* SELECT LCD DEVICE*/	
    LCD_CS_PORT->BRR=BIT_SHIFT(LCD_PIN_CS);
    
    /* COMMAND MODE PULL RS LOW */	
    LCD_RS_PORT->BRR=BIT_SHIFT(LCD_PIN_RS);
    
 
    status=os_device_write(bus_dev, 0, &cmd, 1);   
    
    //		LCD_PORT->BSRR=BIT_SHIFT(LCD_PIN_CS);
    return status;
} 


/*********************************************************************
 * @fn      os_err_t  transfer_data(u8 data) 
 *
 * @brief   This function is write driver for uart1
 *
* 			    @param dev: device poniter 
*								   pos: offset in the data
*									 buffer: data need tansfering
* 								 size: data size tansfered
 *   @return number of data transfered
 */
static os_err_t transfer_data(u8 data) 
{ 
    u8 status;
    
    LCD_CS_PORT->BRR=BIT_SHIFT(LCD_PIN_CS);
    
    LCD_RS_PORT->BSRR=BIT_SHIFT(LCD_PIN_RS);

    status=os_device_write(bus_dev, 0, &data, 1);  
    
    //	 LCD_PORT->BSRR=BIT_SHIFT(LCD_PIN_CS);
    return status;
} 

/*********************************************************************
 * @fn      os_err_t  transfer_data(u8 data) 
 *
 * @brief   This function is write driver for uart1
 *
* 			    @param dev: device poniter 
*								   pos: offset in the data
*									 buffer: data need tansfering
* 								 size: data size tansfered
 *   @return number of data transfered
 */

 void clear_screen(u8 data) 
{
    unsigned char i,n;
    LCD_CS_PORT->BRR=BIT_SHIFT(LCD_PIN_CS);	
    for(i=0 ; i<((lcd_dev->lcd_solution.y_pixel)>>3) ; i++)  
    {  
        /*set refresh cursor*/
        lcd_position_set(0 , i);
        
        for(n=0 ; n<lcd_dev->lcd_solution.x_pixel ; n++)
            
            lcd_dev->buffer[n][i]=data; 
        transfer_data(lcd_dev->buffer[n][i]);
        
        
    }   
    
}

/*********************************************************************
 * @fn      os_err_t  transfer_data(u8 data) 
 *
 * @brief   This function is write driver for uart1
 *
* 			    @param dev: device poniter 
*								   pos: offset in the data
*									 buffer: data need tansfering
* 								 size: data size tansfered
*   @return number of data transfered
*/



 void lcd_refresh_buffer(void)
{
    u16 i,n;		    
    for(i=0 ; i< ((lcd_dev->lcd_solution.y_pixel)>>3) ; i++)  
    {  
        /*set refresh cursor*/
        lcd_position_set(0 , i);
        for(n=0 ; n<lcd_dev->lcd_solution.x_pixel ; n++)
            
            transfer_data(lcd_dev->buffer[n][i]);
        
    }   
}


/*********************************************************************
 * @fn      os_err_t  transfer_data(u8 data) 
 *
 * @brief   This function is draw one point in sdram
 *
 * 			    @param  
 *									  x:0~127
                                      y:0~63
                                      t:1 fill 0 clear
 *   @return number of data transfered
 */


os_err_t lcd_drawpoint(u16 x,u16 y,u8 pixel)
{
    u8 pos,bx,temp=0;
    
    if(x>=(lcd_dev->lcd_solution.x_pixel)||y>=(lcd_dev->lcd_solution.y_pixel))
        return ERROR;//超出范围了.
    
    pos=7-y/8;
    bx=y%8;
    temp=1<<(7-bx);
    
    
    /*using buffer by this program*/	
    if(lcd_dev->buffer!=NULL)
    {	 if(pixel)
            lcd_dev->buffer[x][pos] |= temp;	
        else
            lcd_dev->buffer[x][pos] &= ~temp;
    }	
    return SUCCESS;	
}

/*********************************************************************
 * @fn      os_err_t lcd_read_point(u16 x,u16 y)
 *
 * @brief   This function is draw one point in sdram
 *
 * 			    @param  
 *									  x:0~127
                                      y:0~63
                                      t:1 fill 0 clear
 *   @return point data
 */


u8 lcd_read_point(u16 x,u16 y)
{
    u8 pos,bx,temp=0;
    
    if(x>=(lcd_dev->lcd_solution.x_pixel)||y>=(lcd_dev->lcd_solution.y_pixel))
        return ERROR;//超出范围了.
    
    pos=7-y/8;
    bx=y%8;
    temp=1<<(7-bx);
    
    
    /*using buffer by this program*/	
    if(lcd_dev->buffer!=NULL)
    {	 
         
            if((lcd_dev->buffer[x][pos]&temp) == temp)
						{
							return 1;
						}else
						{
							return 0;
						}
    }	
    return SUCCESS;	
}


/*********************************************************************
 * @fn       os_err_t OLED_ShowChar(u8 x,u8 y,u8 chr )
 *
 * @brief   //在指定位置显示一个字符,包括部分字符
 *
 * 			    @param  //x:0~127
 *									//y:0~63
 *   @return suecess
 */

os_err_t lcd_showchar(u8 x,u8 y,u16 chr )
{      			    
    u8 temp,t,t1;
    u8 y0=y;
    chr=chr-' ';//得到偏移后的值				   
    for(t=0 ; t<(lcd_dev->font.font_y_model) ;  t++)
    {   
        
        temp =	lcd_dev->font.font_ptr[chr][t];	
        for(t1=0; t1<8 ; t1++)
        {
            if(temp&0x80)lcd_drawpoint(x,y,pixel_fill);
            temp<<=1;
            y++;
            if((y-y0)==lcd_dev->font.font_y_model)
            {
                y=y0;
                x++;
                break;
            }
        }  	 
    }  
    
    return SUCCESS;		
}

/*********************************************************************
 * @fn       os_err_t lcd_showstring(u8 x,u8 y,const u8 *p)
 *
 * @brief   //在指定位置显示一个字符,包括部分字符
 *
 * 			    @param  //x:0~127
 *									//y:0~63
 *   @return suecess
 */

//os_err_t lcd_scroll(u8 lines)
//{
//    for(i=0 ; i< ((lcd_dev->lcd_solution.y_pixel)>>3) ; i++)  
//	{  
//		/*set refresh cursor*/
//   		lcd_position_set(0 , i);
//		for(n=0   ; n<lcd_dev->lcd_solution.x_pixel ; n++)
//		
//		   transfer_data(lcd_dev->buffer[n][i]);
//		
//	}   
//}


/*********************************************************************
 * @fn       os_err_t lcd_showstring(u8 x,u8 y,const u8 *p)
 *
 * @brief   //在指定位置显示一个字符,包括部分字符
 *
 * 			    @param  //x:0~127
 *									//y:0~63
 *   @return suecess
 */
static os_err_t lcd_showstring(u8 x,u8 y ,  const u8 *p , u16 size_1)
{
    /*check out the data*/          
    if(size_1<=0)
    {
        return ERROR;
    }
    
    while(size_1>0)
    {       
        if(x>(lcd_dev->lcd_solution.x_pixel-lcd_dev->font.font_x_model))
        {  
            x=0;
            y+=lcd_dev->font.font_y_model;
        }
        
        if(y>((lcd_dev->lcd_solution.y_pixel - lcd_dev->font.font_y_model)))
        {
            y=x=0;
#ifdef   LCD__SCROLL_MODE_
            clear_screen(0x00);  
#else						
            clear_screen(0x00);
#endif
        }
        
        lcd_showchar(x,y,*p);
        
        x+=lcd_dev->font.font_x_model;
        
        p++;
        
        size_1--;
        
    } 
    /* record current cursor positon*/		
    lcd_dev->cursor_record.x_cord=x;
    lcd_dev->cursor_record.y_cord=y;
    
    return SUCCESS;
}	


void lcd_printf()
{
		
}

#ifdef _CONSOLE_DEVICE_LCD_OPEN
struct __FILE  
{  
    int handle;  
};  
FILE __stdout;  

void _sys_exit(int x)  
{  
    x = x;  
}

int fputc(int ch, FILE *f)
{
    u8 ch_temp=ch;
    if(ch_temp=='\n')
    {		
        lcd_dev->cursor_record.y_cord += lcd_dev->font.font_y_model;
        
    }else if(ch_temp=='\r')
    {
        lcd_dev->cursor_record.x_cord = 0;
    }else
    {
        lcd_showstring(lcd_dev->cursor_record.x_cord , lcd_dev->cursor_record.y_cord , &ch_temp , 1  );
        lcd_refresh_buffer();
    }
    return ch;
}

#endif
/*********************************************************************
 *
 * @brief   This function is write driver for uart1
 *
* 			    @param dev: device poniter 
*								   pos: offset in the data
*									 buffer: data need tansfering
* 								 size: data size tansfered
 *   @return number of data transfered
 */

#ifdef __FONT_16X8_
static const  unsigned char font16x8[95][16]={	  
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
    {0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xCC,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*"!",1*/
    {0x00,0x00,0x08,0x00,0x30,0x00,0x60,0x00,0x08,0x00,0x30,0x00,0x60,0x00,0x00,0x00},/*""",2*/
    {0x02,0x20,0x03,0xFC,0x1E,0x20,0x02,0x20,0x03,0xFC,0x1E,0x20,0x02,0x20,0x00,0x00},/*"#",3*/
    {0x00,0x00,0x0E,0x18,0x11,0x04,0x3F,0xFF,0x10,0x84,0x0C,0x78,0x00,0x00,0x00,0x00},/*"$",4*/
    {0x0F,0x00,0x10,0x84,0x0F,0x38,0x00,0xC0,0x07,0x78,0x18,0x84,0x00,0x78,0x00,0x00},/*"%",5*/
    {0x00,0x78,0x0F,0x84,0x10,0xC4,0x11,0x24,0x0E,0x98,0x00,0xE4,0x00,0x84,0x00,0x08},/*"&",6*/
    {0x08,0x00,0x68,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
    {0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x18,0x18,0x20,0x04,0x40,0x02,0x00,0x00},/*"(",8*/
    {0x00,0x00,0x40,0x02,0x20,0x04,0x18,0x18,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00},/*")",9*/
    {0x02,0x40,0x02,0x40,0x01,0x80,0x0F,0xF0,0x01,0x80,0x02,0x40,0x02,0x40,0x00,0x00},/*"*",10*/
    {0x00,0x80,0x00,0x80,0x00,0x80,0x0F,0xF8,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00},/*"+",11*/
    {0x00,0x01,0x00,0x0D,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*",",12*/
    {0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},/*"-",13*/
    {0x00,0x00,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*".",14*/
    {0x00,0x00,0x00,0x06,0x00,0x18,0x00,0x60,0x01,0x80,0x06,0x00,0x18,0x00,0x20,0x00},/*"/",15*/
    {0x00,0x00,0x07,0xF0,0x08,0x08,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"0",16*/
    {0x00,0x00,0x08,0x04,0x08,0x04,0x1F,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"1",17*/
    {0x00,0x00,0x0E,0x0C,0x10,0x14,0x10,0x24,0x10,0x44,0x11,0x84,0x0E,0x0C,0x00,0x00},/*"2",18*/
    {0x00,0x00,0x0C,0x18,0x10,0x04,0x11,0x04,0x11,0x04,0x12,0x88,0x0C,0x70,0x00,0x00},/*"3",19*/
    {0x00,0x00,0x00,0xE0,0x03,0x20,0x04,0x24,0x08,0x24,0x1F,0xFC,0x00,0x24,0x00,0x00},/*"4",20*/
    {0x00,0x00,0x1F,0x98,0x10,0x84,0x11,0x04,0x11,0x04,0x10,0x88,0x10,0x70,0x00,0x00},/*"5",21*/
    {0x00,0x00,0x07,0xF0,0x08,0x88,0x11,0x04,0x11,0x04,0x18,0x88,0x00,0x70,0x00,0x00},/*"6",22*/
    {0x00,0x00,0x1C,0x00,0x10,0x00,0x10,0xFC,0x13,0x00,0x1C,0x00,0x10,0x00,0x00,0x00},/*"7",23*/
    {0x00,0x00,0x0E,0x38,0x11,0x44,0x10,0x84,0x10,0x84,0x11,0x44,0x0E,0x38,0x00,0x00},/*"8",24*/
    {0x00,0x00,0x07,0x00,0x08,0x8C,0x10,0x44,0x10,0x44,0x08,0x88,0x07,0xF0,0x00,0x00},/*"9",25*/
    {0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0C,0x03,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*":",26*/
    {0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*";",27*/
    {0x00,0x00,0x00,0x80,0x01,0x40,0x02,0x20,0x04,0x10,0x08,0x08,0x10,0x04,0x00,0x00},/*"<",28*/
    {0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x00,0x00},/*"=",29*/
    {0x00,0x00,0x10,0x04,0x08,0x08,0x04,0x10,0x02,0x20,0x01,0x40,0x00,0x80,0x00,0x00},/*">",30*/
    {0x00,0x00,0x0E,0x00,0x12,0x00,0x10,0x0C,0x10,0x6C,0x10,0x80,0x0F,0x00,0x00,0x00},/*"?",31*/
    {0x03,0xE0,0x0C,0x18,0x13,0xE4,0x14,0x24,0x17,0xC4,0x08,0x28,0x07,0xD0,0x00,0x00},/*"@",32*/
    {0x00,0x04,0x00,0x3C,0x03,0xC4,0x1C,0x40,0x07,0x40,0x00,0xE4,0x00,0x1C,0x00,0x04},/*"A",33*/
    {0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x04,0x11,0x04,0x0E,0x88,0x00,0x70,0x00,0x00},/*"B",34*/
    {0x03,0xE0,0x0C,0x18,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x08,0x1C,0x10,0x00,0x00},/*"C",35*/
    {0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"D",36*/
    {0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x04,0x17,0xC4,0x10,0x04,0x08,0x18,0x00,0x00},/*"E",37*/
    {0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x00,0x17,0xC0,0x10,0x00,0x08,0x00,0x00,0x00},/*"F",38*/
    {0x03,0xE0,0x0C,0x18,0x10,0x04,0x10,0x04,0x10,0x44,0x1C,0x78,0x00,0x40,0x00,0x00},/*"G",39*/
    {0x10,0x04,0x1F,0xFC,0x10,0x84,0x00,0x80,0x00,0x80,0x10,0x84,0x1F,0xFC,0x10,0x04},/*"H",40*/
    {0x00,0x00,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x00,0x00,0x00,0x00},/*"I",41*/
    {0x00,0x03,0x00,0x01,0x10,0x01,0x10,0x01,0x1F,0xFE,0x10,0x00,0x10,0x00,0x00,0x00},/*"J",42*/
    {0x10,0x04,0x1F,0xFC,0x11,0x04,0x03,0x80,0x14,0x64,0x18,0x1C,0x10,0x04,0x00,0x00},/*"K",43*/
    {0x10,0x04,0x1F,0xFC,0x10,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x0C,0x00,0x00},/*"L",44*/
    {0x10,0x04,0x1F,0xFC,0x1F,0x00,0x00,0xFC,0x1F,0x00,0x1F,0xFC,0x10,0x04,0x00,0x00},/*"M",45*/
    {0x10,0x04,0x1F,0xFC,0x0C,0x04,0x03,0x00,0x00,0xE0,0x10,0x18,0x1F,0xFC,0x10,0x00},/*"N",46*/
    {0x07,0xF0,0x08,0x08,0x10,0x04,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"O",47*/
    {0x10,0x04,0x1F,0xFC,0x10,0x84,0x10,0x80,0x10,0x80,0x10,0x80,0x0F,0x00,0x00,0x00},/*"P",48*/
    {0x07,0xF0,0x08,0x18,0x10,0x24,0x10,0x24,0x10,0x1C,0x08,0x0A,0x07,0xF2,0x00,0x00},/*"Q",49*/
    {0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x00,0x11,0xC0,0x11,0x30,0x0E,0x0C,0x00,0x04},/*"R",50*/
    {0x00,0x00,0x0E,0x1C,0x11,0x04,0x10,0x84,0x10,0x84,0x10,0x44,0x1C,0x38,0x00,0x00},/*"S",51*/
    {0x18,0x00,0x10,0x00,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x00,0x18,0x00,0x00,0x00},/*"T",52*/
    {0x10,0x00,0x1F,0xF8,0x10,0x04,0x00,0x04,0x00,0x04,0x10,0x04,0x1F,0xF8,0x10,0x00},/*"U",53*/
    {0x10,0x00,0x1E,0x00,0x11,0xE0,0x00,0x1C,0x00,0x70,0x13,0x80,0x1C,0x00,0x10,0x00},/*"V",54*/
    {0x1F,0xC0,0x10,0x3C,0x00,0xE0,0x1F,0x00,0x00,0xE0,0x10,0x3C,0x1F,0xC0,0x00,0x00},/*"W",55*/
    {0x10,0x04,0x18,0x0C,0x16,0x34,0x01,0xC0,0x01,0xC0,0x16,0x34,0x18,0x0C,0x10,0x04},/*"X",56*/
    {0x10,0x00,0x1C,0x00,0x13,0x04,0x00,0xFC,0x13,0x04,0x1C,0x00,0x10,0x00,0x00,0x00},/*"Y",57*/
    {0x08,0x04,0x10,0x1C,0x10,0x64,0x10,0x84,0x13,0x04,0x1C,0x04,0x10,0x18,0x00,0x00},/*"Z",58*/
    {0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFE,0x40,0x02,0x40,0x02,0x40,0x02,0x00,0x00},/*"[",59*/
    {0x00,0x00,0x30,0x00,0x0C,0x00,0x03,0x80,0x00,0x60,0x00,0x1C,0x00,0x03,0x00,0x00},/*"\",60*/
    {0x00,0x00,0x40,0x02,0x40,0x02,0x40,0x02,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00},/*"]",61*/
    {0x00,0x00,0x00,0x00,0x20,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x00,0x00},/*"^",62*/
    {0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01},/*"_",63*/
    {0x00,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
    {0x00,0x00,0x00,0x98,0x01,0x24,0x01,0x44,0x01,0x44,0x01,0x44,0x00,0xFC,0x00,0x04},/*"a",65*/
    {0x10,0x00,0x1F,0xFC,0x00,0x88,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x70,0x00,0x00},/*"b",66*/
    {0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x00},/*"c",67*/
    {0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x11,0x08,0x1F,0xFC,0x00,0x04},/*"d",68*/
    {0x00,0x00,0x00,0xF8,0x01,0x44,0x01,0x44,0x01,0x44,0x01,0x44,0x00,0xC8,0x00,0x00},/*"e",69*/
    {0x00,0x00,0x01,0x04,0x01,0x04,0x0F,0xFC,0x11,0x04,0x11,0x04,0x11,0x00,0x18,0x00},/*"f",70*/
    {0x00,0x00,0x00,0xD6,0x01,0x29,0x01,0x29,0x01,0x29,0x01,0xC9,0x01,0x06,0x00,0x00},/*"g",71*/
    {0x10,0x04,0x1F,0xFC,0x00,0x84,0x01,0x00,0x01,0x00,0x01,0x04,0x00,0xFC,0x00,0x04},/*"h",72*/
    {0x00,0x00,0x01,0x04,0x19,0x04,0x19,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"i",73*/
    {0x00,0x00,0x00,0x03,0x00,0x01,0x01,0x01,0x19,0x01,0x19,0xFE,0x00,0x00,0x00,0x00},/*"j",74*/
    {0x10,0x04,0x1F,0xFC,0x00,0x24,0x00,0x40,0x01,0xB4,0x01,0x0C,0x01,0x04,0x00,0x00},/*"k",75*/
    {0x00,0x00,0x10,0x04,0x10,0x04,0x1F,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"l",76*/
    {0x01,0x04,0x01,0xFC,0x01,0x04,0x01,0x00,0x01,0xFC,0x01,0x04,0x01,0x00,0x00,0xFC},/*"m",77*/
    {0x01,0x04,0x01,0xFC,0x00,0x84,0x01,0x00,0x01,0x00,0x01,0x04,0x00,0xFC,0x00,0x04},/*"n",78*/
    {0x00,0x00,0x00,0xF8,0x01,0x04,0x01,0x04,0x01,0x04,0x01,0x04,0x00,0xF8,0x00,0x00},/*"o",79*/
    {0x01,0x01,0x01,0xFF,0x00,0x85,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x70,0x00,0x00},/*"p",80*/
    {0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x01,0x05,0x01,0xFF,0x00,0x01},/*"q",81*/
    {0x01,0x04,0x01,0x04,0x01,0xFC,0x00,0x84,0x01,0x04,0x01,0x00,0x01,0x80,0x00,0x00},/*"r",82*/
    {0x00,0x00,0x00,0xCC,0x01,0x24,0x01,0x24,0x01,0x24,0x01,0x24,0x01,0x98,0x00,0x00},/*"s",83*/
    {0x00,0x00,0x01,0x00,0x01,0x00,0x07,0xF8,0x01,0x04,0x01,0x04,0x00,0x00,0x00,0x00},/*"t",84*/
    {0x01,0x00,0x01,0xF8,0x00,0x04,0x00,0x04,0x00,0x04,0x01,0x08,0x01,0xFC,0x00,0x04},/*"u",85*/
    {0x01,0x00,0x01,0x80,0x01,0x70,0x00,0x0C,0x00,0x10,0x01,0x60,0x01,0x80,0x01,0x00},/*"v",86*/
    {0x01,0xF0,0x01,0x0C,0x00,0x30,0x01,0xC0,0x00,0x30,0x01,0x0C,0x01,0xF0,0x01,0x00},/*"w",87*/
    {0x00,0x00,0x01,0x04,0x01,0x8C,0x00,0x74,0x01,0x70,0x01,0x8C,0x01,0x04,0x00,0x00},/*"x",88*/
    {0x01,0x01,0x01,0x81,0x01,0x71,0x00,0x0E,0x00,0x18,0x01,0x60,0x01,0x80,0x01,0x00},/*"y",89*/
    {0x00,0x00,0x01,0x84,0x01,0x0C,0x01,0x34,0x01,0x44,0x01,0x84,0x01,0x0C,0x00,0x00},/*"z",90*/
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x3E,0xFC,0x40,0x02,0x40,0x02},/*"{",91*/
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00},/*"|",92*/
    {0x00,0x00,0x40,0x02,0x40,0x02,0x3E,0xFC,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"}",93*/
    {0x00,0x00,0x60,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x20,0x00},/*"~",94*/
}; 

#else 

#ifdef _FONT6X8_

static const unsigned char  font6x8[][6] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // sp
    { 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00 },   // !
    { 0x00, 0x00, 0x07, 0x00, 0x07, 0x00 },   // "
    { 0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14 },   // #
    { 0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12 },   // $
    { 0x00, 0x62, 0x64, 0x08, 0x13, 0x23 },   // %
    { 0x00, 0x36, 0x49, 0x55, 0x22, 0x50 },   // &
    { 0x00, 0x00, 0x05, 0x03, 0x00, 0x00 },   // '
    { 0x00, 0x00, 0x1c, 0x22, 0x41, 0x00 },   // (
    { 0x00, 0x00, 0x41, 0x22, 0x1c, 0x00 },   // )
    { 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14 },   // *
    { 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08 },   // +
    { 0x00, 0x00, 0x00, 0xA0, 0x60, 0x00 },   // ,
    { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08 },   // -
    { 0x00, 0x00, 0x60, 0x60, 0x00, 0x00 },   // .
    { 0x00, 0x20, 0x10, 0x08, 0x04, 0x02 },   // /
    { 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E },   // 0
    { 0x00, 0x00, 0x42, 0x7F, 0x40, 0x00 },   // 1
    { 0x00, 0x42, 0x61, 0x51, 0x49, 0x46 },   // 2
    { 0x00, 0x21, 0x41, 0x45, 0x4B, 0x31 },   // 3
    { 0x00, 0x18, 0x14, 0x12, 0x7F, 0x10 },   // 4
    { 0x00, 0x27, 0x45, 0x45, 0x45, 0x39 },   // 5
    { 0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30 },   // 6
    { 0x00, 0x01, 0x71, 0x09, 0x05, 0x03 },   // 7
    { 0x00, 0x36, 0x49, 0x49, 0x49, 0x36 },   // 8
    { 0x00, 0x06, 0x49, 0x49, 0x29, 0x1E },   // 9
    { 0x00, 0x00, 0x36, 0x36, 0x00, 0x00 },   // :
    { 0x00, 0x00, 0x56, 0x36, 0x00, 0x00 },   // ;
    { 0x00, 0x08, 0x14, 0x22, 0x41, 0x00 },   // <
    { 0x00, 0x14, 0x14, 0x14, 0x14, 0x14 },   // =
    { 0x00, 0x00, 0x41, 0x22, 0x14, 0x08 },   // >
    { 0x00, 0x02, 0x01, 0x51, 0x09, 0x06 },   // ?
    { 0x00, 0x32, 0x49, 0x59, 0x51, 0x3E },   // @
    { 0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C },   // A
    { 0x00, 0x7F, 0x49, 0x49, 0x49, 0x36 },   // B
    { 0x00, 0x3E, 0x41, 0x41, 0x41, 0x22 },   // C
    { 0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C },   // D
    { 0x00, 0x7F, 0x49, 0x49, 0x49, 0x41 },   // E
    { 0x00, 0x7F, 0x09, 0x09, 0x09, 0x01 },   // F
    { 0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A },   // G
    { 0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F },   // H
    { 0x00, 0x00, 0x41, 0x7F, 0x41, 0x00 },   // I
    { 0x00, 0x20, 0x40, 0x41, 0x3F, 0x01 },   // J
    { 0x00, 0x7F, 0x08, 0x14, 0x22, 0x41 },   // K
    { 0x00, 0x7F, 0x40, 0x40, 0x40, 0x40 },   // L
    { 0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F },   // M
    { 0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F },   // N
    { 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E },   // O
    { 0x00, 0x7F, 0x09, 0x09, 0x09, 0x06 },   // P
    { 0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E },   // Q
    { 0x00, 0x7F, 0x09, 0x19, 0x29, 0x46 },   // R
    { 0x00, 0x46, 0x49, 0x49, 0x49, 0x31 },   // S
    { 0x00, 0x01, 0x01, 0x7F, 0x01, 0x01 },   // T
    { 0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F },   // U
    { 0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F },   // V
    { 0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F },   // W
    { 0x00, 0x63, 0x14, 0x08, 0x14, 0x63 },   // X
    { 0x00, 0x07, 0x08, 0x70, 0x08, 0x07 },   // Y
    { 0x00, 0x61, 0x51, 0x49, 0x45, 0x43 },   // Z
    { 0x00, 0x00, 0x7F, 0x41, 0x41, 0x00 },   // [
    { 0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55 },   // 55
    { 0x00, 0x00, 0x41, 0x41, 0x7F, 0x00 },   // ]
    { 0x00, 0x04, 0x02, 0x01, 0x02, 0x04 },   // ^
    { 0x00, 0x40, 0x40, 0x40, 0x40, 0x40 },   // _
    { 0x00, 0x00, 0x01, 0x02, 0x04, 0x00 },   // '
    { 0x00, 0x20, 0x54, 0x54, 0x54, 0x78 },   // a
    { 0x00, 0x7F, 0x48, 0x44, 0x44, 0x38 },   // b
    { 0x00, 0x38, 0x44, 0x44, 0x44, 0x20 },   // c
    { 0x00, 0x38, 0x44, 0x44, 0x48, 0x7F },   // d
    { 0x00, 0x38, 0x54, 0x54, 0x54, 0x18 },   // e
    { 0x00, 0x08, 0x7E, 0x09, 0x01, 0x02 },   // f
    { 0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C },   // g
    { 0x00, 0x7F, 0x08, 0x04, 0x04, 0x78 },   // h
    { 0x00, 0x00, 0x44, 0x7D, 0x40, 0x00 },   // i
    { 0x00, 0x40, 0x80, 0x84, 0x7D, 0x00 },   // j
    { 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00 },   // k
    { 0x00, 0x00, 0x41, 0x7F, 0x40, 0x00 },   // l
    { 0x00, 0x7C, 0x04, 0x18, 0x04, 0x78 },   // m
    { 0x00, 0x7C, 0x08, 0x04, 0x04, 0x78 },   // n
    { 0x00, 0x38, 0x44, 0x44, 0x44, 0x38 },   // o
    { 0x00, 0xFC, 0x24, 0x24, 0x24, 0x18 },   // p
    { 0x00, 0x18, 0x24, 0x24, 0x18, 0xFC },   // q
    { 0x00, 0x7C, 0x08, 0x04, 0x04, 0x08 },   // r
    { 0x00, 0x48, 0x54, 0x54, 0x54, 0x20 },   // s
    { 0x00, 0x04, 0x3F, 0x44, 0x40, 0x20 },   // t
    { 0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C },   // u
    { 0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C },   // v
    { 0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C },   // w
    { 0x00, 0x44, 0x28, 0x10, 0x28, 0x44 },   // x
    { 0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C },   // y
    { 0x00, 0x44, 0x64, 0x54, 0x4C, 0x44 },   // z
    { 0x14, 0x14, 0x14, 0x14, 0x14, 0x14 }    // horiz lines
};

#endif

#endif
